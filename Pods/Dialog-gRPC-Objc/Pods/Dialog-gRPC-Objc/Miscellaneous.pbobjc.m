// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: miscellaneous.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Miscellaneous.pbobjc.h"
#import "Wrappers.pbobjc.h"
#import "Definitions.pbobjc.h"
#import "Peers.pbobjc.h"
#import "Scalapb.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Any);
GPBObjCClassDeclaration(CallsConfig);
GPBObjCClassDeclaration(Config);
GPBObjCClassDeclaration(Discover);
GPBObjCClassDeclaration(GPBBoolValue);
GPBObjCClassDeclaration(GPBDoubleValue);
GPBObjCClassDeclaration(GPBInt32Value);
GPBObjCClassDeclaration(GPBInt64Value);
GPBObjCClassDeclaration(GPBStringValue);
GPBObjCClassDeclaration(InvitesConfig);
GPBObjCClassDeclaration(OutPeer);
GPBObjCClassDeclaration(RecursiveMapValue);
GPBObjCClassDeclaration(RecursiveMapValue_Array);
GPBObjCClassDeclaration(RecursiveMapValue_Item);
GPBObjCClassDeclaration(RecursiveMapValue_Value);
GPBObjCClassDeclaration(ServerMetaInfo);
GPBObjCClassDeclaration(ServicePeers);
GPBObjCClassDeclaration(UUIDValue);

#pragma mark - MiscellaneousRoot

@implementation MiscellaneousRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[DefinitionsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - MiscellaneousRoot_FileDescriptor

static GPBFileDescriptor *MiscellaneousRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"dialog"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum SupportedServerMethodsType

GPBEnumDescriptor *SupportedServerMethodsType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NoneSupportedMethods\000ChangePassword\000";
    static const int32_t values[] = {
        SupportedServerMethodsType_NoneSupportedMethods,
        SupportedServerMethodsType_ChangePassword,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SupportedServerMethodsType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SupportedServerMethodsType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SupportedServerMethodsType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SupportedServerMethodsType_NoneSupportedMethods:
    case SupportedServerMethodsType_ChangePassword:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RtcpMuxPolicy

GPBEnumDescriptor *RtcpMuxPolicy_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RtcpmuxpolicyUnknown\000RtcpmuxpolicyNegoti"
        "ate\000RtcpmuxpolicyRequire\000";
    static const int32_t values[] = {
        RtcpMuxPolicy_RtcpmuxpolicyUnknown,
        RtcpMuxPolicy_RtcpmuxpolicyNegotiate,
        RtcpMuxPolicy_RtcpmuxpolicyRequire,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RtcpMuxPolicy)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RtcpMuxPolicy_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RtcpMuxPolicy_IsValidValue(int32_t value__) {
  switch (value__) {
    case RtcpMuxPolicy_RtcpmuxpolicyUnknown:
    case RtcpMuxPolicy_RtcpmuxpolicyNegotiate:
    case RtcpMuxPolicy_RtcpmuxpolicyRequire:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum UpdateOptimization

GPBEnumDescriptor *UpdateOptimization_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UpdateoptimizationUnknown\000Updateoptimiza"
        "tionStripEntities\000";
    static const int32_t values[] = {
        UpdateOptimization_UpdateoptimizationUnknown,
        UpdateOptimization_UpdateoptimizationStripEntities,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UpdateOptimization)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UpdateOptimization_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UpdateOptimization_IsValidValue(int32_t value__) {
  switch (value__) {
    case UpdateOptimization_UpdateoptimizationUnknown:
    case UpdateOptimization_UpdateoptimizationStripEntities:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ResponseVoid

@implementation ResponseVoid


typedef struct ResponseVoid__storage_ {
  uint32_t _has_storage_[1];
} ResponseVoid__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseVoid class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ResponseVoid__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseSeq

@implementation ResponseSeq

@dynamic seq;
@dynamic state;
@dynamic date;

typedef struct ResponseSeq__storage_ {
  uint32_t _has_storage_[1];
  int32_t seq;
  NSData *state;
  int64_t date;
} ResponseSeq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seq",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseSeq_FieldNumber_Seq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseSeq__storage_, seq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "state",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseSeq_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseSeq__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseSeq_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseSeq__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseSeq class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseSeq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseSeqDate

@implementation ResponseSeqDate

@dynamic seq;
@dynamic state;
@dynamic date;
@dynamic hasMid, mid;

typedef struct ResponseSeqDate__storage_ {
  uint32_t _has_storage_[1];
  int32_t seq;
  NSData *state;
  UUIDValue *mid;
  int64_t date;
} ResponseSeqDate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seq",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseSeqDate_FieldNumber_Seq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseSeqDate__storage_, seq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "state",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseSeqDate_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseSeqDate__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseSeqDate_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseSeqDate__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = ResponseSeqDate_FieldNumber_Mid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseSeqDate__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseSeqDate class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseSeqDate__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseSeqDateMid

@implementation ResponseSeqDateMid

@dynamic seq;
@dynamic state;
@dynamic date;
@dynamic hasMid, mid;

typedef struct ResponseSeqDateMid__storage_ {
  uint32_t _has_storage_[1];
  int32_t seq;
  NSData *state;
  UUIDValue *mid;
  int64_t date;
} ResponseSeqDateMid__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seq",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseSeqDateMid_FieldNumber_Seq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseSeqDateMid__storage_, seq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "state",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseSeqDateMid_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseSeqDateMid__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseSeqDateMid_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseSeqDateMid__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = ResponseSeqDateMid_FieldNumber_Mid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseSeqDateMid__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseSeqDateMid class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseSeqDateMid__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseBool

@implementation ResponseBool

@dynamic value;

typedef struct ResponseBool__storage_ {
  uint32_t _has_storage_[1];
} ResponseBool__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseBool_FieldNumber_Value,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseBool class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseBool__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Config

@implementation Config

@dynamic maxGroupSize;
@dynamic hasDiscover, discover;
@dynamic hasShareEndpoint, shareEndpoint;
@dynamic hasCallsConfig, callsConfig;
@dynamic hasGroupInviteConfig, groupInviteConfig;
@dynamic hasServerMetaInfo, serverMetaInfo;
@dynamic customProfileSchema;
@dynamic hasServicePeers, servicePeers;
@dynamic extensionsArray, extensionsArray_Count;
@dynamic clientKeepAlive;
@dynamic supportedMethodsArray, supportedMethodsArray_Count;
@dynamic maxChannelSize;

typedef struct Config__storage_ {
  uint32_t _has_storage_[1];
  int32_t maxGroupSize;
  int32_t maxChannelSize;
  Discover *discover;
  NSMutableArray *extensionsArray;
  GPBStringValue *shareEndpoint;
  CallsConfig *callsConfig;
  InvitesConfig *groupInviteConfig;
  ServerMetaInfo *serverMetaInfo;
  NSString *customProfileSchema;
  ServicePeers *servicePeers;
  GPBEnumArray *supportedMethodsArray;
  int64_t clientKeepAlive;
} Config__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "maxGroupSize",
        .dataTypeSpecific.clazz = Nil,
        .number = Config_FieldNumber_MaxGroupSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Config__storage_, maxGroupSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "discover",
        .dataTypeSpecific.clazz = GPBObjCClass(Discover),
        .number = Config_FieldNumber_Discover,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Config__storage_, discover),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Any),
        .number = Config_FieldNumber_ExtensionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Config__storage_, extensionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shareEndpoint",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = Config_FieldNumber_ShareEndpoint,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Config__storage_, shareEndpoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "callsConfig",
        .dataTypeSpecific.clazz = GPBObjCClass(CallsConfig),
        .number = Config_FieldNumber_CallsConfig,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Config__storage_, callsConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupInviteConfig",
        .dataTypeSpecific.clazz = GPBObjCClass(InvitesConfig),
        .number = Config_FieldNumber_GroupInviteConfig,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Config__storage_, groupInviteConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serverMetaInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(ServerMetaInfo),
        .number = Config_FieldNumber_ServerMetaInfo,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Config__storage_, serverMetaInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "customProfileSchema",
        .dataTypeSpecific.clazz = Nil,
        .number = Config_FieldNumber_CustomProfileSchema,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Config__storage_, customProfileSchema),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "servicePeers",
        .dataTypeSpecific.clazz = GPBObjCClass(ServicePeers),
        .number = Config_FieldNumber_ServicePeers,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Config__storage_, servicePeers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientKeepAlive",
        .dataTypeSpecific.clazz = Nil,
        .number = Config_FieldNumber_ClientKeepAlive,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Config__storage_, clientKeepAlive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "supportedMethodsArray",
        .dataTypeSpecific.enumDescFunc = SupportedServerMethodsType_EnumDescriptor,
        .number = Config_FieldNumber_SupportedMethodsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Config__storage_, supportedMethodsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "maxChannelSize",
        .dataTypeSpecific.clazz = Nil,
        .number = Config_FieldNumber_MaxChannelSize,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Config__storage_, maxChannelSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Config class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Config__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServicePeers

@implementation ServicePeers

@dynamic hasSecurity, security;
@dynamic hasSupport, support;
@dynamic hasStash, stash;

typedef struct ServicePeers__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *security;
  OutPeer *support;
  OutPeer *stash;
} ServicePeers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "security",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = ServicePeers_FieldNumber_Security,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServicePeers__storage_, security),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "support",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = ServicePeers_FieldNumber_Support,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ServicePeers__storage_, support),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stash",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = ServicePeers_FieldNumber_Stash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ServicePeers__storage_, stash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServicePeers class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServicePeers__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServerMetaInfo

@implementation ServerMetaInfo

@dynamic releaseDate;
@dynamic hasApiVersion, apiVersion;

typedef struct ServerMetaInfo__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Value *apiVersion;
  int64_t releaseDate;
} ServerMetaInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "releaseDate",
        .dataTypeSpecific.clazz = Nil,
        .number = ServerMetaInfo_FieldNumber_ReleaseDate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServerMetaInfo__storage_, releaseDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "apiVersion",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = ServerMetaInfo_FieldNumber_ApiVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ServerMetaInfo__storage_, apiVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServerMetaInfo class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServerMetaInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CallsConfig

@implementation CallsConfig

@dynamic hasCallsEnabled, callsEnabled;
@dynamic hasVideoCallsEnabled, videoCallsEnabled;
@dynamic hasGroupCallsEnabled, groupCallsEnabled;
@dynamic hasGroupCallsMaxMembers, groupCallsMaxMembers;
@dynamic rtcpMuxPolicy;
@dynamic hasEmojiSecurityEnabled, emojiSecurityEnabled;
@dynamic hasScreenSharingEnabled, screenSharingEnabled;

typedef struct CallsConfig__storage_ {
  uint32_t _has_storage_[1];
  RtcpMuxPolicy rtcpMuxPolicy;
  GPBBoolValue *callsEnabled;
  GPBBoolValue *videoCallsEnabled;
  GPBBoolValue *groupCallsEnabled;
  GPBInt32Value *groupCallsMaxMembers;
  GPBBoolValue *emojiSecurityEnabled;
  GPBBoolValue *screenSharingEnabled;
} CallsConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callsEnabled",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = CallsConfig_FieldNumber_CallsEnabled,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CallsConfig__storage_, callsEnabled),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "videoCallsEnabled",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = CallsConfig_FieldNumber_VideoCallsEnabled,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CallsConfig__storage_, videoCallsEnabled),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupCallsEnabled",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = CallsConfig_FieldNumber_GroupCallsEnabled,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CallsConfig__storage_, groupCallsEnabled),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupCallsMaxMembers",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = CallsConfig_FieldNumber_GroupCallsMaxMembers,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CallsConfig__storage_, groupCallsMaxMembers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rtcpMuxPolicy",
        .dataTypeSpecific.enumDescFunc = RtcpMuxPolicy_EnumDescriptor,
        .number = CallsConfig_FieldNumber_RtcpMuxPolicy,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CallsConfig__storage_, rtcpMuxPolicy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "emojiSecurityEnabled",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = CallsConfig_FieldNumber_EmojiSecurityEnabled,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CallsConfig__storage_, emojiSecurityEnabled),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "screenSharingEnabled",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = CallsConfig_FieldNumber_ScreenSharingEnabled,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CallsConfig__storage_, screenSharingEnabled),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CallsConfig class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CallsConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CallsConfig_RtcpMuxPolicy_RawValue(CallsConfig *message) {
  GPBDescriptor *descriptor = [CallsConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CallsConfig_FieldNumber_RtcpMuxPolicy];
  return GPBGetMessageRawEnumField(message, field);
}

void SetCallsConfig_RtcpMuxPolicy_RawValue(CallsConfig *message, int32_t value) {
  GPBDescriptor *descriptor = [CallsConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CallsConfig_FieldNumber_RtcpMuxPolicy];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - InvitesConfig

@implementation InvitesConfig

@dynamic hasBaseURL, baseURL;
@dynamic hasGroupInviteURLPrefix, groupInviteURLPrefix;
@dynamic hasResolveURLPrefix, resolveURLPrefix;
@dynamic hasShareInviteURL, shareInviteURL;

typedef struct InvitesConfig__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *baseURL;
  GPBStringValue *groupInviteURLPrefix;
  GPBStringValue *resolveURLPrefix;
  GPBStringValue *shareInviteURL;
} InvitesConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseURL",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InvitesConfig_FieldNumber_BaseURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvitesConfig__storage_, baseURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupInviteURLPrefix",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InvitesConfig_FieldNumber_GroupInviteURLPrefix,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvitesConfig__storage_, groupInviteURLPrefix),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resolveURLPrefix",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InvitesConfig_FieldNumber_ResolveURLPrefix,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InvitesConfig__storage_, resolveURLPrefix),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shareInviteURL",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InvitesConfig_FieldNumber_ShareInviteURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InvitesConfig__storage_, shareInviteURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvitesConfig class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvitesConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\004\241!!\000\002\005\246\241!!\246\000\003\007\241!!\246\000\004\005\246\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Discover

@implementation Discover

@dynamic peersArray, peersArray_Count;

typedef struct Discover__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersArray;
} Discover__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = Discover_FieldNumber_PeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Discover__storage_, peersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Discover class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Discover__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Extension

@implementation Extension

@dynamic id_p;
@dynamic data_p;

typedef struct Extension__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSData *data_p;
} Extension__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Extension_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Extension__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Extension_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Extension__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Extension class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Extension__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Any

@implementation Any

@dynamic typeURL;
@dynamic data_p;

typedef struct Any__storage_ {
  uint32_t _has_storage_[1];
  NSString *typeURL;
  NSData *data_p;
} Any__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "typeURL",
        .dataTypeSpecific.clazz = Nil,
        .number = Any_FieldNumber_TypeURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Any__storage_, typeURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Any_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Any__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Any class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Any__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateConfig

@implementation UpdateConfig

@dynamic hasConfig, config;
@dynamic hasConfigHash, configHash;

typedef struct UpdateConfig__storage_ {
  uint32_t _has_storage_[1];
  Config *config;
  GPBInt64Value *configHash;
} UpdateConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "config",
        .dataTypeSpecific.clazz = GPBObjCClass(Config),
        .number = UpdateConfig_FieldNumber_Config,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateConfig__storage_, config),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "configHash",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = UpdateConfig_FieldNumber_ConfigHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateConfig__storage_, configHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateConfig class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RecursiveMapValue

@implementation RecursiveMapValue

@dynamic itemsArray, itemsArray_Count;

typedef struct RecursiveMapValue__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} RecursiveMapValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(RecursiveMapValue_Item),
        .number = RecursiveMapValue_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RecursiveMapValue__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RecursiveMapValue class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RecursiveMapValue__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RecursiveMapValue_Value

@implementation RecursiveMapValue_Value

@dynamic valueOneOfCase;
@dynamic d;
@dynamic i32;
@dynamic i64;
@dynamic str;
@dynamic rec;
@dynamic arrayRec;

typedef struct RecursiveMapValue_Value__storage_ {
  uint32_t _has_storage_[2];
  GPBDoubleValue *d;
  GPBInt32Value *i32;
  GPBInt64Value *i64;
  GPBStringValue *str;
  RecursiveMapValue *rec;
  RecursiveMapValue_Array *arrayRec;
} RecursiveMapValue_Value__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "d",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDoubleValue),
        .number = RecursiveMapValue_Value_FieldNumber_D,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(RecursiveMapValue_Value__storage_, d),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "i32",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = RecursiveMapValue_Value_FieldNumber_I32,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(RecursiveMapValue_Value__storage_, i32),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "i64",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = RecursiveMapValue_Value_FieldNumber_I64,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(RecursiveMapValue_Value__storage_, i64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "str",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RecursiveMapValue_Value_FieldNumber_Str,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(RecursiveMapValue_Value__storage_, str),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rec",
        .dataTypeSpecific.clazz = GPBObjCClass(RecursiveMapValue),
        .number = RecursiveMapValue_Value_FieldNumber_Rec,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(RecursiveMapValue_Value__storage_, rec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "arrayRec",
        .dataTypeSpecific.clazz = GPBObjCClass(RecursiveMapValue_Array),
        .number = RecursiveMapValue_Value_FieldNumber_ArrayRec,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(RecursiveMapValue_Value__storage_, arrayRec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RecursiveMapValue_Value class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RecursiveMapValue_Value__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "value",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(RecursiveMapValue)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void RecursiveMapValue_Value_ClearValueOneOfCase(RecursiveMapValue_Value *message) {
  GPBDescriptor *descriptor = [RecursiveMapValue_Value descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - RecursiveMapValue_Array

@implementation RecursiveMapValue_Array

@dynamic valuesArray, valuesArray_Count;

typedef struct RecursiveMapValue_Array__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *valuesArray;
} RecursiveMapValue_Array__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valuesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(RecursiveMapValue_Value),
        .number = RecursiveMapValue_Array_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RecursiveMapValue_Array__storage_, valuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RecursiveMapValue_Array class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RecursiveMapValue_Array__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(RecursiveMapValue)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RecursiveMapValue_Item

@implementation RecursiveMapValue_Item

@dynamic key;
@dynamic hasValue, value;

typedef struct RecursiveMapValue_Item__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  RecursiveMapValue_Value *value;
} RecursiveMapValue_Item__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = RecursiveMapValue_Item_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RecursiveMapValue_Item__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = GPBObjCClass(RecursiveMapValue_Value),
        .number = RecursiveMapValue_Item_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RecursiveMapValue_Item__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RecursiveMapValue_Item class]
                                     rootClass:[MiscellaneousRoot class]
                                          file:MiscellaneousRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RecursiveMapValue_Item__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(RecursiveMapValue)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
