// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messaging.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Messaging.pbobjc.h"
#import "Wrappers.pbobjc.h"
#import "Empty.pbobjc.h"
#import "Duration.pbobjc.h"
#import "Annotations.pbobjc.h"
#import "Definitions.pbobjc.h"
#import "Miscellaneous.pbobjc.h"
#import "Peers.pbobjc.h"
#import "MediaAndFiles.pbobjc.h"
#import "Reactions.pbobjc.h"
#import "Scalapb.pbobjc.h"
#import "Groups.pbobjc.h"
#import "Threads.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Any);
GPBObjCClassDeclaration(AudioLocation);
GPBObjCClassDeclaration(AudioMedia);
GPBObjCClassDeclaration(Avatar);
GPBObjCClassDeclaration(BinaryMessage);
GPBObjCClassDeclaration(Color);
GPBObjCClassDeclaration(DeletedMessage);
GPBObjCClassDeclaration(Dialog);
GPBObjCClassDeclaration(DialogFilter);
GPBObjCClassDeclaration(DialogGroup);
GPBObjCClassDeclaration(DialogShort);
GPBObjCClassDeclaration(DocumentEx);
GPBObjCClassDeclaration(DocumentExPhoto);
GPBObjCClassDeclaration(DocumentExVideo);
GPBObjCClassDeclaration(DocumentExVoice);
GPBObjCClassDeclaration(DocumentMessage);
GPBObjCClassDeclaration(EmptyMessage);
GPBObjCClassDeclaration(FastThumb);
GPBObjCClassDeclaration(ForwardItem);
GPBObjCClassDeclaration(ForwardSource);
GPBObjCClassDeclaration(GPBBoolValue);
GPBObjCClassDeclaration(GPBBytesValue);
GPBObjCClassDeclaration(GPBDuration);
GPBObjCClassDeclaration(GPBInt32Value);
GPBObjCClassDeclaration(GPBInt64Value);
GPBObjCClassDeclaration(GPBStringValue);
GPBObjCClassDeclaration(GroupData);
GPBObjCClassDeclaration(GroupOutPeer);
GPBObjCClassDeclaration(HistoryMessage);
GPBObjCClassDeclaration(ImageLocation);
GPBObjCClassDeclaration(ImageMedia);
GPBObjCClassDeclaration(InteractiveMedia);
GPBObjCClassDeclaration(InteractiveMediaButton);
GPBObjCClassDeclaration(InteractiveMediaConfirm);
GPBObjCClassDeclaration(InteractiveMediaGroup);
GPBObjCClassDeclaration(InteractiveMediaSelect);
GPBObjCClassDeclaration(InteractiveMediaSelectOption);
GPBObjCClassDeclaration(InteractiveMediaTranslation);
GPBObjCClassDeclaration(InteractiveMediaTranslationGroup);
GPBObjCClassDeclaration(InteractiveMediaWidget);
GPBObjCClassDeclaration(JsonMessage);
GPBObjCClassDeclaration(Mention);
GPBObjCClassDeclaration(MessageAttributes);
GPBObjCClassDeclaration(MessageContent);
GPBObjCClassDeclaration(MessageMedia);
GPBObjCClassDeclaration(MessageOverrides);
GPBObjCClassDeclaration(MessageStatus);
GPBObjCClassDeclaration(OutPeer);
GPBObjCClassDeclaration(ParagraphStyle);
GPBObjCClassDeclaration(Peer);
GPBObjCClassDeclaration(PinnedMessages);
GPBObjCClassDeclaration(Reaction);
GPBObjCClassDeclaration(ReferencedMessages);
GPBObjCClassDeclaration(SearchPredicate);
GPBObjCClassDeclaration(ServiceEx);
GPBObjCClassDeclaration(ServiceExChangedAbout);
GPBObjCClassDeclaration(ServiceExChangedAvatar);
GPBObjCClassDeclaration(ServiceExChangedTitle);
GPBObjCClassDeclaration(ServiceExChangedTopic);
GPBObjCClassDeclaration(ServiceExChatArchived);
GPBObjCClassDeclaration(ServiceExChatRestored);
GPBObjCClassDeclaration(ServiceExConferenceStatus);
GPBObjCClassDeclaration(ServiceExContactRegistered);
GPBObjCClassDeclaration(ServiceExGroupCreated);
GPBObjCClassDeclaration(ServiceExGroupPublicityChanged);
GPBObjCClassDeclaration(ServiceExImportantTopicClosed);
GPBObjCClassDeclaration(ServiceExImportantTopicForked);
GPBObjCClassDeclaration(ServiceExImportantTopicReopened);
GPBObjCClassDeclaration(ServiceExPhoneCall);
GPBObjCClassDeclaration(ServiceExPhoneMissed);
GPBObjCClassDeclaration(ServiceExPhoneRejected);
GPBObjCClassDeclaration(ServiceExUserInvited);
GPBObjCClassDeclaration(ServiceExUserJoined);
GPBObjCClassDeclaration(ServiceExUserKicked);
GPBObjCClassDeclaration(ServiceExUserLeft);
GPBObjCClassDeclaration(ServiceMessage);
GPBObjCClassDeclaration(StickerMessage);
GPBObjCClassDeclaration(TextCommand);
GPBObjCClassDeclaration(TextExMarkdown);
GPBObjCClassDeclaration(TextMessage);
GPBObjCClassDeclaration(TextMessageEx);
GPBObjCClassDeclaration(TextModernAttach);
GPBObjCClassDeclaration(TextModernField);
GPBObjCClassDeclaration(TextModernMessage);
GPBObjCClassDeclaration(ThreadInfo);
GPBObjCClassDeclaration(UUIDValue);
GPBObjCClassDeclaration(UnsupportedMessage);
GPBObjCClassDeclaration(UpdateErrorCause);
GPBObjCClassDeclaration(UserOutPeer);
GPBObjCClassDeclaration(WebpageMedia);

#pragma mark - MessagingRoot

@implementation MessagingRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[GAPIAnnotationsRoot extensionRegistry]];
    [registry addExtensions:[DefinitionsRoot extensionRegistry]];
    [registry addExtensions:[ScalapbRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - MessagingRoot_FileDescriptor

static GPBFileDescriptor *MessagingRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"dialog"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum InteractiveMediaStyle

GPBEnumDescriptor *InteractiveMediaStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "InteractiveMediaStyleUnknown\000Interactive"
        "MediaStyleDefault\000InteractiveMediaStyleP"
        "rimary\000InteractiveMediaStyleDanger\000";
    static const int32_t values[] = {
        InteractiveMediaStyle_InteractiveMediaStyleUnknown,
        InteractiveMediaStyle_InteractiveMediaStyleDefault,
        InteractiveMediaStyle_InteractiveMediaStylePrimary,
        InteractiveMediaStyle_InteractiveMediaStyleDanger,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(InteractiveMediaStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:InteractiveMediaStyle_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL InteractiveMediaStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case InteractiveMediaStyle_InteractiveMediaStyleUnknown:
    case InteractiveMediaStyle_InteractiveMediaStyleDefault:
    case InteractiveMediaStyle_InteractiveMediaStylePrimary:
    case InteractiveMediaStyle_InteractiveMediaStyleDanger:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ListLoadMode

GPBEnumDescriptor *ListLoadMode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ListLoadModeUnknown\000ListLoadModeForward\000"
        "ListLoadModeBackward\000ListLoadModeBoth\000";
    static const int32_t values[] = {
        ListLoadMode_ListLoadModeUnknown,
        ListLoadMode_ListLoadModeForward,
        ListLoadMode_ListLoadModeBackward,
        ListLoadMode_ListLoadModeBoth,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ListLoadMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ListLoadMode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ListLoadMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ListLoadMode_ListLoadModeUnknown:
    case ListLoadMode_ListLoadModeForward:
    case ListLoadMode_ListLoadModeBackward:
    case ListLoadMode_ListLoadModeBoth:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MessageAttributes

@implementation MessageAttributes

@dynamic hasIsMentioned, isMentioned;
@dynamic unclassified, unclassified_Count;
@dynamic linkedPeersArray, linkedPeersArray_Count;
@dynamic hasIsRespondable, isRespondable;

typedef struct MessageAttributes__storage_ {
  uint32_t _has_storage_[1];
  GPBBoolValue *isMentioned;
  NSMutableDictionary *unclassified;
  NSMutableArray *linkedPeersArray;
  GPBBoolValue *isRespondable;
} MessageAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isMentioned",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = MessageAttributes_FieldNumber_IsMentioned,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageAttributes__storage_, isMentioned),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unclassified",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageAttributes_FieldNumber_Unclassified,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageAttributes__storage_, unclassified),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linkedPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = MessageAttributes_FieldNumber_LinkedPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageAttributes__storage_, linkedPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isRespondable",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = MessageAttributes_FieldNumber_IsRespondable,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageAttributes__storage_, isRespondable),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageAttributes class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageAttributes__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageMedia

@implementation MessageMedia

@dynamic hasWebpage, webpage;
@dynamic hasImage, image;
@dynamic hasAudio, audio;
@dynamic actionsArray, actionsArray_Count;

typedef struct MessageMedia__storage_ {
  uint32_t _has_storage_[1];
  WebpageMedia *webpage;
  ImageMedia *image;
  AudioMedia *audio;
  NSMutableArray *actionsArray;
} MessageMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "webpage",
        .dataTypeSpecific.clazz = GPBObjCClass(WebpageMedia),
        .number = MessageMedia_FieldNumber_Webpage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageMedia__storage_, webpage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageMedia),
        .number = MessageMedia_FieldNumber_Image,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageMedia__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.clazz = GPBObjCClass(AudioMedia),
        .number = MessageMedia_FieldNumber_Audio,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageMedia__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaGroup),
        .number = MessageMedia_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageMedia__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageMedia class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageMedia__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WebpageMedia

@implementation WebpageMedia

@dynamic hasURL, URL;
@dynamic hasTitle, title;
@dynamic hasDescription_p, description_p;
@dynamic hasImage, image;

typedef struct WebpageMedia__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *URL;
  GPBStringValue *title;
  GPBStringValue *description_p;
  ImageLocation *image;
} WebpageMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = WebpageMedia_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WebpageMedia__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = WebpageMedia_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WebpageMedia__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = WebpageMedia_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WebpageMedia__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageLocation),
        .number = WebpageMedia_FieldNumber_Image,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WebpageMedia__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WebpageMedia class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WebpageMedia__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ImageMedia

@implementation ImageMedia

@dynamic hasImage, image;

typedef struct ImageMedia__storage_ {
  uint32_t _has_storage_[1];
  ImageLocation *image;
} ImageMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "image",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageLocation),
        .number = ImageMedia_FieldNumber_Image,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ImageMedia__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ImageMedia class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ImageMedia__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AudioMedia

@implementation AudioMedia

@dynamic hasAudio, audio;

typedef struct AudioMedia__storage_ {
  uint32_t _has_storage_[1];
  AudioLocation *audio;
} AudioMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audio",
        .dataTypeSpecific.clazz = GPBObjCClass(AudioLocation),
        .number = AudioMedia_FieldNumber_Audio,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AudioMedia__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AudioMedia class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AudioMedia__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMediaWidget

@implementation InteractiveMediaWidget

@dynamic bodyOneOfCase;
@dynamic interactiveMediaButton;
@dynamic interactiveMediaSelect;

typedef struct InteractiveMediaWidget__storage_ {
  uint32_t _has_storage_[2];
  InteractiveMediaButton *interactiveMediaButton;
  InteractiveMediaSelect *interactiveMediaSelect;
} InteractiveMediaWidget__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "interactiveMediaButton",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaButton),
        .number = InteractiveMediaWidget_FieldNumber_InteractiveMediaButton,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InteractiveMediaWidget__storage_, interactiveMediaButton),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "interactiveMediaSelect",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaSelect),
        .number = InteractiveMediaWidget_FieldNumber_InteractiveMediaSelect,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InteractiveMediaWidget__storage_, interactiveMediaSelect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaWidget class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaWidget__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void InteractiveMediaWidget_ClearBodyOneOfCase(InteractiveMediaWidget *message) {
  GPBDescriptor *descriptor = [InteractiveMediaWidget descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - InteractiveMediaButton

@implementation InteractiveMediaButton

@dynamic value;
@dynamic hasLabel, label;

typedef struct InteractiveMediaButton__storage_ {
  uint32_t _has_storage_[1];
  NSString *value;
  GPBStringValue *label;
} InteractiveMediaButton__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMediaButton_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaButton__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaButton_FieldNumber_Label,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMediaButton__storage_, label),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaButton class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaButton__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMediaSelect

@implementation InteractiveMediaSelect

@dynamic optionsArray, optionsArray_Count;
@dynamic hasLabel, label;
@dynamic hasDefaultValue, defaultValue;

typedef struct InteractiveMediaSelect__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *optionsArray;
  GPBStringValue *label;
  GPBStringValue *defaultValue;
} InteractiveMediaSelect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "optionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaSelectOption),
        .number = InteractiveMediaSelect_FieldNumber_OptionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InteractiveMediaSelect__storage_, optionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaSelect_FieldNumber_Label,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaSelect__storage_, label),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "defaultValue",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaSelect_FieldNumber_DefaultValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMediaSelect__storage_, defaultValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaSelect class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaSelect__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMediaSelectOption

@implementation InteractiveMediaSelectOption

@dynamic value;
@dynamic label;

typedef struct InteractiveMediaSelectOption__storage_ {
  uint32_t _has_storage_[1];
  NSString *value;
  NSString *label;
} InteractiveMediaSelectOption__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMediaSelectOption_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaSelectOption__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMediaSelectOption_FieldNumber_Label,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMediaSelectOption__storage_, label),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaSelectOption class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaSelectOption__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMedia

@implementation InteractiveMedia

@dynamic id_p;
@dynamic hasWidget, widget;
@dynamic style;
@dynamic hasConfirm, confirm;

typedef struct InteractiveMedia__storage_ {
  uint32_t _has_storage_[1];
  InteractiveMediaStyle style;
  NSString *id_p;
  InteractiveMediaWidget *widget;
  InteractiveMediaConfirm *confirm;
} InteractiveMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMedia_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMedia__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "widget",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaWidget),
        .number = InteractiveMedia_FieldNumber_Widget,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMedia__storage_, widget),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "style",
        .dataTypeSpecific.enumDescFunc = InteractiveMediaStyle_EnumDescriptor,
        .number = InteractiveMedia_FieldNumber_Style,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InteractiveMedia__storage_, style),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "confirm",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaConfirm),
        .number = InteractiveMedia_FieldNumber_Confirm,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InteractiveMedia__storage_, confirm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMedia class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMedia__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t InteractiveMedia_Style_RawValue(InteractiveMedia *message) {
  GPBDescriptor *descriptor = [InteractiveMedia descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InteractiveMedia_FieldNumber_Style];
  return GPBGetMessageRawEnumField(message, field);
}

void SetInteractiveMedia_Style_RawValue(InteractiveMedia *message, int32_t value) {
  GPBDescriptor *descriptor = [InteractiveMedia descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InteractiveMedia_FieldNumber_Style];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - InteractiveMediaTranslation

@implementation InteractiveMediaTranslation

@dynamic id_p;
@dynamic value;

typedef struct InteractiveMediaTranslation__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *value;
} InteractiveMediaTranslation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMediaTranslation_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaTranslation__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMediaTranslation_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMediaTranslation__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaTranslation class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaTranslation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMediaTranslationGroup

@implementation InteractiveMediaTranslationGroup

@dynamic language;
@dynamic messagesArray, messagesArray_Count;

typedef struct InteractiveMediaTranslationGroup__storage_ {
  uint32_t _has_storage_[1];
  NSString *language;
  NSMutableArray *messagesArray;
} InteractiveMediaTranslationGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "language",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMediaTranslationGroup_FieldNumber_Language,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaTranslationGroup__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "messagesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaTranslation),
        .number = InteractiveMediaTranslationGroup_FieldNumber_MessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InteractiveMediaTranslationGroup__storage_, messagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaTranslationGroup class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaTranslationGroup__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMediaGroup

@implementation InteractiveMediaGroup

@dynamic actionsArray, actionsArray_Count;
@dynamic hasTitle, title;
@dynamic hasDescription_p, description_p;
@dynamic translationsArray, translationsArray_Count;

typedef struct InteractiveMediaGroup__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *actionsArray;
  GPBStringValue *title;
  GPBStringValue *description_p;
  NSMutableArray *translationsArray;
} InteractiveMediaGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "actionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMedia),
        .number = InteractiveMediaGroup_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InteractiveMediaGroup__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaGroup_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaGroup__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaGroup_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMediaGroup__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "translationsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaTranslationGroup),
        .number = InteractiveMediaGroup_FieldNumber_TranslationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InteractiveMediaGroup__storage_, translationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaGroup class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaGroup__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMediaConfirm

@implementation InteractiveMediaConfirm

@dynamic hasText, text;
@dynamic hasTitle, title;
@dynamic hasOk, ok;
@dynamic hasDismiss, dismiss;

typedef struct InteractiveMediaConfirm__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *text;
  GPBStringValue *title;
  GPBStringValue *ok;
  GPBStringValue *dismiss;
} InteractiveMediaConfirm__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaConfirm_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaConfirm__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaConfirm_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMediaConfirm__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ok",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaConfirm_FieldNumber_Ok,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InteractiveMediaConfirm__storage_, ok),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dismiss",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaConfirm_FieldNumber_Dismiss,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InteractiveMediaConfirm__storage_, dismiss),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaConfirm class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaConfirm__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateInteractiveMediaEvent

@implementation UpdateInteractiveMediaEvent

@dynamic hasMid, mid;
@dynamic id_p;
@dynamic value;
@dynamic userId;

typedef struct UpdateInteractiveMediaEvent__storage_ {
  uint32_t _has_storage_[1];
  UUIDValue *mid;
  NSString *id_p;
  NSString *value;
  NSString *userId;
} UpdateInteractiveMediaEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateInteractiveMediaEvent_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateInteractiveMediaEvent__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateInteractiveMediaEvent_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateInteractiveMediaEvent__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateInteractiveMediaEvent_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateInteractiveMediaEvent__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateInteractiveMediaEvent_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateInteractiveMediaEvent__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateInteractiveMediaEvent class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateInteractiveMediaEvent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestDoInteractiveMediaAction

@implementation RequestDoInteractiveMediaAction

@dynamic hasMid, mid;
@dynamic id_p;
@dynamic value;

typedef struct RequestDoInteractiveMediaAction__storage_ {
  uint32_t _has_storage_[1];
  UUIDValue *mid;
  NSString *id_p;
  NSString *value;
} RequestDoInteractiveMediaAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestDoInteractiveMediaAction_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestDoInteractiveMediaAction__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestDoInteractiveMediaAction_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestDoInteractiveMediaAction__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestDoInteractiveMediaAction_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestDoInteractiveMediaAction__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestDoInteractiveMediaAction class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestDoInteractiveMediaAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageOverrides

@implementation MessageOverrides

@dynamic hasSenderNameOverride, senderNameOverride;
@dynamic hasSenderPhotoOverride, senderPhotoOverride;
@dynamic hasSenderPhotoURLOverride, senderPhotoURLOverride;

typedef struct MessageOverrides__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *senderNameOverride;
  Avatar *senderPhotoOverride;
  GPBStringValue *senderPhotoURLOverride;
} MessageOverrides__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderNameOverride",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = MessageOverrides_FieldNumber_SenderNameOverride,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageOverrides__storage_, senderNameOverride),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "senderPhotoOverride",
        .dataTypeSpecific.clazz = GPBObjCClass(Avatar),
        .number = MessageOverrides_FieldNumber_SenderPhotoOverride,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageOverrides__storage_, senderPhotoOverride),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "senderPhotoURLOverride",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = MessageOverrides_FieldNumber_SenderPhotoURLOverride,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageOverrides__storage_, senderPhotoURLOverride),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageOverrides class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageOverrides__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\006\245\241!!\250\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageContent

@implementation MessageContent

@dynamic bodyOneOfCase;
@dynamic textMessage;
@dynamic serviceMessage;
@dynamic documentMessage;
@dynamic jsonMessage;
@dynamic unsupportedMessage;
@dynamic stickerMessage;
@dynamic binaryMessage;
@dynamic emptyMessage;
@dynamic deletedMessage;
@dynamic hasOverrides, overrides;
@dynamic extensionsArray, extensionsArray_Count;
@dynamic disableNotifications;

typedef struct MessageContent__storage_ {
  uint32_t _has_storage_[2];
  TextMessage *textMessage;
  ServiceMessage *serviceMessage;
  DocumentMessage *documentMessage;
  JsonMessage *jsonMessage;
  UnsupportedMessage *unsupportedMessage;
  StickerMessage *stickerMessage;
  BinaryMessage *binaryMessage;
  EmptyMessage *emptyMessage;
  DeletedMessage *deletedMessage;
  MessageOverrides *overrides;
  NSMutableArray *extensionsArray;
} MessageContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "textMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(TextMessage),
        .number = MessageContent_FieldNumber_TextMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, textMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serviceMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceMessage),
        .number = MessageContent_FieldNumber_ServiceMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, serviceMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "documentMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(DocumentMessage),
        .number = MessageContent_FieldNumber_DocumentMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, documentMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "jsonMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonMessage),
        .number = MessageContent_FieldNumber_JsonMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, jsonMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unsupportedMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(UnsupportedMessage),
        .number = MessageContent_FieldNumber_UnsupportedMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, unsupportedMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stickerMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(StickerMessage),
        .number = MessageContent_FieldNumber_StickerMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, stickerMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "binaryMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(BinaryMessage),
        .number = MessageContent_FieldNumber_BinaryMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, binaryMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "emptyMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(EmptyMessage),
        .number = MessageContent_FieldNumber_EmptyMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, emptyMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deletedMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(DeletedMessage),
        .number = MessageContent_FieldNumber_DeletedMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, deletedMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "overrides",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageOverrides),
        .number = MessageContent_FieldNumber_Overrides,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageContent__storage_, overrides),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Any),
        .number = MessageContent_FieldNumber_ExtensionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageContent__storage_, extensionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "disableNotifications",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageContent_FieldNumber_DisableNotifications,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageContent class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageContent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void MessageContent_ClearBodyOneOfCase(MessageContent *message) {
  GPBDescriptor *descriptor = [MessageContent descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - TextMessage

@implementation TextMessage

@dynamic text;
@dynamic hasExt, ext;
@dynamic mediaArray, mediaArray_Count;
@dynamic extensionsArray, extensionsArray_Count;
@dynamic mentionsArray, mentionsArray_Count;

typedef struct TextMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
  TextMessageEx *ext;
  NSMutableArray *mediaArray;
  NSMutableArray *extensionsArray;
  NSMutableArray *mentionsArray;
} TextMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = TextMessage_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextMessage__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ext",
        .dataTypeSpecific.clazz = GPBObjCClass(TextMessageEx),
        .number = TextMessage_FieldNumber_Ext,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextMessage__storage_, ext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mediaArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageMedia),
        .number = TextMessage_FieldNumber_MediaArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextMessage__storage_, mediaArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Any),
        .number = TextMessage_FieldNumber_ExtensionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextMessage__storage_, extensionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mentionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Mention),
        .number = TextMessage_FieldNumber_MentionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextMessage__storage_, mentionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Mention

@implementation Mention

@dynamic hasPeer, peer;
@dynamic all;

typedef struct Mention__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
} Mention__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = Mention_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Mention__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "all",
        .dataTypeSpecific.clazz = Nil,
        .number = Mention_FieldNumber_All,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Mention class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Mention__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextMessageEx

@implementation TextMessageEx

@dynamic bodyOneOfCase;
@dynamic textExMarkdown;
@dynamic textModernMessage;
@dynamic textCommand;

typedef struct TextMessageEx__storage_ {
  uint32_t _has_storage_[2];
  TextExMarkdown *textExMarkdown;
  TextModernMessage *textModernMessage;
  TextCommand *textCommand;
} TextMessageEx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "textExMarkdown",
        .dataTypeSpecific.clazz = GPBObjCClass(TextExMarkdown),
        .number = TextMessageEx_FieldNumber_TextExMarkdown,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TextMessageEx__storage_, textExMarkdown),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "textModernMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(TextModernMessage),
        .number = TextMessageEx_FieldNumber_TextModernMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TextMessageEx__storage_, textModernMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "textCommand",
        .dataTypeSpecific.clazz = GPBObjCClass(TextCommand),
        .number = TextMessageEx_FieldNumber_TextCommand,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TextMessageEx__storage_, textCommand),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextMessageEx class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextMessageEx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TextMessageEx_ClearBodyOneOfCase(TextMessageEx *message) {
  GPBDescriptor *descriptor = [TextMessageEx descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - TextExMarkdown

@implementation TextExMarkdown

@dynamic markdown;

typedef struct TextExMarkdown__storage_ {
  uint32_t _has_storage_[1];
  NSString *markdown;
} TextExMarkdown__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "markdown",
        .dataTypeSpecific.clazz = Nil,
        .number = TextExMarkdown_FieldNumber_Markdown,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextExMarkdown__storage_, markdown),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextExMarkdown class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextExMarkdown__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextModernMessage

@implementation TextModernMessage

@dynamic hasText, text;
@dynamic hasStyle, style;
@dynamic attachesArray, attachesArray_Count;

typedef struct TextModernMessage__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *text;
  ParagraphStyle *style;
  NSMutableArray *attachesArray;
} TextModernMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = TextModernMessage_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextModernMessage__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "style",
        .dataTypeSpecific.clazz = GPBObjCClass(ParagraphStyle),
        .number = TextModernMessage_FieldNumber_Style,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextModernMessage__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TextModernAttach),
        .number = TextModernMessage_FieldNumber_AttachesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextModernMessage__storage_, attachesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextModernMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextModernMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ParagraphStyle

@implementation ParagraphStyle

@dynamic hasShowParagraph, showParagraph;
@dynamic hasParagraphColor, paragraphColor;
@dynamic hasBgColor, bgColor;

typedef struct ParagraphStyle__storage_ {
  uint32_t _has_storage_[1];
  GPBBoolValue *showParagraph;
  Color *paragraphColor;
  Color *bgColor;
} ParagraphStyle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "showParagraph",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = ParagraphStyle_FieldNumber_ShowParagraph,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ParagraphStyle__storage_, showParagraph),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "paragraphColor",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = ParagraphStyle_FieldNumber_ParagraphColor,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ParagraphStyle__storage_, paragraphColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bgColor",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = ParagraphStyle_FieldNumber_BgColor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ParagraphStyle__storage_, bgColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ParagraphStyle class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ParagraphStyle__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextModernAttach

@implementation TextModernAttach

@dynamic hasTitle, title;
@dynamic hasTitleURL, titleURL;
@dynamic hasTitleIcon, titleIcon;
@dynamic hasText, text;
@dynamic hasStyle, style;
@dynamic fieldsArray, fieldsArray_Count;

typedef struct TextModernAttach__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *title;
  GPBStringValue *titleURL;
  ImageLocation *titleIcon;
  GPBStringValue *text;
  ParagraphStyle *style;
  NSMutableArray *fieldsArray;
} TextModernAttach__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = TextModernAttach_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextModernAttach__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "titleURL",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = TextModernAttach_FieldNumber_TitleURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextModernAttach__storage_, titleURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "titleIcon",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageLocation),
        .number = TextModernAttach_FieldNumber_TitleIcon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TextModernAttach__storage_, titleIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = TextModernAttach_FieldNumber_Text,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TextModernAttach__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "style",
        .dataTypeSpecific.clazz = GPBObjCClass(ParagraphStyle),
        .number = TextModernAttach_FieldNumber_Style,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TextModernAttach__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fieldsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TextModernField),
        .number = TextModernAttach_FieldNumber_FieldsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextModernAttach__storage_, fieldsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextModernAttach class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextModernAttach__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextModernField

@implementation TextModernField

@dynamic title;
@dynamic value;
@dynamic hasIsShort, isShort;

typedef struct TextModernField__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *value;
  GPBBoolValue *isShort;
} TextModernField__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = TextModernField_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextModernField__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = TextModernField_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextModernField__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isShort",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = TextModernField_FieldNumber_IsShort,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TextModernField__storage_, isShort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextModernField class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextModernField__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextCommand

@implementation TextCommand

@dynamic command;
@dynamic args;

typedef struct TextCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *command;
  NSString *args;
} TextCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "command",
        .dataTypeSpecific.clazz = Nil,
        .number = TextCommand_FieldNumber_Command,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextCommand__storage_, command),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "args",
        .dataTypeSpecific.clazz = Nil,
        .number = TextCommand_FieldNumber_Args,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextCommand__storage_, args),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextCommand class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextCommand__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceMessage

@implementation ServiceMessage

@dynamic text;
@dynamic hasExt, ext;

typedef struct ServiceMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
  ServiceEx *ext;
} ServiceMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceMessage_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceMessage__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ext",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceEx),
        .number = ServiceMessage_FieldNumber_Ext,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ServiceMessage__storage_, ext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceEx

@implementation ServiceEx

@dynamic bodyOneOfCase;
@dynamic userInvited;
@dynamic userJoined;
@dynamic userKicked;
@dynamic userLeft;
@dynamic groupCreated;
@dynamic changedTitle;
@dynamic changedTopic;
@dynamic changedAbout;
@dynamic changedAvatar;
@dynamic contactRegistered;
@dynamic phoneMissed;
@dynamic phoneCall;
@dynamic phoneRejected;
@dynamic chatArchived;
@dynamic chatRestored;
@dynamic conferenceStatus;
@dynamic publicityChanged;
@dynamic importantTopicForked;
@dynamic importantTopicClosed;
@dynamic importantTopicReopened;

typedef struct ServiceEx__storage_ {
  uint32_t _has_storage_[2];
  ServiceExUserInvited *userInvited;
  ServiceExUserJoined *userJoined;
  ServiceExUserKicked *userKicked;
  ServiceExUserLeft *userLeft;
  ServiceExGroupCreated *groupCreated;
  ServiceExChangedTitle *changedTitle;
  ServiceExChangedTopic *changedTopic;
  ServiceExChangedAbout *changedAbout;
  ServiceExChangedAvatar *changedAvatar;
  ServiceExContactRegistered *contactRegistered;
  ServiceExPhoneMissed *phoneMissed;
  ServiceExPhoneCall *phoneCall;
  ServiceExPhoneRejected *phoneRejected;
  ServiceExChatArchived *chatArchived;
  ServiceExChatRestored *chatRestored;
  ServiceExConferenceStatus *conferenceStatus;
  ServiceExGroupPublicityChanged *publicityChanged;
  ServiceExImportantTopicForked *importantTopicForked;
  ServiceExImportantTopicClosed *importantTopicClosed;
  ServiceExImportantTopicReopened *importantTopicReopened;
} ServiceEx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInvited",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExUserInvited),
        .number = ServiceEx_FieldNumber_UserInvited,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, userInvited),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userJoined",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExUserJoined),
        .number = ServiceEx_FieldNumber_UserJoined,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, userJoined),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userKicked",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExUserKicked),
        .number = ServiceEx_FieldNumber_UserKicked,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, userKicked),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userLeft",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExUserLeft),
        .number = ServiceEx_FieldNumber_UserLeft,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, userLeft),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupCreated",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExGroupCreated),
        .number = ServiceEx_FieldNumber_GroupCreated,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, groupCreated),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "changedTitle",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExChangedTitle),
        .number = ServiceEx_FieldNumber_ChangedTitle,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, changedTitle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "changedTopic",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExChangedTopic),
        .number = ServiceEx_FieldNumber_ChangedTopic,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, changedTopic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "changedAbout",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExChangedAbout),
        .number = ServiceEx_FieldNumber_ChangedAbout,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, changedAbout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "changedAvatar",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExChangedAvatar),
        .number = ServiceEx_FieldNumber_ChangedAvatar,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, changedAvatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contactRegistered",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExContactRegistered),
        .number = ServiceEx_FieldNumber_ContactRegistered,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, contactRegistered),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "phoneMissed",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExPhoneMissed),
        .number = ServiceEx_FieldNumber_PhoneMissed,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, phoneMissed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "phoneCall",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExPhoneCall),
        .number = ServiceEx_FieldNumber_PhoneCall,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, phoneCall),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "phoneRejected",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExPhoneRejected),
        .number = ServiceEx_FieldNumber_PhoneRejected,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, phoneRejected),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatArchived",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExChatArchived),
        .number = ServiceEx_FieldNumber_ChatArchived,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, chatArchived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatRestored",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExChatRestored),
        .number = ServiceEx_FieldNumber_ChatRestored,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, chatRestored),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conferenceStatus",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExConferenceStatus),
        .number = ServiceEx_FieldNumber_ConferenceStatus,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, conferenceStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "publicityChanged",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExGroupPublicityChanged),
        .number = ServiceEx_FieldNumber_PublicityChanged,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, publicityChanged),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "importantTopicForked",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExImportantTopicForked),
        .number = ServiceEx_FieldNumber_ImportantTopicForked,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, importantTopicForked),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "importantTopicClosed",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExImportantTopicClosed),
        .number = ServiceEx_FieldNumber_ImportantTopicClosed,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, importantTopicClosed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "importantTopicReopened",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExImportantTopicReopened),
        .number = ServiceEx_FieldNumber_ImportantTopicReopened,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, importantTopicReopened),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceEx class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceEx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ServiceEx_ClearBodyOneOfCase(ServiceEx *message) {
  GPBDescriptor *descriptor = [ServiceEx descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ServiceExUserInvited

@implementation ServiceExUserInvited

@dynamic invitedUserIdsArray, invitedUserIdsArray_Count;

typedef struct ServiceExUserInvited__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *invitedUserIdsArray;
} ServiceExUserInvited__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invitedUserIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExUserInvited_FieldNumber_InvitedUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ServiceExUserInvited__storage_, invitedUserIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExUserInvited class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExUserInvited__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExUserJoined

@implementation ServiceExUserJoined

@dynamic joinedUserIdsArray, joinedUserIdsArray_Count;

typedef struct ServiceExUserJoined__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *joinedUserIdsArray;
} ServiceExUserJoined__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "joinedUserIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExUserJoined_FieldNumber_JoinedUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ServiceExUserJoined__storage_, joinedUserIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExUserJoined class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExUserJoined__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExUserKicked

@implementation ServiceExUserKicked

@dynamic kickedUserIdsArray, kickedUserIdsArray_Count;

typedef struct ServiceExUserKicked__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *kickedUserIdsArray;
} ServiceExUserKicked__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "kickedUserIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExUserKicked_FieldNumber_KickedUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ServiceExUserKicked__storage_, kickedUserIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExUserKicked class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExUserKicked__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExUserLeft

@implementation ServiceExUserLeft

@dynamic leftUserIdsArray, leftUserIdsArray_Count;

typedef struct ServiceExUserLeft__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *leftUserIdsArray;
} ServiceExUserLeft__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "leftUserIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExUserLeft_FieldNumber_LeftUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ServiceExUserLeft__storage_, leftUserIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExUserLeft class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExUserLeft__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExGroupCreated

@implementation ServiceExGroupCreated


typedef struct ServiceExGroupCreated__storage_ {
  uint32_t _has_storage_[1];
} ServiceExGroupCreated__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExGroupCreated class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ServiceExGroupCreated__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExChangedTitle

@implementation ServiceExChangedTitle

@dynamic title;

typedef struct ServiceExChangedTitle__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
} ServiceExChangedTitle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExChangedTitle_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExChangedTitle__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExChangedTitle class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExChangedTitle__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExChangedTopic

@implementation ServiceExChangedTopic

@dynamic hasTopic, topic;

typedef struct ServiceExChangedTopic__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *topic;
} ServiceExChangedTopic__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topic",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = ServiceExChangedTopic_FieldNumber_Topic,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExChangedTopic__storage_, topic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExChangedTopic class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExChangedTopic__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExChangedAbout

@implementation ServiceExChangedAbout

@dynamic hasAbout, about;

typedef struct ServiceExChangedAbout__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *about;
} ServiceExChangedAbout__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "about",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = ServiceExChangedAbout_FieldNumber_About,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExChangedAbout__storage_, about),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExChangedAbout class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExChangedAbout__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExChangedAvatar

@implementation ServiceExChangedAvatar

@dynamic hasAvatar, avatar;

typedef struct ServiceExChangedAvatar__storage_ {
  uint32_t _has_storage_[1];
  Avatar *avatar;
} ServiceExChangedAvatar__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "avatar",
        .dataTypeSpecific.clazz = GPBObjCClass(Avatar),
        .number = ServiceExChangedAvatar_FieldNumber_Avatar,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExChangedAvatar__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExChangedAvatar class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExChangedAvatar__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExContactRegistered

@implementation ServiceExContactRegistered

@dynamic userId;

typedef struct ServiceExContactRegistered__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} ServiceExContactRegistered__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExContactRegistered_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExContactRegistered__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExContactRegistered class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExContactRegistered__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExPhoneMissed

@implementation ServiceExPhoneMissed


typedef struct ServiceExPhoneMissed__storage_ {
  uint32_t _has_storage_[1];
} ServiceExPhoneMissed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExPhoneMissed class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ServiceExPhoneMissed__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExPhoneCall

@implementation ServiceExPhoneCall

@dynamic durationSeconds;

typedef struct ServiceExPhoneCall__storage_ {
  uint32_t _has_storage_[1];
  int32_t durationSeconds;
} ServiceExPhoneCall__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "durationSeconds",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExPhoneCall_FieldNumber_DurationSeconds,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExPhoneCall__storage_, durationSeconds),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExPhoneCall class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExPhoneCall__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExPhoneRejected

@implementation ServiceExPhoneRejected


typedef struct ServiceExPhoneRejected__storage_ {
  uint32_t _has_storage_[1];
} ServiceExPhoneRejected__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExPhoneRejected class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ServiceExPhoneRejected__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExChatArchived

@implementation ServiceExChatArchived


typedef struct ServiceExChatArchived__storage_ {
  uint32_t _has_storage_[1];
} ServiceExChatArchived__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExChatArchived class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ServiceExChatArchived__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExChatRestored

@implementation ServiceExChatRestored


typedef struct ServiceExChatRestored__storage_ {
  uint32_t _has_storage_[1];
} ServiceExChatRestored__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExChatRestored class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ServiceExChatRestored__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExConferenceStatus

@implementation ServiceExConferenceStatus

@dynamic conferenceId;
@dynamic conferenceStatus;

typedef struct ServiceExConferenceStatus__storage_ {
  uint32_t _has_storage_[1];
  NSString *conferenceId;
  NSString *conferenceStatus;
} ServiceExConferenceStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conferenceId",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExConferenceStatus_FieldNumber_ConferenceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExConferenceStatus__storage_, conferenceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "conferenceStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExConferenceStatus_FieldNumber_ConferenceStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ServiceExConferenceStatus__storage_, conferenceStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExConferenceStatus class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExConferenceStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExGroupPublicityChanged

@implementation ServiceExGroupPublicityChanged

@dynamic previousPublicity;
@dynamic currentPublicity;

typedef struct ServiceExGroupPublicityChanged__storage_ {
  uint32_t _has_storage_[1];
} ServiceExGroupPublicityChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "previousPublicity",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExGroupPublicityChanged_FieldNumber_PreviousPublicity,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "currentPublicity",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExGroupPublicityChanged_FieldNumber_CurrentPublicity,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExGroupPublicityChanged class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExGroupPublicityChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExImportantTopicForked

@implementation ServiceExImportantTopicForked

@dynamic hasTopicGroup, topicGroup;

typedef struct ServiceExImportantTopicForked__storage_ {
  uint32_t _has_storage_[1];
  GroupData *topicGroup;
} ServiceExImportantTopicForked__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topicGroup",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupData),
        .number = ServiceExImportantTopicForked_FieldNumber_TopicGroup,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExImportantTopicForked__storage_, topicGroup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExImportantTopicForked class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExImportantTopicForked__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExImportantTopicClosed

@implementation ServiceExImportantTopicClosed

@dynamic closedByUserId;

typedef struct ServiceExImportantTopicClosed__storage_ {
  uint32_t _has_storage_[1];
  NSString *closedByUserId;
} ServiceExImportantTopicClosed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "closedByUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExImportantTopicClosed_FieldNumber_ClosedByUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExImportantTopicClosed__storage_, closedByUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExImportantTopicClosed class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExImportantTopicClosed__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExImportantTopicReopened

@implementation ServiceExImportantTopicReopened

@dynamic reopenedByUserId;

typedef struct ServiceExImportantTopicReopened__storage_ {
  uint32_t _has_storage_[1];
  NSString *reopenedByUserId;
} ServiceExImportantTopicReopened__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reopenedByUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExImportantTopicReopened_FieldNumber_ReopenedByUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExImportantTopicReopened__storage_, reopenedByUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExImportantTopicReopened class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExImportantTopicReopened__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DocumentMessage

@implementation DocumentMessage

@dynamic fileId;
@dynamic accessHash;
@dynamic fileSize;
@dynamic name;
@dynamic mimeType;
@dynamic hasThumb, thumb;
@dynamic hasExt, ext;
@dynamic hasCaption, caption;
@dynamic mentionsArray, mentionsArray_Count;

typedef struct DocumentMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t fileSize;
  NSString *fileId;
  NSString *name;
  NSString *mimeType;
  FastThumb *thumb;
  DocumentEx *ext;
  GPBStringValue *caption;
  NSMutableArray *mentionsArray;
  int64_t accessHash;
} DocumentMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileId",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentMessage_FieldNumber_FileId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, fileId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accessHash",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentMessage_FieldNumber_AccessHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, accessHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentMessage_FieldNumber_FileSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, fileSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentMessage_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mimeType",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentMessage_FieldNumber_MimeType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, mimeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thumb",
        .dataTypeSpecific.clazz = GPBObjCClass(FastThumb),
        .number = DocumentMessage_FieldNumber_Thumb,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, thumb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ext",
        .dataTypeSpecific.clazz = GPBObjCClass(DocumentEx),
        .number = DocumentMessage_FieldNumber_Ext,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, ext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "caption",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = DocumentMessage_FieldNumber_Caption,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, caption),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mentionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Mention),
        .number = DocumentMessage_FieldNumber_MentionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, mentionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DocumentMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DocumentMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DocumentEx

@implementation DocumentEx

@dynamic bodyOneOfCase;
@dynamic photo;
@dynamic video;
@dynamic voice;

typedef struct DocumentEx__storage_ {
  uint32_t _has_storage_[2];
  DocumentExPhoto *photo;
  DocumentExVideo *video;
  DocumentExVoice *voice;
} DocumentEx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "photo",
        .dataTypeSpecific.clazz = GPBObjCClass(DocumentExPhoto),
        .number = DocumentEx_FieldNumber_Photo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DocumentEx__storage_, photo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.clazz = GPBObjCClass(DocumentExVideo),
        .number = DocumentEx_FieldNumber_Video,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DocumentEx__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voice",
        .dataTypeSpecific.clazz = GPBObjCClass(DocumentExVoice),
        .number = DocumentEx_FieldNumber_Voice,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DocumentEx__storage_, voice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DocumentEx class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DocumentEx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void DocumentEx_ClearBodyOneOfCase(DocumentEx *message) {
  GPBDescriptor *descriptor = [DocumentEx descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - DocumentExPhoto

@implementation DocumentExPhoto

@dynamic w;
@dynamic h;

typedef struct DocumentExPhoto__storage_ {
  uint32_t _has_storage_[1];
  int32_t w;
  int32_t h;
} DocumentExPhoto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "w",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentExPhoto_FieldNumber_W,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DocumentExPhoto__storage_, w),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "h",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentExPhoto_FieldNumber_H,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DocumentExPhoto__storage_, h),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DocumentExPhoto class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DocumentExPhoto__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DocumentExVideo

@implementation DocumentExVideo

@dynamic w;
@dynamic h;
@dynamic duration;

typedef struct DocumentExVideo__storage_ {
  uint32_t _has_storage_[1];
  int32_t w;
  int32_t h;
  int32_t duration;
} DocumentExVideo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "w",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentExVideo_FieldNumber_W,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DocumentExVideo__storage_, w),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "h",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentExVideo_FieldNumber_H,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DocumentExVideo__storage_, h),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentExVideo_FieldNumber_Duration,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DocumentExVideo__storage_, duration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DocumentExVideo class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DocumentExVideo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DocumentExVoice

@implementation DocumentExVoice

@dynamic duration;

typedef struct DocumentExVoice__storage_ {
  uint32_t _has_storage_[1];
  int32_t duration;
} DocumentExVoice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentExVoice_FieldNumber_Duration,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DocumentExVoice__storage_, duration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DocumentExVoice class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DocumentExVoice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - JsonMessage

@implementation JsonMessage

@dynamic rawJson;

typedef struct JsonMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *rawJson;
} JsonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rawJson",
        .dataTypeSpecific.clazz = Nil,
        .number = JsonMessage_FieldNumber_RawJson,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(JsonMessage__storage_, rawJson),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[JsonMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(JsonMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnsupportedMessage

@implementation UnsupportedMessage


typedef struct UnsupportedMessage__storage_ {
  uint32_t _has_storage_[1];
} UnsupportedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnsupportedMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(UnsupportedMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StickerMessage

@implementation StickerMessage

@dynamic hasStickerId, stickerId;
@dynamic hasFastPreview, fastPreview;
@dynamic hasImage512, image512;
@dynamic hasImage256, image256;
@dynamic hasStickerCollectionId, stickerCollectionId;
@dynamic hasStickerCollectionAccessHash, stickerCollectionAccessHash;
@dynamic hasEmoji, emoji;
@dynamic hasAnimatedStickerJson, animatedStickerJson;

typedef struct StickerMessage__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *stickerId;
  GPBBytesValue *fastPreview;
  ImageLocation *image512;
  ImageLocation *image256;
  GPBStringValue *stickerCollectionId;
  GPBInt64Value *stickerCollectionAccessHash;
  GPBStringValue *emoji;
  GPBStringValue *animatedStickerJson;
} StickerMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stickerId",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = StickerMessage_FieldNumber_StickerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, stickerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fastPreview",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBytesValue),
        .number = StickerMessage_FieldNumber_FastPreview,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, fastPreview),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image512",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageLocation),
        .number = StickerMessage_FieldNumber_Image512,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, image512),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image256",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageLocation),
        .number = StickerMessage_FieldNumber_Image256,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, image256),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stickerCollectionId",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = StickerMessage_FieldNumber_StickerCollectionId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, stickerCollectionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stickerCollectionAccessHash",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = StickerMessage_FieldNumber_StickerCollectionAccessHash,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, stickerCollectionAccessHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "emoji",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = StickerMessage_FieldNumber_Emoji,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, emoji),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "animatedStickerJson",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = StickerMessage_FieldNumber_AnimatedStickerJson,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, animatedStickerJson),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StickerMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StickerMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\005\203\000\004\005\203\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinaryMessage

@implementation BinaryMessage

@dynamic contentTag;
@dynamic msg;

typedef struct BinaryMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *contentTag;
  NSData *msg;
} BinaryMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contentTag",
        .dataTypeSpecific.clazz = Nil,
        .number = BinaryMessage_FieldNumber_ContentTag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinaryMessage__storage_, contentTag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = Nil,
        .number = BinaryMessage_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BinaryMessage__storage_, msg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinaryMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinaryMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmptyMessage

@implementation EmptyMessage


typedef struct EmptyMessage__storage_ {
  uint32_t _has_storage_[1];
} EmptyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmptyMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(EmptyMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeletedMessage

@implementation DeletedMessage

@dynamic hasIsLocal, isLocal;

typedef struct DeletedMessage__storage_ {
  uint32_t _has_storage_[1];
  GPBBoolValue *isLocal;
} DeletedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isLocal",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = DeletedMessage_FieldNumber_IsLocal,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeletedMessage__storage_, isLocal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeletedMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeletedMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DialogShort

@implementation DialogShort

@dynamic hasPeer, peer;
@dynamic counter;
@dynamic date;

typedef struct DialogShort__storage_ {
  uint32_t _has_storage_[1];
  int32_t counter;
  Peer *peer;
  int64_t date;
} DialogShort__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = DialogShort_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DialogShort__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "counter",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogShort_FieldNumber_Counter,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DialogShort__storage_, counter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogShort_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DialogShort__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DialogShort class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DialogShort__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DialogGroup

@implementation DialogGroup

@dynamic title;
@dynamic key;
@dynamic dialogsArray, dialogsArray_Count;

typedef struct DialogGroup__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *key;
  NSMutableArray *dialogsArray;
} DialogGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogGroup_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DialogGroup__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogGroup_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DialogGroup__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dialogsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DialogShort),
        .number = DialogGroup_FieldNumber_DialogsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DialogGroup__storage_, dialogsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DialogGroup class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DialogGroup__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchPredicate

@implementation SearchPredicate

@dynamic key;
@dynamic valuesArray, valuesArray_Count;

typedef struct SearchPredicate__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSMutableArray *valuesArray;
} SearchPredicate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchPredicate_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchPredicate__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "valuesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchPredicate_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchPredicate__storage_, valuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchPredicate class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchPredicate__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ForwardItem

@implementation ForwardItem

@dynamic deduplicationId;
@dynamic hasMid, mid;
@dynamic hasPeer, peer;

typedef struct ForwardItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *deduplicationId;
  UUIDValue *mid;
  OutPeer *peer;
} ForwardItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deduplicationId",
        .dataTypeSpecific.clazz = Nil,
        .number = ForwardItem_FieldNumber_DeduplicationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ForwardItem__storage_, deduplicationId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = ForwardItem_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ForwardItem__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = ForwardItem_FieldNumber_Peer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ForwardItem__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ForwardItem class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ForwardItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestSendMessage

@implementation RequestSendMessage

@dynamic hasPeer, peer;
@dynamic deduplicationId;
@dynamic hasMessage, message;
@dynamic hasIsOnlyForUser, isOnlyForUser;
@dynamic forwardsArray, forwardsArray_Count;
@dynamic hasReply, reply;
@dynamic predicatesArray, predicatesArray_Count;
@dynamic whiteListArray, whiteListArray_Count;
@dynamic blackListArray, blackListArray_Count;

typedef struct RequestSendMessage__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  NSString *deduplicationId;
  MessageContent *message;
  GPBStringValue *isOnlyForUser;
  NSMutableArray *forwardsArray;
  ReferencedMessages *reply;
  NSMutableArray *predicatesArray;
  NSMutableArray *whiteListArray;
  NSMutableArray *blackListArray;
} RequestSendMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestSendMessage_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deduplicationId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSendMessage_FieldNumber_DeduplicationId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, deduplicationId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = RequestSendMessage_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isOnlyForUser",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestSendMessage_FieldNumber_IsOnlyForUser,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, isOnlyForUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "forwardsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ForwardItem),
        .number = RequestSendMessage_FieldNumber_ForwardsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, forwardsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reply",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = RequestSendMessage_FieldNumber_Reply,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, reply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "predicatesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPredicate),
        .number = RequestSendMessage_FieldNumber_PredicatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, predicatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "whiteListArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSendMessage_FieldNumber_WhiteListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, whiteListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blackListArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSendMessage_FieldNumber_BlackListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, blackListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestSendMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestSendMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestSendMessageAsync

@implementation RequestSendMessageAsync

@dynamic hasPeer, peer;
@dynamic deduplicationId;
@dynamic hasMessage, message;
@dynamic hasIsOnlyForUser, isOnlyForUser;
@dynamic forwardsArray, forwardsArray_Count;
@dynamic hasReply, reply;
@dynamic predicatesArray, predicatesArray_Count;
@dynamic whiteListArray, whiteListArray_Count;
@dynamic blackListArray, blackListArray_Count;

typedef struct RequestSendMessageAsync__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  NSString *deduplicationId;
  MessageContent *message;
  GPBStringValue *isOnlyForUser;
  NSMutableArray *forwardsArray;
  ReferencedMessages *reply;
  NSMutableArray *predicatesArray;
  NSMutableArray *whiteListArray;
  NSMutableArray *blackListArray;
} RequestSendMessageAsync__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestSendMessageAsync_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deduplicationId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSendMessageAsync_FieldNumber_DeduplicationId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, deduplicationId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = RequestSendMessageAsync_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isOnlyForUser",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestSendMessageAsync_FieldNumber_IsOnlyForUser,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, isOnlyForUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "forwardsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ForwardItem),
        .number = RequestSendMessageAsync_FieldNumber_ForwardsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, forwardsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reply",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = RequestSendMessageAsync_FieldNumber_Reply,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, reply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "predicatesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPredicate),
        .number = RequestSendMessageAsync_FieldNumber_PredicatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, predicatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "whiteListArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSendMessageAsync_FieldNumber_WhiteListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, whiteListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blackListArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSendMessageAsync_FieldNumber_BlackListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, blackListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestSendMessageAsync class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestSendMessageAsync__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestUpdateMessage

@implementation RequestUpdateMessage

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic hasUpdatedMessage, updatedMessage;
@dynamic lastEditedAt;

typedef struct RequestUpdateMessage__storage_ {
  uint32_t _has_storage_[1];
  UUIDValue *mid;
  MessageContent *updatedMessage;
  Peer *peer;
  int64_t lastEditedAt;
} RequestUpdateMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestUpdateMessage_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestUpdateMessage__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updatedMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = RequestUpdateMessage_FieldNumber_UpdatedMessage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestUpdateMessage__storage_, updatedMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastEditedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestUpdateMessage_FieldNumber_LastEditedAt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestUpdateMessage__storage_, lastEditedAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestUpdateMessage_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestUpdateMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestUpdateMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestUpdateMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageReceived

@implementation RequestMessageReceived

@dynamic hasPeer, peer;
@dynamic date;

typedef struct RequestMessageReceived__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  int64_t date;
} RequestMessageReceived__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestMessageReceived_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageReceived__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageReceived_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestMessageReceived__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageReceived class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageReceived__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageRead

@implementation RequestMessageRead

@dynamic hasPeer, peer;
@dynamic date;

typedef struct RequestMessageRead__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  int64_t date;
} RequestMessageRead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestMessageRead_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageRead__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageRead_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestMessageRead__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageRead class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageRead__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestDeleteMessage

@implementation RequestDeleteMessage

@dynamic hasPeer, peer;
@dynamic hasMessageId, messageId;
@dynamic deleteForUserOnly;

typedef struct RequestDeleteMessage__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *messageId;
} RequestDeleteMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestDeleteMessage_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestDeleteMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestDeleteMessage_FieldNumber_MessageId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestDeleteMessage__storage_, messageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deleteForUserOnly",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestDeleteMessage_FieldNumber_DeleteForUserOnly,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestDeleteMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestDeleteMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestClearChat

@implementation RequestClearChat

@dynamic hasPeer, peer;
@dynamic lastMessageDate;

typedef struct RequestClearChat__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  int64_t lastMessageDate;
} RequestClearChat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestClearChat_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestClearChat__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastMessageDate",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestClearChat_FieldNumber_LastMessageDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestClearChat__storage_, lastMessageDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestClearChat class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestClearChat__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestDeleteChat

@implementation RequestDeleteChat

@dynamic hasPeer, peer;
@dynamic lastMessageDate;

typedef struct RequestDeleteChat__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  int64_t lastMessageDate;
} RequestDeleteChat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestDeleteChat_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestDeleteChat__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastMessageDate",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestDeleteChat_FieldNumber_LastMessageDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestDeleteChat__storage_, lastMessageDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestDeleteChat class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestDeleteChat__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestArchiveChat

@implementation RequestArchiveChat

@dynamic hasPeer, peer;

typedef struct RequestArchiveChat__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
} RequestArchiveChat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestArchiveChat_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestArchiveChat__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestArchiveChat class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestArchiveChat__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseSendMessage

@implementation ResponseSendMessage

@dynamic hasMessageId, messageId;

typedef struct ResponseSendMessage__storage_ {
  uint32_t _has_storage_[1];
  UUIDValue *messageId;
} ResponseSendMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageId",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = ResponseSendMessage_FieldNumber_MessageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseSendMessage__storage_, messageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseSendMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseSendMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessage

@implementation UpdateMessage

@dynamic attachOneOfCase;
@dynamic hasPeer, peer;
@dynamic senderUserId;
@dynamic date;
@dynamic hasMid, mid;
@dynamic hasMessage, message;
@dynamic hasAttributes, attributes;
@dynamic reply;
@dynamic forwardSource;
@dynamic hasPreviousMid, previousMid;
@dynamic hasPrevMessageDate, prevMessageDate;
@dynamic hasCounter, counter;
@dynamic hasMentionsCounter, mentionsCounter;
@dynamic hasMyReadDate, myReadDate;
@dynamic randomId;
@dynamic modifiedAt;
@dynamic badgeCounter;

typedef struct UpdateMessage__storage_ {
  uint32_t _has_storage_[2];
  uint32_t badgeCounter;
  Peer *peer;
  NSString *senderUserId;
  UUIDValue *mid;
  MessageContent *message;
  MessageAttributes *attributes;
  ReferencedMessages *reply;
  UUIDValue *previousMid;
  GPBInt64Value *prevMessageDate;
  GPBInt32Value *counter;
  GPBInt64Value *myReadDate;
  NSString *randomId;
  ForwardSource *forwardSource;
  GPBInt32Value *mentionsCounter;
  int64_t date;
  int64_t modifiedAt;
} UpdateMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessage_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "senderUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessage_FieldNumber_SenderUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, senderUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessage_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessage_FieldNumber_Mid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = UpdateMessage_FieldNumber_Message,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attributes",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageAttributes),
        .number = UpdateMessage_FieldNumber_Attributes,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, attributes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reply",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = UpdateMessage_FieldNumber_Reply,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, reply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "previousMid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessage_FieldNumber_PreviousMid,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, previousMid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prevMessageDate",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = UpdateMessage_FieldNumber_PrevMessageDate,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, prevMessageDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "counter",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateMessage_FieldNumber_Counter,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, counter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "myReadDate",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = UpdateMessage_FieldNumber_MyReadDate,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, myReadDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessage_FieldNumber_RandomId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, randomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "modifiedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessage_FieldNumber_ModifiedAt,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, modifiedAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "forwardSource",
        .dataTypeSpecific.clazz = GPBObjCClass(ForwardSource),
        .number = UpdateMessage_FieldNumber_ForwardSource,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, forwardSource),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mentionsCounter",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateMessage_FieldNumber_MentionsCounter,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, mentionsCounter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "badgeCounter",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessage_FieldNumber_BadgeCounter,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, badgeCounter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "attach",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void UpdateMessage_ClearAttachOneOfCase(UpdateMessage *message) {
  GPBDescriptor *descriptor = [UpdateMessage descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - UpdateMessageContentChanged

@implementation UpdateMessageContentChanged

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic hasMessage, message;
@dynamic editedAt;
@dynamic hasIsSilent, isSilent;
@dynamic hasAttributes, attributes;

typedef struct UpdateMessageContentChanged__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *mid;
  MessageContent *message;
  GPBBoolValue *isSilent;
  MessageAttributes *attributes;
  int64_t editedAt;
} UpdateMessageContentChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageContentChanged_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageContentChanged__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessageContentChanged_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageContentChanged__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = UpdateMessageContentChanged_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageContentChanged__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "editedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageContentChanged_FieldNumber_EditedAt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessageContentChanged__storage_, editedAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isSilent",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = UpdateMessageContentChanged_FieldNumber_IsSilent,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateMessageContentChanged__storage_, isSilent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attributes",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageAttributes),
        .number = UpdateMessageContentChanged_FieldNumber_Attributes,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UpdateMessageContentChanged__storage_, attributes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageContentChanged class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageContentChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessageSent

@implementation UpdateMessageSent

@dynamic attachOneOfCase;
@dynamic hasPeer, peer;
@dynamic rid;
@dynamic date;
@dynamic hasMid, mid;
@dynamic hasPrevMid, prevMid;
@dynamic hasUnreadCounter, unreadCounter;
@dynamic hasUnreadMentionsCounter, unreadMentionsCounter;
@dynamic hasMyReadDate, myReadDate;
@dynamic reply;
@dynamic forwardSource;
@dynamic hasAttributes, attributes;
@dynamic badgeCounter;

typedef struct UpdateMessageSent__storage_ {
  uint32_t _has_storage_[2];
  uint32_t badgeCounter;
  Peer *peer;
  NSString *rid;
  UUIDValue *mid;
  UUIDValue *prevMid;
  GPBInt32Value *unreadCounter;
  GPBInt64Value *myReadDate;
  ReferencedMessages *reply;
  ForwardSource *forwardSource;
  MessageAttributes *attributes;
  GPBInt32Value *unreadMentionsCounter;
  int64_t date;
} UpdateMessageSent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageSent_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rid",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageSent_FieldNumber_Rid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, rid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageSent_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessageSent_FieldNumber_Mid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prevMid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessageSent_FieldNumber_PrevMid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, prevMid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unreadCounter",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateMessageSent_FieldNumber_UnreadCounter,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, unreadCounter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "myReadDate",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = UpdateMessageSent_FieldNumber_MyReadDate,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, myReadDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reply",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = UpdateMessageSent_FieldNumber_Reply,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, reply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "forwardSource",
        .dataTypeSpecific.clazz = GPBObjCClass(ForwardSource),
        .number = UpdateMessageSent_FieldNumber_ForwardSource,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, forwardSource),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attributes",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageAttributes),
        .number = UpdateMessageSent_FieldNumber_Attributes,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, attributes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unreadMentionsCounter",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateMessageSent_FieldNumber_UnreadMentionsCounter,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, unreadMentionsCounter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "badgeCounter",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageSent_FieldNumber_BadgeCounter,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, badgeCounter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageSent class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageSent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "attach",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void UpdateMessageSent_ClearAttachOneOfCase(UpdateMessageSent *message) {
  GPBDescriptor *descriptor = [UpdateMessageSent descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - UpdateMessageReceived

@implementation UpdateMessageReceived

@dynamic hasPeer, peer;
@dynamic date;

typedef struct UpdateMessageReceived__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  int64_t date;
} UpdateMessageReceived__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageReceived_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageReceived__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReceived_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageReceived__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageReceived class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageReceived__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessageRead

@implementation UpdateMessageRead

@dynamic hasPeer, peer;
@dynamic date;

typedef struct UpdateMessageRead__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  int64_t date;
} UpdateMessageRead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageRead_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageRead__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageRead_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageRead__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageRead class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageRead__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessageReadByMe

@implementation UpdateMessageReadByMe

@dynamic hasPeer, peer;
@dynamic date;
@dynamic hasUnreadCounter, unreadCounter;
@dynamic hasUnreadMentionsCounter, unreadMentionsCounter;
@dynamic badgeCounter;

typedef struct UpdateMessageReadByMe__storage_ {
  uint32_t _has_storage_[1];
  uint32_t badgeCounter;
  Peer *peer;
  GPBInt32Value *unreadCounter;
  GPBInt32Value *unreadMentionsCounter;
  int64_t date;
} UpdateMessageReadByMe__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageReadByMe_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageReadByMe__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReadByMe_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageReadByMe__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unreadCounter",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateMessageReadByMe_FieldNumber_UnreadCounter,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageReadByMe__storage_, unreadCounter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unreadMentionsCounter",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateMessageReadByMe_FieldNumber_UnreadMentionsCounter,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessageReadByMe__storage_, unreadMentionsCounter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "badgeCounter",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReadByMe_FieldNumber_BadgeCounter,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateMessageReadByMe__storage_, badgeCounter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageReadByMe class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageReadByMe__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateChatClear

@implementation UpdateChatClear

@dynamic hasPeer, peer;
@dynamic date;

typedef struct UpdateChatClear__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  int64_t date;
} UpdateChatClear__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateChatClear_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateChatClear__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateChatClear_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateChatClear__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateChatClear class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateChatClear__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateChatDelete

@implementation UpdateChatDelete

@dynamic hasPeer, peer;
@dynamic date;

typedef struct UpdateChatDelete__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  int64_t date;
} UpdateChatDelete__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateChatDelete_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateChatDelete__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateChatDelete_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateChatDelete__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateChatDelete class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateChatDelete__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateChatArchive

@implementation UpdateChatArchive

@dynamic hasPeer, peer;

typedef struct UpdateChatArchive__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
} UpdateChatArchive__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateChatArchive_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateChatArchive__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateChatArchive class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateChatArchive__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateChatGroupsChanged

@implementation UpdateChatGroupsChanged

@dynamic dialogsArray, dialogsArray_Count;

typedef struct UpdateChatGroupsChanged__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dialogsArray;
} UpdateChatGroupsChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dialogsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DialogGroup),
        .number = UpdateChatGroupsChanged_FieldNumber_DialogsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpdateChatGroupsChanged__storage_, dialogsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateChatGroupsChanged class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateChatGroupsChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateSendMessageError

@implementation UpdateSendMessageError

@dynamic hasPeer, peer;
@dynamic rid;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateSendMessageError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *rid;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateSendMessageError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateSendMessageError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateSendMessageError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rid",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateSendMessageError_FieldNumber_Rid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateSendMessageError__storage_, rid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateSendMessageError_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateSendMessageError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateSendMessageError_FieldNumber_HookId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateSendMessageError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateSendMessageError_FieldNumber_Cause,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateSendMessageError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateSendMessageError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateSendMessageError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateEditMessageError

@implementation UpdateEditMessageError

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateEditMessageError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *mid;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateEditMessageError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateEditMessageError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateEditMessageError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateEditMessageError_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateEditMessageError__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateEditMessageError_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateEditMessageError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateEditMessageError_FieldNumber_HookId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateEditMessageError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateEditMessageError_FieldNumber_Cause,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateEditMessageError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateEditMessageError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateEditMessageError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateDeleteMessageError

@implementation UpdateDeleteMessageError

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateDeleteMessageError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *mid;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateDeleteMessageError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateDeleteMessageError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateDeleteMessageError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateDeleteMessageError_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateDeleteMessageError__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateDeleteMessageError_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateDeleteMessageError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateDeleteMessageError_FieldNumber_HookId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateDeleteMessageError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateDeleteMessageError_FieldNumber_Cause,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateDeleteMessageError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateDeleteMessageError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateDeleteMessageError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessageReadError

@implementation UpdateMessageReadError

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateMessageReadError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *mid;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateMessageReadError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageReadError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageReadError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessageReadError_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageReadError__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReadError_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageReadError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReadError_FieldNumber_HookId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessageReadError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateMessageReadError_FieldNumber_Cause,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateMessageReadError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageReadError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageReadError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessageReceivedError

@implementation UpdateMessageReceivedError

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateMessageReceivedError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *mid;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateMessageReceivedError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageReceivedError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageReceivedError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessageReceivedError_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageReceivedError__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReceivedError_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageReceivedError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReceivedError_FieldNumber_HookId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessageReceivedError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateMessageReceivedError_FieldNumber_Cause,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateMessageReceivedError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageReceivedError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageReceivedError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateClearChatError

@implementation UpdateClearChatError

@dynamic hasPeer, peer;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateClearChatError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateClearChatError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateClearChatError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateClearChatError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateClearChatError_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateClearChatError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateClearChatError_FieldNumber_HookId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateClearChatError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateClearChatError_FieldNumber_Cause,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateClearChatError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateClearChatError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateClearChatError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateDeleteChatError

@implementation UpdateDeleteChatError

@dynamic hasPeer, peer;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateDeleteChatError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateDeleteChatError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateDeleteChatError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateDeleteChatError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateDeleteChatError_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateDeleteChatError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateDeleteChatError_FieldNumber_HookId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateDeleteChatError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateDeleteChatError_FieldNumber_Cause,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateDeleteChatError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateDeleteChatError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateDeleteChatError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateFavouriteDialogError

@implementation UpdateFavouriteDialogError

@dynamic hasPeer, peer;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateFavouriteDialogError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateFavouriteDialogError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateFavouriteDialogError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateFavouriteDialogError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateFavouriteDialogError_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateFavouriteDialogError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateFavouriteDialogError_FieldNumber_HookId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateFavouriteDialogError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateFavouriteDialogError_FieldNumber_Cause,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateFavouriteDialogError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateFavouriteDialogError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateFavouriteDialogError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateUnfavouriteDialogError

@implementation UpdateUnfavouriteDialogError

@dynamic hasPeer, peer;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateUnfavouriteDialogError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateUnfavouriteDialogError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateUnfavouriteDialogError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateUnfavouriteDialogError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateUnfavouriteDialogError_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateUnfavouriteDialogError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateUnfavouriteDialogError_FieldNumber_HookId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateUnfavouriteDialogError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateUnfavouriteDialogError_FieldNumber_Cause,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateUnfavouriteDialogError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateUnfavouriteDialogError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateUnfavouriteDialogError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateReadDialogLaterError

@implementation UpdateReadDialogLaterError

@dynamic hasPeer, peer;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateReadDialogLaterError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateReadDialogLaterError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateReadDialogLaterError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateReadDialogLaterError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateReadDialogLaterError_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateReadDialogLaterError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateReadDialogLaterError_FieldNumber_HookId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateReadDialogLaterError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateReadDialogLaterError_FieldNumber_Cause,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateReadDialogLaterError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateReadDialogLaterError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateReadDialogLaterError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReferencedMessages

@implementation ReferencedMessages

@dynamic midsArray, midsArray_Count;
@dynamic hasPeer, peer;

typedef struct ReferencedMessages__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *midsArray;
  OutPeer *peer;
} ReferencedMessages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "midsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = ReferencedMessages_FieldNumber_MidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ReferencedMessages__storage_, midsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = ReferencedMessages_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReferencedMessages__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReferencedMessages class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReferencedMessages__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ForwardSource

@implementation ForwardSource

@dynamic hasHostPeer, hostPeer;
@dynamic hasSenderPeer, senderPeer;
@dynamic hostPeerName;
@dynamic hasMid, mid;

typedef struct ForwardSource__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *hostPeer;
  OutPeer *senderPeer;
  NSString *hostPeerName;
  UUIDValue *mid;
} ForwardSource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hostPeer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = ForwardSource_FieldNumber_HostPeer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ForwardSource__storage_, hostPeer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "senderPeer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = ForwardSource_FieldNumber_SenderPeer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ForwardSource__storage_, senderPeer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hostPeerName",
        .dataTypeSpecific.clazz = Nil,
        .number = ForwardSource_FieldNumber_HostPeerName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ForwardSource__storage_, hostPeerName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = ForwardSource_FieldNumber_Mid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ForwardSource__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ForwardSource class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ForwardSource__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HistoryMessage

@implementation HistoryMessage

@dynamic attachOneOfCase;
@dynamic senderUserId;
@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic hasPrevMid, prevMid;
@dynamic createdAt;
@dynamic hasMessage, message;
@dynamic hasAttributes, attributes;
@dynamic reply;
@dynamic forwardSource;
@dynamic hasEditedAt, editedAt;
@dynamic randomId;
@dynamic reactionsArray, reactionsArray_Count;
@dynamic hasThreadInfo, threadInfo;

typedef struct HistoryMessage__storage_ {
  uint32_t _has_storage_[2];
  NSString *senderUserId;
  UUIDValue *mid;
  UUIDValue *prevMid;
  MessageContent *message;
  MessageAttributes *attributes;
  ReferencedMessages *reply;
  GPBInt64Value *editedAt;
  NSString *randomId;
  ForwardSource *forwardSource;
  NSMutableArray *reactionsArray;
  OutPeer *peer;
  ThreadInfo *threadInfo;
  int64_t createdAt;
} HistoryMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = HistoryMessage_FieldNumber_SenderUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, senderUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = HistoryMessage_FieldNumber_Mid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prevMid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = HistoryMessage_FieldNumber_PrevMid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, prevMid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.clazz = Nil,
        .number = HistoryMessage_FieldNumber_CreatedAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, createdAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = HistoryMessage_FieldNumber_Message,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attributes",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageAttributes),
        .number = HistoryMessage_FieldNumber_Attributes,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, attributes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reply",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = HistoryMessage_FieldNumber_Reply,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, reply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "editedAt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = HistoryMessage_FieldNumber_EditedAt,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, editedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomId",
        .dataTypeSpecific.clazz = Nil,
        .number = HistoryMessage_FieldNumber_RandomId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, randomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "forwardSource",
        .dataTypeSpecific.clazz = GPBObjCClass(ForwardSource),
        .number = HistoryMessage_FieldNumber_ForwardSource,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, forwardSource),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reactionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Reaction),
        .number = HistoryMessage_FieldNumber_ReactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, reactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = HistoryMessage_FieldNumber_Peer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "threadInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(ThreadInfo),
        .number = HistoryMessage_FieldNumber_ThreadInfo,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, threadInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HistoryMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HistoryMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "attach",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void HistoryMessage_ClearAttachOneOfCase(HistoryMessage *message) {
  GPBDescriptor *descriptor = [HistoryMessage descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - RequestLoadMessageHistory

@implementation RequestLoadMessageHistory

@dynamic hasPeer, peer;
@dynamic hasFromMid, fromMid;
@dynamic loadMode;
@dynamic limit;

typedef struct RequestLoadMessageHistory__storage_ {
  uint32_t _has_storage_[1];
  ListLoadMode loadMode;
  int32_t limit;
  OutPeer *peer;
  UUIDValue *fromMid;
} RequestLoadMessageHistory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestLoadMessageHistory_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadMessageHistory__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fromMid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestLoadMessageHistory_FieldNumber_FromMid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestLoadMessageHistory__storage_, fromMid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "loadMode",
        .dataTypeSpecific.enumDescFunc = ListLoadMode_EnumDescriptor,
        .number = RequestLoadMessageHistory_FieldNumber_LoadMode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestLoadMessageHistory__storage_, loadMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadMessageHistory_FieldNumber_Limit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestLoadMessageHistory__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadMessageHistory class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadMessageHistory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RequestLoadMessageHistory_LoadMode_RawValue(RequestLoadMessageHistory *message) {
  GPBDescriptor *descriptor = [RequestLoadMessageHistory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestLoadMessageHistory_FieldNumber_LoadMode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRequestLoadMessageHistory_LoadMode_RawValue(RequestLoadMessageHistory *message, int32_t value) {
  GPBDescriptor *descriptor = [RequestLoadMessageHistory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestLoadMessageHistory_FieldNumber_LoadMode];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ResponseLoadHistory

@implementation ResponseLoadHistory

@dynamic historyArray, historyArray_Count;
@dynamic userPeersArray, userPeersArray_Count;
@dynamic unreadCounter;
@dynamic unreadMentionsCounter;
@dynamic hasLastConversationMessageDate, lastConversationMessageDate;

typedef struct ResponseLoadHistory__storage_ {
  uint32_t _has_storage_[1];
  int32_t unreadCounter;
  int32_t unreadMentionsCounter;
  NSMutableArray *historyArray;
  NSMutableArray *userPeersArray;
  GPBInt64Value *lastConversationMessageDate;
} ResponseLoadHistory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "historyArray",
        .dataTypeSpecific.clazz = GPBObjCClass(HistoryMessage),
        .number = ResponseLoadHistory_FieldNumber_HistoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadHistory__storage_, historyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOutPeer),
        .number = ResponseLoadHistory_FieldNumber_UserPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadHistory__storage_, userPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastConversationMessageDate",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = ResponseLoadHistory_FieldNumber_LastConversationMessageDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseLoadHistory__storage_, lastConversationMessageDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unreadCounter",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadHistory_FieldNumber_UnreadCounter,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseLoadHistory__storage_, unreadCounter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "unreadMentionsCounter",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadHistory_FieldNumber_UnreadMentionsCounter,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseLoadHistory__storage_, unreadMentionsCounter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadHistory class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadHistory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestLoadMentions

@implementation RequestLoadMentions

@dynamic hasPeer, peer;
@dynamic hasFromMid, fromMid;
@dynamic limit;

typedef struct RequestLoadMentions__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  OutPeer *peer;
  UUIDValue *fromMid;
} RequestLoadMentions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestLoadMentions_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadMentions__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fromMid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestLoadMentions_FieldNumber_FromMid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestLoadMentions__storage_, fromMid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadMentions_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestLoadMentions__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadMentions class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadMentions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseLoadMentions

@implementation ResponseLoadMentions

@dynamic midsWithMentionsArray, midsWithMentionsArray_Count;

typedef struct ResponseLoadMentions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *midsWithMentionsArray;
} ResponseLoadMentions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "midsWithMentionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = ResponseLoadMentions_FieldNumber_MidsWithMentionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadMentions__storage_, midsWithMentionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadMentions class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadMentions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Dialog

@implementation Dialog

@dynamic hasPeer, peer;
@dynamic unreadCounter;
@dynamic unreadMentionsCounter;
@dynamic modifiedAt;
@dynamic hasPinnedMessages, pinnedMessages;
@dynamic hasHistoryMessage, historyMessage;
@dynamic lastReceive;
@dynamic lastRead;
@dynamic lastReactionAt;
@dynamic lastThreadInfoAt;
@dynamic readLater;
@dynamic isMuted;
@dynamic isFavourite;
@dynamic isArchived;
@dynamic lastOwnRead;
@dynamic lastOwnReceive;
@dynamic isFollowing;

typedef struct Dialog__storage_ {
  uint32_t _has_storage_[1];
  int32_t unreadCounter;
  int32_t unreadMentionsCounter;
  Peer *peer;
  PinnedMessages *pinnedMessages;
  HistoryMessage *historyMessage;
  int64_t modifiedAt;
  int64_t lastReceive;
  int64_t lastRead;
  int64_t lastReactionAt;
  int64_t lastThreadInfoAt;
  int64_t lastOwnRead;
  int64_t lastOwnReceive;
} Dialog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = Dialog_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Dialog__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unreadCounter",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_UnreadCounter,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Dialog__storage_, unreadCounter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "modifiedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_ModifiedAt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Dialog__storage_, modifiedAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pinnedMessages",
        .dataTypeSpecific.clazz = GPBObjCClass(PinnedMessages),
        .number = Dialog_FieldNumber_PinnedMessages,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Dialog__storage_, pinnedMessages),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "historyMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(HistoryMessage),
        .number = Dialog_FieldNumber_HistoryMessage,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Dialog__storage_, historyMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastReceive",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_LastReceive,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Dialog__storage_, lastReceive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastRead",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_LastRead,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Dialog__storage_, lastRead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastReactionAt",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_LastReactionAt,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Dialog__storage_, lastReactionAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "readLater",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_ReadLater,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isMuted",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_IsMuted,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isFavourite",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_IsFavourite,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isArchived",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_IsArchived,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "lastThreadInfoAt",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_LastThreadInfoAt,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Dialog__storage_, lastThreadInfoAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unreadMentionsCounter",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_UnreadMentionsCounter,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Dialog__storage_, unreadMentionsCounter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastOwnRead",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_LastOwnRead,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(Dialog__storage_, lastOwnRead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastOwnReceive",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_LastOwnReceive,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(Dialog__storage_, lastOwnReceive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isFollowing",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_IsFollowing,
        .hasIndex = 20,
        .offset = 21,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Dialog class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Dialog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DialogFilter

@implementation DialogFilter

@dynamic dialogType;
@dynamic hasIsArchived, isArchived;
@dynamic hasIsFavourited, isFavourited;

typedef struct DialogFilter__storage_ {
  uint32_t _has_storage_[1];
  DialogFilter_DialogType dialogType;
  GPBBoolValue *isArchived;
  GPBBoolValue *isFavourited;
} DialogFilter__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dialogType",
        .dataTypeSpecific.enumDescFunc = DialogFilter_DialogType_EnumDescriptor,
        .number = DialogFilter_FieldNumber_DialogType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DialogFilter__storage_, dialogType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isArchived",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = DialogFilter_FieldNumber_IsArchived,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DialogFilter__storage_, isArchived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFavourited",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = DialogFilter_FieldNumber_IsFavourited,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DialogFilter__storage_, isFavourited),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DialogFilter class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DialogFilter__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DialogFilter_DialogType_RawValue(DialogFilter *message) {
  GPBDescriptor *descriptor = [DialogFilter descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DialogFilter_FieldNumber_DialogType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDialogFilter_DialogType_RawValue(DialogFilter *message, int32_t value) {
  GPBDescriptor *descriptor = [DialogFilter descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DialogFilter_FieldNumber_DialogType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum DialogFilter_DialogType

GPBEnumDescriptor *DialogFilter_DialogType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DialogFilterTypeAny\000DialogFilterTypeRoot"
        "\000DialogFilterTypeThread\000";
    static const int32_t values[] = {
        DialogFilter_DialogType_DialogFilterTypeAny,
        DialogFilter_DialogType_DialogFilterTypeRoot,
        DialogFilter_DialogType_DialogFilterTypeThread,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DialogFilter_DialogType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DialogFilter_DialogType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DialogFilter_DialogType_IsValidValue(int32_t value__) {
  switch (value__) {
    case DialogFilter_DialogType_DialogFilterTypeAny:
    case DialogFilter_DialogType_DialogFilterTypeRoot:
    case DialogFilter_DialogType_DialogFilterTypeThread:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RequestLoadDialogs

@implementation RequestLoadDialogs

@dynamic fromDate;
@dynamic limit;
@dynamic hasFilter, filter;
@dynamic peersToLoadArray, peersToLoadArray_Count;

typedef struct RequestLoadDialogs__storage_ {
  uint32_t _has_storage_[1];
  int32_t limit;
  DialogFilter *filter;
  NSMutableArray *peersToLoadArray;
  int64_t fromDate;
} RequestLoadDialogs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromDate",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadDialogs_FieldNumber_FromDate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadDialogs__storage_, fromDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadDialogs_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestLoadDialogs__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "filter",
        .dataTypeSpecific.clazz = GPBObjCClass(DialogFilter),
        .number = RequestLoadDialogs_FieldNumber_Filter,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestLoadDialogs__storage_, filter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "peersToLoadArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestLoadDialogs_FieldNumber_PeersToLoadArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestLoadDialogs__storage_, peersToLoadArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadDialogs class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadDialogs__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseLoadDialogs

@implementation ResponseLoadDialogs

@dynamic dialogsArray, dialogsArray_Count;
@dynamic userPeersArray, userPeersArray_Count;
@dynamic groupPeersArray, groupPeersArray_Count;
@dynamic totalDialogsCount;

typedef struct ResponseLoadDialogs__storage_ {
  uint32_t _has_storage_[1];
  int32_t totalDialogsCount;
  NSMutableArray *dialogsArray;
  NSMutableArray *userPeersArray;
  NSMutableArray *groupPeersArray;
} ResponseLoadDialogs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dialogsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Dialog),
        .number = ResponseLoadDialogs_FieldNumber_DialogsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadDialogs__storage_, dialogsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOutPeer),
        .number = ResponseLoadDialogs_FieldNumber_UserPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadDialogs__storage_, userPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupOutPeer),
        .number = ResponseLoadDialogs_FieldNumber_GroupPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadDialogs__storage_, groupPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "totalDialogsCount",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadDialogs_FieldNumber_TotalDialogsCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseLoadDialogs__storage_, totalDialogsCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadDialogs class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadDialogs__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestFavouriteDialog

@implementation RequestFavouriteDialog

@dynamic hasPeer, peer;

typedef struct RequestFavouriteDialog__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
} RequestFavouriteDialog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestFavouriteDialog_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestFavouriteDialog__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestFavouriteDialog class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestFavouriteDialog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestUnfavouriteDialog

@implementation RequestUnfavouriteDialog

@dynamic hasPeer, peer;

typedef struct RequestUnfavouriteDialog__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
} RequestUnfavouriteDialog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestUnfavouriteDialog_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestUnfavouriteDialog__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestUnfavouriteDialog class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestUnfavouriteDialog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateDialogFavouriteChanged

@implementation UpdateDialogFavouriteChanged

@dynamic hasPeer, peer;
@dynamic hasIsFavourite, isFavourite;

typedef struct UpdateDialogFavouriteChanged__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  GPBBoolValue *isFavourite;
} UpdateDialogFavouriteChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateDialogFavouriteChanged_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateDialogFavouriteChanged__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFavourite",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = UpdateDialogFavouriteChanged_FieldNumber_IsFavourite,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateDialogFavouriteChanged__storage_, isFavourite),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateDialogFavouriteChanged class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateDialogFavouriteChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateDialogMuteChanged

@implementation UpdateDialogMuteChanged

@dynamic hasPeer, peer;
@dynamic isMuted;

typedef struct UpdateDialogMuteChanged__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
} UpdateDialogMuteChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateDialogMuteChanged_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateDialogMuteChanged__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isMuted",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateDialogMuteChanged_FieldNumber_IsMuted,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateDialogMuteChanged class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateDialogMuteChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PinnedMessages

@implementation PinnedMessages

@dynamic midsArray, midsArray_Count;

typedef struct PinnedMessages__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *midsArray;
} PinnedMessages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "midsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = PinnedMessages_FieldNumber_MidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PinnedMessages__storage_, midsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PinnedMessages class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PinnedMessages__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestPinMessage

@implementation RequestPinMessage

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic lastPinDate;

typedef struct RequestPinMessage__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  UUIDValue *mid;
  int64_t lastPinDate;
} RequestPinMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestPinMessage_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestPinMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestPinMessage_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestPinMessage__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastPinDate",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestPinMessage_FieldNumber_LastPinDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestPinMessage__storage_, lastPinDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestPinMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestPinMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestUnpinMessage

@implementation RequestUnpinMessage

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic lastPinDate;

typedef struct RequestUnpinMessage__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  UUIDValue *mid;
  int64_t lastPinDate;
} RequestUnpinMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestUnpinMessage_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestUnpinMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestUnpinMessage_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestUnpinMessage__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastPinDate",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestUnpinMessage_FieldNumber_LastPinDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestUnpinMessage__storage_, lastPinDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestUnpinMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestUnpinMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdatePinnedMessagesChanged

@implementation UpdatePinnedMessagesChanged

@dynamic hasPeer, peer;
@dynamic hasPinnedMessages, pinnedMessages;
@dynamic lastPinDate;

typedef struct UpdatePinnedMessagesChanged__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  PinnedMessages *pinnedMessages;
  int64_t lastPinDate;
} UpdatePinnedMessagesChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdatePinnedMessagesChanged_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdatePinnedMessagesChanged__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pinnedMessages",
        .dataTypeSpecific.clazz = GPBObjCClass(PinnedMessages),
        .number = UpdatePinnedMessagesChanged_FieldNumber_PinnedMessages,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdatePinnedMessagesChanged__storage_, pinnedMessages),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastPinDate",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdatePinnedMessagesChanged_FieldNumber_LastPinDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdatePinnedMessagesChanged__storage_, lastPinDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdatePinnedMessagesChanged class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdatePinnedMessagesChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageStatus

@implementation MessageStatus

@dynamic clock;
@dynamic userId;

typedef struct MessageStatus__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  int64_t clock;
} MessageStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clock",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageStatus_FieldNumber_Clock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageStatus__storage_, clock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageStatus_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageStatus__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageStatus class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestGetMessageReads

@implementation RequestGetMessageReads

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic limit;
@dynamic timestampFrom;

typedef struct RequestGetMessageReads__storage_ {
  uint32_t _has_storage_[1];
  int32_t limit;
  UUIDValue *mid;
  OutPeer *peer;
  int64_t timestampFrom;
} RequestGetMessageReads__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestGetMessageReads_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestGetMessageReads__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestGetMessageReads_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestGetMessageReads__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestampFrom",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestGetMessageReads_FieldNumber_TimestampFrom,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestGetMessageReads__storage_, timestampFrom),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestGetMessageReads_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestGetMessageReads__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestGetMessageReads class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestGetMessageReads__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestGetMessageReceives

@implementation RequestGetMessageReceives

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic limit;
@dynamic timestampFrom;

typedef struct RequestGetMessageReceives__storage_ {
  uint32_t _has_storage_[1];
  int32_t limit;
  UUIDValue *mid;
  OutPeer *peer;
  int64_t timestampFrom;
} RequestGetMessageReceives__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestGetMessageReceives_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestGetMessageReceives__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestGetMessageReceives_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestGetMessageReceives__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestampFrom",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestGetMessageReceives_FieldNumber_TimestampFrom,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestGetMessageReceives__storage_, timestampFrom),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestGetMessageReceives_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestGetMessageReceives__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestGetMessageReceives class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestGetMessageReceives__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetMessageReads

@implementation ResponseGetMessageReads

@dynamic statusArray, statusArray_Count;
@dynamic timestampTill;

typedef struct ResponseGetMessageReads__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *statusArray;
  int64_t timestampTill;
} ResponseGetMessageReads__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageStatus),
        .number = ResponseGetMessageReads_FieldNumber_StatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseGetMessageReads__storage_, statusArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestampTill",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseGetMessageReads_FieldNumber_TimestampTill,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseGetMessageReads__storage_, timestampTill),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetMessageReads class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetMessageReads__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetMessageReceives

@implementation ResponseGetMessageReceives

@dynamic statusArray, statusArray_Count;
@dynamic timestampTill;

typedef struct ResponseGetMessageReceives__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *statusArray;
  int64_t timestampTill;
} ResponseGetMessageReceives__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageStatus),
        .number = ResponseGetMessageReceives_FieldNumber_StatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseGetMessageReceives__storage_, statusArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestampTill",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseGetMessageReceives_FieldNumber_TimestampTill,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseGetMessageReceives__storage_, timestampTill),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetMessageReceives class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetMessageReceives__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestReadDialogLater

@implementation RequestReadDialogLater

@dynamic hasPeer, peer;
@dynamic readLater;

typedef struct RequestReadDialogLater__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
} RequestReadDialogLater__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestReadDialogLater_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestReadDialogLater__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "readLater",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestReadDialogLater_FieldNumber_ReadLater,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestReadDialogLater class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestReadDialogLater__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateDialogReadLaterChanged

@implementation UpdateDialogReadLaterChanged

@dynamic hasPeer, peer;
@dynamic readLater;

typedef struct UpdateDialogReadLaterChanged__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
} UpdateDialogReadLaterChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateDialogReadLaterChanged_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateDialogReadLaterChanged__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "readLater",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateDialogReadLaterChanged_FieldNumber_ReadLater,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateDialogReadLaterChanged class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateDialogReadLaterChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMuteChat

@implementation RequestMuteChat

@dynamic hasPeer, peer;
@dynamic hasDuration, duration;

typedef struct RequestMuteChat__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  GPBDuration *duration;
} RequestMuteChat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestMuteChat_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMuteChat__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = RequestMuteChat_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestMuteChat__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMuteChat class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMuteChat__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestUnmuteChat

@implementation RequestUnmuteChat

@dynamic hasPeer, peer;

typedef struct RequestUnmuteChat__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
} RequestUnmuteChat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestUnmuteChat_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestUnmuteChat__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestUnmuteChat class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestUnmuteChat__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
