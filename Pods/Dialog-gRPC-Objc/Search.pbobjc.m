// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: search.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Search.pbobjc.h"
#import "Timestamp.pbobjc.h"
#import "Wrappers.pbobjc.h"
#import "Annotations.pbobjc.h"
#import "Definitions.pbobjc.h"
#import "Groups.pbobjc.h"
#import "Peers.pbobjc.h"
#import "Messaging.pbobjc.h"
#import "Users.pbobjc.h"
#import "Scalapb.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(ContactSearchResult);
GPBObjCClassDeclaration(FacetHighlight);
GPBObjCClassDeclaration(GPBBoolValue);
GPBObjCClassDeclaration(GPBBytesValue);
GPBObjCClassDeclaration(GPBInt32Value);
GPBObjCClassDeclaration(GPBInt64Value);
GPBObjCClassDeclaration(GPBStringValue);
GPBObjCClassDeclaration(GPBTimestamp);
GPBObjCClassDeclaration(GroupData);
GPBObjCClassDeclaration(GroupOutPeer);
GPBObjCClassDeclaration(GroupSearchResult);
GPBObjCClassDeclaration(MessageContent);
GPBObjCClassDeclaration(MessageSearchItem);
GPBObjCClassDeclaration(MessageSearchResult);
GPBObjCClassDeclaration(OutPeer);
GPBObjCClassDeclaration(Peer);
GPBObjCClassDeclaration(PeerSearchResult);
GPBObjCClassDeclaration(ResponseSearch);
GPBObjCClassDeclaration(SearchAndCondition);
GPBObjCClassDeclaration(SearchCondition);
GPBObjCClassDeclaration(SearchOrCondition);
GPBObjCClassDeclaration(SearchPeerCondition);
GPBObjCClassDeclaration(SearchPeerContentType);
GPBObjCClassDeclaration(SearchPeerTypeCondition);
GPBObjCClassDeclaration(SearchPieceText);
GPBObjCClassDeclaration(SearchPredicate);
GPBObjCClassDeclaration(SearchResult);
GPBObjCClassDeclaration(SearchSenderIdCondition);
GPBObjCClassDeclaration(SearchUserCondition);
GPBObjCClassDeclaration(SearchUserCondition_ExtensionCondition);
GPBObjCClassDeclaration(SimpleContactSearchCondition);
GPBObjCClassDeclaration(SimpleGroupSearchCondition);
GPBObjCClassDeclaration(SimpleMessageSearchCondition);
GPBObjCClassDeclaration(SimplePeerSearchCondition);
GPBObjCClassDeclaration(SimpleSearchCondition);
GPBObjCClassDeclaration(SimpleUserProfileSearchCondition);
GPBObjCClassDeclaration(UUIDValue);
GPBObjCClassDeclaration(UserData);
GPBObjCClassDeclaration(UserMatch);
GPBObjCClassDeclaration(UserOutPeer);
GPBObjCClassDeclaration(UserSearchResult);

#pragma mark - SearchRoot

@implementation SearchRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[GAPIAnnotationsRoot extensionRegistry]];
    [registry addExtensions:[DefinitionsRoot extensionRegistry]];
    [registry addExtensions:[ScalapbRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - SearchRoot_FileDescriptor

static GPBFileDescriptor *SearchRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"dialog"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum SearchPeerType

GPBEnumDescriptor *SearchPeerType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SearchPeerTypeUnknown\000SearchPeerTypeGrou"
        "ps\000SearchPeerTypeContacts\000SearchPeerType"
        "Public\000";
    static const int32_t values[] = {
        SearchPeerType_SearchPeerTypeUnknown,
        SearchPeerType_SearchPeerTypeGroups,
        SearchPeerType_SearchPeerTypeContacts,
        SearchPeerType_SearchPeerTypePublic,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SearchPeerType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SearchPeerType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SearchPeerType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SearchPeerType_SearchPeerTypeUnknown:
    case SearchPeerType_SearchPeerTypeGroups:
    case SearchPeerType_SearchPeerTypeContacts:
    case SearchPeerType_SearchPeerTypePublic:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SearchContentType

GPBEnumDescriptor *SearchContentType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SearchContentTypeUnknown\000SearchContentTy"
        "peAny\000SearchContentTypeText\000SearchConten"
        "tTypeLinks\000SearchContentTypeDocuments\000Se"
        "archContentTypeMedia\000SearchContentTypeAu"
        "dio\000";
    static const int32_t values[] = {
        SearchContentType_SearchContentTypeUnknown,
        SearchContentType_SearchContentTypeAny,
        SearchContentType_SearchContentTypeText,
        SearchContentType_SearchContentTypeLinks,
        SearchContentType_SearchContentTypeDocuments,
        SearchContentType_SearchContentTypeMedia,
        SearchContentType_SearchContentTypeAudio,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SearchContentType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SearchContentType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SearchContentType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SearchContentType_SearchContentTypeUnknown:
    case SearchContentType_SearchContentTypeAny:
    case SearchContentType_SearchContentTypeText:
    case SearchContentType_SearchContentTypeLinks:
    case SearchContentType_SearchContentTypeDocuments:
    case SearchContentType_SearchContentTypeMedia:
    case SearchContentType_SearchContentTypeAudio:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SearchDirection

GPBEnumDescriptor *SearchDirection_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SearchDirectionUnknown\000SearchDirectionFo"
        "rward\000SearchDirectionBackward\000";
    static const int32_t values[] = {
        SearchDirection_SearchDirectionUnknown,
        SearchDirection_SearchDirectionForward,
        SearchDirection_SearchDirectionBackward,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SearchDirection)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SearchDirection_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SearchDirection_IsValidValue(int32_t value__) {
  switch (value__) {
    case SearchDirection_SearchDirectionUnknown:
    case SearchDirection_SearchDirectionForward:
    case SearchDirection_SearchDirectionBackward:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SimpleContactSearchCondition

@implementation SimpleContactSearchCondition

@dynamic text;

typedef struct SimpleContactSearchCondition__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
} SimpleContactSearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleContactSearchCondition_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimpleContactSearchCondition__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SimpleContactSearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleContactSearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SimpleMessageSearchCondition

@implementation SimpleMessageSearchCondition

@dynamic hasPeer, peer;
@dynamic text;
@dynamic type;
@dynamic searchDirection;
@dynamic hasDateFrom, dateFrom;
@dynamic hasSender, sender;

typedef struct SimpleMessageSearchCondition__storage_ {
  uint32_t _has_storage_[1];
  SearchContentType type;
  SearchDirection searchDirection;
  Peer *peer;
  NSString *text;
  GPBInt64Value *dateFrom;
  Peer *sender;
} SimpleMessageSearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = SimpleMessageSearchCondition_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimpleMessageSearchCondition__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleMessageSearchCondition_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SimpleMessageSearchCondition__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = SearchContentType_EnumDescriptor,
        .number = SimpleMessageSearchCondition_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SimpleMessageSearchCondition__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "searchDirection",
        .dataTypeSpecific.enumDescFunc = SearchDirection_EnumDescriptor,
        .number = SimpleMessageSearchCondition_FieldNumber_SearchDirection,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SimpleMessageSearchCondition__storage_, searchDirection),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "dateFrom",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = SimpleMessageSearchCondition_FieldNumber_DateFrom,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SimpleMessageSearchCondition__storage_, dateFrom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sender",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = SimpleMessageSearchCondition_FieldNumber_Sender,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SimpleMessageSearchCondition__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SimpleMessageSearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleMessageSearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SimpleMessageSearchCondition_Type_RawValue(SimpleMessageSearchCondition *message) {
  GPBDescriptor *descriptor = [SimpleMessageSearchCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimpleMessageSearchCondition_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSimpleMessageSearchCondition_Type_RawValue(SimpleMessageSearchCondition *message, int32_t value) {
  GPBDescriptor *descriptor = [SimpleMessageSearchCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimpleMessageSearchCondition_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t SimpleMessageSearchCondition_SearchDirection_RawValue(SimpleMessageSearchCondition *message) {
  GPBDescriptor *descriptor = [SimpleMessageSearchCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimpleMessageSearchCondition_FieldNumber_SearchDirection];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSimpleMessageSearchCondition_SearchDirection_RawValue(SimpleMessageSearchCondition *message, int32_t value) {
  GPBDescriptor *descriptor = [SimpleMessageSearchCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimpleMessageSearchCondition_FieldNumber_SearchDirection];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SimplePeerSearchCondition

@implementation SimplePeerSearchCondition

@dynamic peerType;
@dynamic hasText, text;

typedef struct SimplePeerSearchCondition__storage_ {
  uint32_t _has_storage_[1];
  SearchPeerType peerType;
  GPBStringValue *text;
} SimplePeerSearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerType",
        .dataTypeSpecific.enumDescFunc = SearchPeerType_EnumDescriptor,
        .number = SimplePeerSearchCondition_FieldNumber_PeerType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimplePeerSearchCondition__storage_, peerType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = SimplePeerSearchCondition_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SimplePeerSearchCondition__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SimplePeerSearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimplePeerSearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SimplePeerSearchCondition_PeerType_RawValue(SimplePeerSearchCondition *message) {
  GPBDescriptor *descriptor = [SimplePeerSearchCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimplePeerSearchCondition_FieldNumber_PeerType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSimplePeerSearchCondition_PeerType_RawValue(SimplePeerSearchCondition *message, int32_t value) {
  GPBDescriptor *descriptor = [SimplePeerSearchCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimplePeerSearchCondition_FieldNumber_PeerType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SimpleUserProfileSearchCondition

@implementation SimpleUserProfileSearchCondition

@dynamic queryString;

typedef struct SimpleUserProfileSearchCondition__storage_ {
  uint32_t _has_storage_[1];
  NSString *queryString;
} SimpleUserProfileSearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "queryString",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleUserProfileSearchCondition_FieldNumber_QueryString,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimpleUserProfileSearchCondition__storage_, queryString),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SimpleUserProfileSearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleUserProfileSearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SimpleGroupSearchCondition

@implementation SimpleGroupSearchCondition

@dynamic queryString;

typedef struct SimpleGroupSearchCondition__storage_ {
  uint32_t _has_storage_[1];
  NSString *queryString;
} SimpleGroupSearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "queryString",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleGroupSearchCondition_FieldNumber_QueryString,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimpleGroupSearchCondition__storage_, queryString),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SimpleGroupSearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleGroupSearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - criterion

@implementation criterion


typedef struct criterion__storage_ {
  uint32_t _has_storage_[1];
} criterion__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[criterion class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(criterion__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SimpleSearchCondition

@implementation SimpleSearchCondition

@dynamic criterionOneOfCase;
@dynamic contact;
@dynamic message;
@dynamic peer;
@dynamic userProfile;
@dynamic group;

typedef struct SimpleSearchCondition__storage_ {
  uint32_t _has_storage_[2];
  SimpleContactSearchCondition *contact;
  SimpleMessageSearchCondition *message;
  SimplePeerSearchCondition *peer;
  SimpleUserProfileSearchCondition *userProfile;
  SimpleGroupSearchCondition *group;
} SimpleSearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contact",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleContactSearchCondition),
        .number = SimpleSearchCondition_FieldNumber_Contact,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SimpleSearchCondition__storage_, contact),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleMessageSearchCondition),
        .number = SimpleSearchCondition_FieldNumber_Message,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SimpleSearchCondition__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(SimplePeerSearchCondition),
        .number = SimpleSearchCondition_FieldNumber_Peer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SimpleSearchCondition__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userProfile",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleUserProfileSearchCondition),
        .number = SimpleSearchCondition_FieldNumber_UserProfile,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SimpleSearchCondition__storage_, userProfile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "group",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleGroupSearchCondition),
        .number = SimpleSearchCondition_FieldNumber_Group,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SimpleSearchCondition__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SimpleSearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleSearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "criterion",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void SimpleSearchCondition_ClearCriterionOneOfCase(SimpleSearchCondition *message) {
  GPBDescriptor *descriptor = [SimpleSearchCondition descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - SearchCondition

@implementation SearchCondition

@dynamic bodyOneOfCase;
@dynamic searchPeerTypeCondition;
@dynamic searchPieceText;
@dynamic searchAndCondition;
@dynamic searchOrCondition;
@dynamic searchPeerCondition;
@dynamic searchPeerContentType;
@dynamic searchSenderIdCondition;
@dynamic searchUserCondition;

typedef struct SearchCondition__storage_ {
  uint32_t _has_storage_[2];
  SearchPeerTypeCondition *searchPeerTypeCondition;
  SearchPieceText *searchPieceText;
  SearchAndCondition *searchAndCondition;
  SearchOrCondition *searchOrCondition;
  SearchPeerCondition *searchPeerCondition;
  SearchPeerContentType *searchPeerContentType;
  SearchSenderIdCondition *searchSenderIdCondition;
  SearchUserCondition *searchUserCondition;
} SearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "searchPeerTypeCondition",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPeerTypeCondition),
        .number = SearchCondition_FieldNumber_SearchPeerTypeCondition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchPeerTypeCondition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchPieceText",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPieceText),
        .number = SearchCondition_FieldNumber_SearchPieceText,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchPieceText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchAndCondition",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchAndCondition),
        .number = SearchCondition_FieldNumber_SearchAndCondition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchAndCondition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchOrCondition",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchOrCondition),
        .number = SearchCondition_FieldNumber_SearchOrCondition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchOrCondition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchPeerCondition",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPeerCondition),
        .number = SearchCondition_FieldNumber_SearchPeerCondition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchPeerCondition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchPeerContentType",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPeerContentType),
        .number = SearchCondition_FieldNumber_SearchPeerContentType,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchPeerContentType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchSenderIdCondition",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchSenderIdCondition),
        .number = SearchCondition_FieldNumber_SearchSenderIdCondition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchSenderIdCondition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchUserCondition",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchUserCondition),
        .number = SearchCondition_FieldNumber_SearchUserCondition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchUserCondition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void SearchCondition_ClearBodyOneOfCase(SearchCondition *message) {
  GPBDescriptor *descriptor = [SearchCondition descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - SearchAndCondition

@implementation SearchAndCondition

@dynamic andQueryArray, andQueryArray_Count;

typedef struct SearchAndCondition__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *andQueryArray;
} SearchAndCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "andQueryArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchCondition),
        .number = SearchAndCondition_FieldNumber_AndQueryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchAndCondition__storage_, andQueryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchAndCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchAndCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchOrCondition

@implementation SearchOrCondition

@dynamic orQueryArray, orQueryArray_Count;

typedef struct SearchOrCondition__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *orQueryArray;
} SearchOrCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "orQueryArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchCondition),
        .number = SearchOrCondition_FieldNumber_OrQueryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchOrCondition__storage_, orQueryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchOrCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchOrCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchPeerTypeCondition

@implementation SearchPeerTypeCondition

@dynamic peerType;

typedef struct SearchPeerTypeCondition__storage_ {
  uint32_t _has_storage_[1];
  SearchPeerType peerType;
} SearchPeerTypeCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerType",
        .dataTypeSpecific.enumDescFunc = SearchPeerType_EnumDescriptor,
        .number = SearchPeerTypeCondition_FieldNumber_PeerType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchPeerTypeCondition__storage_, peerType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchPeerTypeCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchPeerTypeCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SearchPeerTypeCondition_PeerType_RawValue(SearchPeerTypeCondition *message) {
  GPBDescriptor *descriptor = [SearchPeerTypeCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SearchPeerTypeCondition_FieldNumber_PeerType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSearchPeerTypeCondition_PeerType_RawValue(SearchPeerTypeCondition *message, int32_t value) {
  GPBDescriptor *descriptor = [SearchPeerTypeCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SearchPeerTypeCondition_FieldNumber_PeerType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SearchPieceText

@implementation SearchPieceText

@dynamic query;

typedef struct SearchPieceText__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} SearchPieceText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchPieceText_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchPieceText__storage_, query),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchPieceText class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchPieceText__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchPeerCondition

@implementation SearchPeerCondition

@dynamic hasPeer, peer;

typedef struct SearchPeerCondition__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
} SearchPeerCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = SearchPeerCondition_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchPeerCondition__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchPeerCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchPeerCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchPeerContentType

@implementation SearchPeerContentType

@dynamic contentType;

typedef struct SearchPeerContentType__storage_ {
  uint32_t _has_storage_[1];
  SearchContentType contentType;
} SearchPeerContentType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contentType",
        .dataTypeSpecific.enumDescFunc = SearchContentType_EnumDescriptor,
        .number = SearchPeerContentType_FieldNumber_ContentType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchPeerContentType__storage_, contentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchPeerContentType class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchPeerContentType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SearchPeerContentType_ContentType_RawValue(SearchPeerContentType *message) {
  GPBDescriptor *descriptor = [SearchPeerContentType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SearchPeerContentType_FieldNumber_ContentType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSearchPeerContentType_ContentType_RawValue(SearchPeerContentType *message, int32_t value) {
  GPBDescriptor *descriptor = [SearchPeerContentType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SearchPeerContentType_FieldNumber_ContentType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SearchUserCondition

@implementation SearchUserCondition

@dynamic hasIsBot, isBot;
@dynamic extensionConditions, extensionConditions_Count;

typedef struct SearchUserCondition__storage_ {
  uint32_t _has_storage_[1];
  GPBBoolValue *isBot;
  NSMutableDictionary *extensionConditions;
} SearchUserCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isBot",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = SearchUserCondition_FieldNumber_IsBot,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchUserCondition__storage_, isBot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionConditions",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchUserCondition_ExtensionCondition),
        .number = SearchUserCondition_FieldNumber_ExtensionConditions,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchUserCondition__storage_, extensionConditions),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchUserCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchUserCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchUserCondition_ExtensionCondition

@implementation SearchUserCondition_ExtensionCondition

@dynamic conditionOneOfCase;
@dynamic stringValueEquality;
@dynamic boolValueEquality;
@dynamic valueExistence;
@dynamic valueAbsence;

typedef struct SearchUserCondition_ExtensionCondition__storage_ {
  uint32_t _has_storage_[2];
  NSString *stringValueEquality;
} SearchUserCondition_ExtensionCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stringValueEquality",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchUserCondition_ExtensionCondition_FieldNumber_StringValueEquality,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchUserCondition_ExtensionCondition__storage_, stringValueEquality),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "boolValueEquality",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchUserCondition_ExtensionCondition_FieldNumber_BoolValueEquality,
        .hasIndex = -1,
        .offset = 0,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "valueExistence",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchUserCondition_ExtensionCondition_FieldNumber_ValueExistence,
        .hasIndex = -1,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "valueAbsence",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchUserCondition_ExtensionCondition_FieldNumber_ValueAbsence,
        .hasIndex = -1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchUserCondition_ExtensionCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchUserCondition_ExtensionCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "condition",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SearchUserCondition)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void SearchUserCondition_ExtensionCondition_ClearConditionOneOfCase(SearchUserCondition_ExtensionCondition *message) {
  GPBDescriptor *descriptor = [SearchUserCondition_ExtensionCondition descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - SearchSenderIdCondition

@implementation SearchSenderIdCondition

@dynamic senderId;

typedef struct SearchSenderIdCondition__storage_ {
  uint32_t _has_storage_[1];
  NSString *senderId;
} SearchSenderIdCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderId",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchSenderIdCondition_FieldNumber_SenderId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchSenderIdCondition__storage_, senderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchSenderIdCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchSenderIdCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerSearchResult

@implementation PeerSearchResult

@dynamic hasPeer, peer;
@dynamic title;
@dynamic hasShortname, shortname;
@dynamic hasDescription_p, description_p;
@dynamic hasMembersCount, membersCount;
@dynamic dateCreated;
@dynamic hasCreator, creator;
@dynamic hasIsPublic, isPublic;
@dynamic hasIsJoined, isJoined;

typedef struct PeerSearchResult__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *title;
  GPBStringValue *shortname;
  GPBStringValue *description_p;
  GPBInt32Value *membersCount;
  GPBStringValue *creator;
  GPBBoolValue *isPublic;
  GPBBoolValue *isJoined;
  int64_t dateCreated;
} PeerSearchResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = PeerSearchResult_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = PeerSearchResult_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shortname",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = PeerSearchResult_FieldNumber_Shortname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, shortname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = PeerSearchResult_FieldNumber_Description_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "membersCount",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = PeerSearchResult_FieldNumber_MembersCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, membersCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dateCreated",
        .dataTypeSpecific.clazz = Nil,
        .number = PeerSearchResult_FieldNumber_DateCreated,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, dateCreated),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "creator",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = PeerSearchResult_FieldNumber_Creator,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, creator),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isPublic",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = PeerSearchResult_FieldNumber_IsPublic,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, isPublic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isJoined",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = PeerSearchResult_FieldNumber_IsJoined,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, isJoined),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerSearchResult class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerSearchResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestPeerSearch

@implementation RequestPeerSearch

@dynamic queryArray, queryArray_Count;

typedef struct RequestPeerSearch__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *queryArray;
} RequestPeerSearch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "queryArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchCondition),
        .number = RequestPeerSearch_FieldNumber_QueryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestPeerSearch__storage_, queryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestPeerSearch class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestPeerSearch__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponsePeerSearch

@implementation ResponsePeerSearch

@dynamic searchResultsArray, searchResultsArray_Count;
@dynamic userPeersArray, userPeersArray_Count;
@dynamic groupPeersArray, groupPeersArray_Count;

typedef struct ResponsePeerSearch__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *searchResultsArray;
  NSMutableArray *userPeersArray;
  NSMutableArray *groupPeersArray;
} ResponsePeerSearch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "searchResultsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(PeerSearchResult),
        .number = ResponsePeerSearch_FieldNumber_SearchResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponsePeerSearch__storage_, searchResultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOutPeer),
        .number = ResponsePeerSearch_FieldNumber_UserPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponsePeerSearch__storage_, userPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupOutPeer),
        .number = ResponsePeerSearch_FieldNumber_GroupPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponsePeerSearch__storage_, groupPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponsePeerSearch class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponsePeerSearch__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestResolvePeer

@implementation RequestResolvePeer

@dynamic shortname;

typedef struct RequestResolvePeer__storage_ {
  uint32_t _has_storage_[1];
  NSString *shortname;
} RequestResolvePeer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shortname",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestResolvePeer_FieldNumber_Shortname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestResolvePeer__storage_, shortname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestResolvePeer class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestResolvePeer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseResolvePeer

@implementation ResponseResolvePeer

@dynamic hasPeer, peer;

typedef struct ResponseResolvePeer__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
} ResponseResolvePeer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = ResponseResolvePeer_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseResolvePeer__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseResolvePeer class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseResolvePeer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FacetHighlight

@implementation FacetHighlight

@dynamic text;
@dynamic highlightStartPos;
@dynamic highlightEndPos;

typedef struct FacetHighlight__storage_ {
  uint32_t _has_storage_[1];
  int32_t highlightStartPos;
  int32_t highlightEndPos;
  NSString *text;
} FacetHighlight__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = FacetHighlight_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FacetHighlight__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "highlightStartPos",
        .dataTypeSpecific.clazz = Nil,
        .number = FacetHighlight_FieldNumber_HighlightStartPos,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FacetHighlight__storage_, highlightStartPos),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "highlightEndPos",
        .dataTypeSpecific.clazz = Nil,
        .number = FacetHighlight_FieldNumber_HighlightEndPos,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FacetHighlight__storage_, highlightEndPos),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FacetHighlight class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FacetHighlight__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserSearchResult

@implementation UserSearchResult

@dynamic hasPeer, peer;
@dynamic hasLastOnlineAt, lastOnlineAt;
@dynamic facetHighlightsArray, facetHighlightsArray_Count;
@dynamic metadata, metadata_Count;

typedef struct UserSearchResult__storage_ {
  uint32_t _has_storage_[1];
  UserOutPeer *peer;
  GPBTimestamp *lastOnlineAt;
  NSMutableArray *facetHighlightsArray;
  NSMutableDictionary *metadata;
} UserSearchResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOutPeer),
        .number = UserSearchResult_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserSearchResult__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastOnlineAt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = UserSearchResult_FieldNumber_LastOnlineAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserSearchResult__storage_, lastOnlineAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "facetHighlightsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(FacetHighlight),
        .number = UserSearchResult_FieldNumber_FacetHighlightsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserSearchResult__storage_, facetHighlightsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = Nil,
        .number = UserSearchResult_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserSearchResult__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserSearchResult class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserSearchResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupSearchResult

@implementation GroupSearchResult

@dynamic hasPeer, peer;
@dynamic facetHighlightsArray, facetHighlightsArray_Count;

typedef struct GroupSearchResult__storage_ {
  uint32_t _has_storage_[1];
  GroupOutPeer *peer;
  NSMutableArray *facetHighlightsArray;
} GroupSearchResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupOutPeer),
        .number = GroupSearchResult_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupSearchResult__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "facetHighlightsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(FacetHighlight),
        .number = GroupSearchResult_FieldNumber_FacetHighlightsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupSearchResult__storage_, facetHighlightsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupSearchResult class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupSearchResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContactSearchResult

@implementation ContactSearchResult

@dynamic phoneHash;
@dynamic hasUserId, userId;
@dynamic facetHighlightsArray, facetHighlightsArray_Count;

typedef struct ContactSearchResult__storage_ {
  uint32_t _has_storage_[1];
  NSString *phoneHash;
  GPBStringValue *userId;
  NSMutableArray *facetHighlightsArray;
} ContactSearchResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phoneHash",
        .dataTypeSpecific.clazz = Nil,
        .number = ContactSearchResult_FieldNumber_PhoneHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ContactSearchResult__storage_, phoneHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = ContactSearchResult_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ContactSearchResult__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "facetHighlightsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(FacetHighlight),
        .number = ContactSearchResult_FieldNumber_FacetHighlightsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ContactSearchResult__storage_, facetHighlightsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContactSearchResult class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContactSearchResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageSearchResult

@implementation MessageSearchResult

@dynamic hasPeer, peer;
@dynamic date;
@dynamic senderId;
@dynamic hasContent, content;
@dynamic hasMid, mid;
@dynamic facetHighlightsArray, facetHighlightsArray_Count;

typedef struct MessageSearchResult__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *senderId;
  MessageContent *content;
  UUIDValue *mid;
  NSMutableArray *facetHighlightsArray;
  int64_t date;
} MessageSearchResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = MessageSearchResult_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageSearchResult__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageSearchResult_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageSearchResult__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "senderId",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageSearchResult_FieldNumber_SenderId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageSearchResult__storage_, senderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = MessageSearchResult_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MessageSearchResult__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = MessageSearchResult_FieldNumber_Mid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MessageSearchResult__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "facetHighlightsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(FacetHighlight),
        .number = MessageSearchResult_FieldNumber_FacetHighlightsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageSearchResult__storage_, facetHighlightsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageSearchResult class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageSearchResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchResult

@implementation SearchResult

@dynamic bodyOneOfCase;
@dynamic contactSearchResult;
@dynamic userSearchResult;
@dynamic groupSearchResult;
@dynamic messageSearchResult;

typedef struct SearchResult__storage_ {
  uint32_t _has_storage_[2];
  ContactSearchResult *contactSearchResult;
  UserSearchResult *userSearchResult;
  GroupSearchResult *groupSearchResult;
  MessageSearchResult *messageSearchResult;
} SearchResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contactSearchResult",
        .dataTypeSpecific.clazz = GPBObjCClass(ContactSearchResult),
        .number = SearchResult_FieldNumber_ContactSearchResult,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchResult__storage_, contactSearchResult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userSearchResult",
        .dataTypeSpecific.clazz = GPBObjCClass(UserSearchResult),
        .number = SearchResult_FieldNumber_UserSearchResult,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchResult__storage_, userSearchResult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupSearchResult",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupSearchResult),
        .number = SearchResult_FieldNumber_GroupSearchResult,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchResult__storage_, groupSearchResult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "messageSearchResult",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageSearchResult),
        .number = SearchResult_FieldNumber_MessageSearchResult,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchResult__storage_, messageSearchResult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchResult class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void SearchResult_ClearBodyOneOfCase(SearchResult *message) {
  GPBDescriptor *descriptor = [SearchResult descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - MessageSearchItem

@implementation MessageSearchItem

@dynamic hasResult, result;

typedef struct MessageSearchItem__storage_ {
  uint32_t _has_storage_[1];
  MessageSearchResult *result;
} MessageSearchItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageSearchResult),
        .number = MessageSearchItem_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageSearchItem__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageSearchItem class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageSearchItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseMessageSearchResponse

@implementation ResponseMessageSearchResponse

@dynamic searchResultsArray, searchResultsArray_Count;
@dynamic hasLoadMoreState, loadMoreState;
@dynamic userOutPeersArray, userOutPeersArray_Count;
@dynamic groupOutPeersArray, groupOutPeersArray_Count;
@dynamic totalCount;

typedef struct ResponseMessageSearchResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *searchResultsArray;
  GPBBytesValue *loadMoreState;
  NSMutableArray *userOutPeersArray;
  NSMutableArray *groupOutPeersArray;
  int64_t totalCount;
} ResponseMessageSearchResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "searchResultsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageSearchItem),
        .number = ResponseMessageSearchResponse_FieldNumber_SearchResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseMessageSearchResponse__storage_, searchResultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "loadMoreState",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBytesValue),
        .number = ResponseMessageSearchResponse_FieldNumber_LoadMoreState,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseMessageSearchResponse__storage_, loadMoreState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userOutPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOutPeer),
        .number = ResponseMessageSearchResponse_FieldNumber_UserOutPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseMessageSearchResponse__storage_, userOutPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupOutPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupOutPeer),
        .number = ResponseMessageSearchResponse_FieldNumber_GroupOutPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseMessageSearchResponse__storage_, groupOutPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "totalCount",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMessageSearchResponse_FieldNumber_TotalCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseMessageSearchResponse__storage_, totalCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseMessageSearchResponse class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseMessageSearchResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageSearch

@implementation RequestMessageSearch

@dynamic hasQuery, query;

typedef struct RequestMessageSearch__storage_ {
  uint32_t _has_storage_[1];
  SearchCondition *query;
} RequestMessageSearch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchCondition),
        .number = RequestMessageSearch_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageSearch__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageSearch class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageSearch__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageSearchMore

@implementation RequestMessageSearchMore

@dynamic loadMoreState;

typedef struct RequestMessageSearchMore__storage_ {
  uint32_t _has_storage_[1];
  NSData *loadMoreState;
} RequestMessageSearchMore__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "loadMoreState",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageSearchMore_FieldNumber_LoadMoreState,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageSearchMore__storage_, loadMoreState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageSearchMore class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageSearchMore__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestSimpleSearch

@implementation RequestSimpleSearch

@dynamic criteriaArray, criteriaArray_Count;

typedef struct RequestSimpleSearch__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *criteriaArray;
} RequestSimpleSearch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "criteriaArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleSearchCondition),
        .number = RequestSimpleSearch_FieldNumber_CriteriaArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSimpleSearch__storage_, criteriaArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestSimpleSearch class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestSimpleSearch__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestSimpleSearchMore

@implementation RequestSimpleSearchMore

@dynamic loadMoreState;

typedef struct RequestSimpleSearchMore__storage_ {
  uint32_t _has_storage_[1];
  NSData *loadMoreState;
} RequestSimpleSearchMore__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "loadMoreState",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSimpleSearchMore_FieldNumber_LoadMoreState,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestSimpleSearchMore__storage_, loadMoreState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestSimpleSearchMore class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestSimpleSearchMore__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestFieldAutocomplete

@implementation RequestFieldAutocomplete

@dynamic fieldName;
@dynamic fieldValue;

typedef struct RequestFieldAutocomplete__storage_ {
  uint32_t _has_storage_[1];
  NSString *fieldName;
  NSString *fieldValue;
} RequestFieldAutocomplete__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fieldName",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestFieldAutocomplete_FieldNumber_FieldName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestFieldAutocomplete__storage_, fieldName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fieldValue",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestFieldAutocomplete_FieldNumber_FieldValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestFieldAutocomplete__storage_, fieldValue),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestFieldAutocomplete class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestFieldAutocomplete__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseFieldAutocomplete

@implementation ResponseFieldAutocomplete

@dynamic fieldName;
@dynamic fieldValueArray, fieldValueArray_Count;

typedef struct ResponseFieldAutocomplete__storage_ {
  uint32_t _has_storage_[1];
  NSString *fieldName;
  NSMutableArray *fieldValueArray;
} ResponseFieldAutocomplete__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fieldName",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseFieldAutocomplete_FieldNumber_FieldName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseFieldAutocomplete__storage_, fieldName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fieldValueArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseFieldAutocomplete_FieldNumber_FieldValueArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseFieldAutocomplete__storage_, fieldValueArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseFieldAutocomplete class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseFieldAutocomplete__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestLoadUserSearchByPredicatesResults

@implementation RequestLoadUserSearchByPredicatesResults

@dynamic predicatesArray, predicatesArray_Count;
@dynamic groupId;
@dynamic hasQuery, query;
@dynamic limit;
@dynamic requiredFieldsArray, requiredFieldsArray_Count;

typedef struct RequestLoadUserSearchByPredicatesResults__storage_ {
  uint32_t _has_storage_[1];
  int32_t limit;
  NSMutableArray *predicatesArray;
  NSString *groupId;
  GPBStringValue *query;
  NSMutableArray *requiredFieldsArray;
} RequestLoadUserSearchByPredicatesResults__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "predicatesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPredicate),
        .number = RequestLoadUserSearchByPredicatesResults_FieldNumber_PredicatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesResults__storage_, predicatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadUserSearchByPredicatesResults_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesResults__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "query",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestLoadUserSearchByPredicatesResults_FieldNumber_Query,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesResults__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadUserSearchByPredicatesResults_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesResults__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "requiredFieldsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadUserSearchByPredicatesResults_FieldNumber_RequiredFieldsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesResults__storage_, requiredFieldsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadUserSearchByPredicatesResults class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadUserSearchByPredicatesResults__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserMatch

@implementation UserMatch

@dynamic userId;
@dynamic matchPredicates;

typedef struct UserMatch__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} UserMatch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserMatch_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserMatch__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "matchPredicates",
        .dataTypeSpecific.clazz = Nil,
        .number = UserMatch_FieldNumber_MatchPredicates,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserMatch class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserMatch__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseLoadUserSearchByPredicatesResults

@implementation ResponseLoadUserSearchByPredicatesResults

@dynamic usersArray, usersArray_Count;
@dynamic resultCount;

typedef struct ResponseLoadUserSearchByPredicatesResults__storage_ {
  uint32_t _has_storage_[1];
  int32_t resultCount;
  NSMutableArray *usersArray;
} ResponseLoadUserSearchByPredicatesResults__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserMatch),
        .number = ResponseLoadUserSearchByPredicatesResults_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadUserSearchByPredicatesResults__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resultCount",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadUserSearchByPredicatesResults_FieldNumber_ResultCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseLoadUserSearchByPredicatesResults__storage_, resultCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadUserSearchByPredicatesResults class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadUserSearchByPredicatesResults__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestLoadUserSearchByPredicatesCount

@implementation RequestLoadUserSearchByPredicatesCount

@dynamic predicatesArray, predicatesArray_Count;
@dynamic groupId;

typedef struct RequestLoadUserSearchByPredicatesCount__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *predicatesArray;
  NSString *groupId;
} RequestLoadUserSearchByPredicatesCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "predicatesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPredicate),
        .number = RequestLoadUserSearchByPredicatesCount_FieldNumber_PredicatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesCount__storage_, predicatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadUserSearchByPredicatesCount_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesCount__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadUserSearchByPredicatesCount class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadUserSearchByPredicatesCount__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseLoadUserSearchByPredicatesCount

@implementation ResponseLoadUserSearchByPredicatesCount

@dynamic resultCount;

typedef struct ResponseLoadUserSearchByPredicatesCount__storage_ {
  uint32_t _has_storage_[1];
  int32_t resultCount;
} ResponseLoadUserSearchByPredicatesCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resultCount",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadUserSearchByPredicatesCount_FieldNumber_ResultCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseLoadUserSearchByPredicatesCount__storage_, resultCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadUserSearchByPredicatesCount class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadUserSearchByPredicatesCount__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestGetRecommendations

@implementation RequestGetRecommendations


typedef struct RequestGetRecommendations__storage_ {
  uint32_t _has_storage_[1];
} RequestGetRecommendations__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestGetRecommendations class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RequestGetRecommendations__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetRecommendations

@implementation ResponseGetRecommendations

@dynamic peersArray, peersArray_Count;

typedef struct ResponseGetRecommendations__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersArray;
} ResponseGetRecommendations__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = ResponseGetRecommendations_FieldNumber_PeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseGetRecommendations__storage_, peersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetRecommendations class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetRecommendations__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestGetPromotedPeers

@implementation RequestGetPromotedPeers


typedef struct RequestGetPromotedPeers__storage_ {
  uint32_t _has_storage_[1];
} RequestGetPromotedPeers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestGetPromotedPeers class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RequestGetPromotedPeers__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetPromotedPeers

@implementation ResponseGetPromotedPeers

@dynamic userPeersArray, userPeersArray_Count;
@dynamic groupPeersArray, groupPeersArray_Count;

typedef struct ResponseGetPromotedPeers__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userPeersArray;
  NSMutableArray *groupPeersArray;
} ResponseGetPromotedPeers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOutPeer),
        .number = ResponseGetPromotedPeers_FieldNumber_UserPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseGetPromotedPeers__storage_, userPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupOutPeer),
        .number = ResponseGetPromotedPeers_FieldNumber_GroupPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseGetPromotedPeers__storage_, groupPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetPromotedPeers class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetPromotedPeers__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestSearch

@implementation RequestSearch

@dynamic query;
@dynamic limit;
@dynamic hasCursor, cursor;
@dynamic hasCondition, condition;

typedef struct RequestSearch__storage_ {
  uint32_t _has_storage_[1];
  int32_t limit;
  NSString *query;
  GPBBytesValue *cursor;
  SearchCondition *condition;
} RequestSearch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSearch_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestSearch__storage_, query),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSearch_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestSearch__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cursor",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBytesValue),
        .number = RequestSearch_FieldNumber_Cursor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestSearch__storage_, cursor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "condition",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchCondition),
        .number = RequestSearch_FieldNumber_Condition,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestSearch__storage_, condition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestSearch class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestSearch__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseSearch

@implementation ResponseSearch

@dynamic searchResultsArray, searchResultsArray_Count;
@dynamic userData, userData_Count;
@dynamic groupData, groupData_Count;
@dynamic hasNextCursor, nextCursor;

typedef struct ResponseSearch__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *searchResultsArray;
  NSMutableDictionary *userData;
  NSMutableDictionary *groupData;
  GPBBytesValue *nextCursor;
} ResponseSearch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "searchResultsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchResult),
        .number = ResponseSearch_FieldNumber_SearchResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseSearch__storage_, searchResultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userData",
        .dataTypeSpecific.clazz = GPBObjCClass(UserData),
        .number = ResponseSearch_FieldNumber_UserData,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseSearch__storage_, userData),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupData",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupData),
        .number = ResponseSearch_FieldNumber_GroupData,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseSearch__storage_, groupData),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextCursor",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBytesValue),
        .number = ResponseSearch_FieldNumber_NextCursor,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseSearch__storage_, nextCursor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseSearch class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseSearch__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
