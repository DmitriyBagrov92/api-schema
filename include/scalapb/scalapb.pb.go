// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: scalapb/scalapb.proto

package scalapb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ScalaPbOptions struct {
	// If set then it overrides the java_package and package.
	PackageName string `protobuf:"bytes,1,opt,name=package_name,json=packageName" json:"package_name"`
	// If true, the compiler does not append the proto base file name
	// into the generated package name. If false (the default), the
	// generated scala package name is the package_name.basename where
	// basename is the proto file name without the .proto extension.
	FlatPackage bool `protobuf:"varint,2,opt,name=flat_package,json=flatPackage" json:"flat_package"`
	// Adds the following imports at the top of the file (this is meant
	// to provide implicit TypeMappers)
	Import []string `protobuf:"bytes,3,rep,name=import" json:"import,omitempty"`
	// Text to add to the generated scala file.  This can be used only
	// when single_file is true.
	Preamble []string `protobuf:"bytes,4,rep,name=preamble" json:"preamble,omitempty"`
	// If true, all messages and enums (but not services) will be written
	// to a single Scala file.
	SingleFile bool `protobuf:"varint,5,opt,name=single_file,json=singleFile" json:"single_file"`
	// When this option is enabled, wrappers defined at
	// https://github.com/google/protobuf/blob/master/src/google/protobuf/wrappers.proto,
	// are mapped to an Option[T] where T is a primitive type.
	PrimitiveWrappers bool `protobuf:"varint,6,opt,name=primitive_wrappers,json=primitiveWrappers" json:"primitive_wrappers"`
}

func (m *ScalaPbOptions) Reset()      { *m = ScalaPbOptions{} }
func (*ScalaPbOptions) ProtoMessage() {}
func (*ScalaPbOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_8b9e851cf3ec1bec, []int{0}
}
func (m *ScalaPbOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScalaPbOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScalaPbOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScalaPbOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScalaPbOptions.Merge(m, src)
}
func (m *ScalaPbOptions) XXX_Size() int {
	return m.Size()
}
func (m *ScalaPbOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ScalaPbOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ScalaPbOptions proto.InternalMessageInfo

func (m *ScalaPbOptions) GetPackageName() string {
	if m != nil {
		return m.PackageName
	}
	return ""
}

func (m *ScalaPbOptions) GetFlatPackage() bool {
	if m != nil {
		return m.FlatPackage
	}
	return false
}

func (m *ScalaPbOptions) GetImport() []string {
	if m != nil {
		return m.Import
	}
	return nil
}

func (m *ScalaPbOptions) GetPreamble() []string {
	if m != nil {
		return m.Preamble
	}
	return nil
}

func (m *ScalaPbOptions) GetSingleFile() bool {
	if m != nil {
		return m.SingleFile
	}
	return false
}

func (m *ScalaPbOptions) GetPrimitiveWrappers() bool {
	if m != nil {
		return m.PrimitiveWrappers
	}
	return false
}

type MessageOptions struct {
	// Additional classes and traits to mix in to the case class.
	Extends []string `protobuf:"bytes,1,rep,name=extends" json:"extends,omitempty"`
	// Additional classes and traits to mix in to the companion object.
	CompanionExtends []string `protobuf:"bytes,2,rep,name=companion_extends,json=companionExtends" json:"companion_extends,omitempty"`
}

func (m *MessageOptions) Reset()      { *m = MessageOptions{} }
func (*MessageOptions) ProtoMessage() {}
func (*MessageOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_8b9e851cf3ec1bec, []int{1}
}
func (m *MessageOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageOptions.Merge(m, src)
}
func (m *MessageOptions) XXX_Size() int {
	return m.Size()
}
func (m *MessageOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageOptions.DiscardUnknown(m)
}

var xxx_messageInfo_MessageOptions proto.InternalMessageInfo

func (m *MessageOptions) GetExtends() []string {
	if m != nil {
		return m.Extends
	}
	return nil
}

func (m *MessageOptions) GetCompanionExtends() []string {
	if m != nil {
		return m.CompanionExtends
	}
	return nil
}

type FieldOptions struct {
	Type string `protobuf:"bytes,1,opt,name=type" json:"type"`
}

func (m *FieldOptions) Reset()      { *m = FieldOptions{} }
func (*FieldOptions) ProtoMessage() {}
func (*FieldOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_8b9e851cf3ec1bec, []int{2}
}
func (m *FieldOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldOptions.Merge(m, src)
}
func (m *FieldOptions) XXX_Size() int {
	return m.Size()
}
func (m *FieldOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldOptions.DiscardUnknown(m)
}

var xxx_messageInfo_FieldOptions proto.InternalMessageInfo

func (m *FieldOptions) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

var E_Options = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FileOptions)(nil),
	ExtensionType: (*ScalaPbOptions)(nil),
	Field:         1020,
	Name:          "scalapb.options",
	Tag:           "bytes,1020,opt,name=options",
	Filename:      "scalapb/scalapb.proto",
}

var E_Message = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*MessageOptions)(nil),
	Field:         1020,
	Name:          "scalapb.message",
	Tag:           "bytes,1020,opt,name=message",
	Filename:      "scalapb/scalapb.proto",
}

var E_Field = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*FieldOptions)(nil),
	Field:         1020,
	Name:          "scalapb.field",
	Tag:           "bytes,1020,opt,name=field",
	Filename:      "scalapb/scalapb.proto",
}

func init() {
	proto.RegisterType((*ScalaPbOptions)(nil), "scalapb.ScalaPbOptions")
	proto.RegisterType((*MessageOptions)(nil), "scalapb.MessageOptions")
	proto.RegisterType((*FieldOptions)(nil), "scalapb.FieldOptions")
	proto.RegisterExtension(E_Options)
	proto.RegisterExtension(E_Message)
	proto.RegisterExtension(E_Field)
}

func init() { proto.RegisterFile("scalapb/scalapb.proto", fileDescriptor_8b9e851cf3ec1bec) }

var fileDescriptor_8b9e851cf3ec1bec = []byte{
	// 450 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x91, 0x3d, 0x6b, 0xdb, 0x40,
	0x18, 0xc7, 0x75, 0x89, 0x13, 0x25, 0xe7, 0x10, 0x9a, 0x83, 0xa4, 0x47, 0x68, 0x2f, 0xc2, 0x50,
	0x2a, 0x28, 0xc8, 0xd0, 0x6e, 0x1e, 0x03, 0xcd, 0xd2, 0x37, 0xa3, 0x0c, 0x19, 0xc5, 0x59, 0x7e,
	0x2c, 0x8e, 0x4a, 0xba, 0xe3, 0x74, 0xe9, 0xcb, 0xd6, 0x8f, 0xd0, 0x8f, 0xd1, 0x8f, 0x92, 0xd1,
	0x63, 0xa6, 0x52, 0xcb, 0x4b, 0xc7, 0xd0, 0xb9, 0x43, 0x91, 0x74, 0xe7, 0xd8, 0xa4, 0x93, 0x79,
	0x9e, 0xdf, 0x9f, 0x9f, 0xef, 0xaf, 0x07, 0x1f, 0x57, 0x29, 0xcf, 0xb9, 0x9a, 0x0c, 0xed, 0x6f,
	0xa4, 0xb4, 0x34, 0x92, 0xf8, 0x76, 0x3c, 0x0d, 0x32, 0x29, 0xb3, 0x1c, 0x86, 0xed, 0x7a, 0x72,
	0x3d, 0x1b, 0x4e, 0xa1, 0x4a, 0xb5, 0x50, 0x46, 0xea, 0x2e, 0x3a, 0xf8, 0x83, 0xf0, 0xe1, 0x65,
	0x93, 0x1e, 0x4f, 0x3e, 0x28, 0x23, 0x64, 0x59, 0x91, 0xe7, 0xf8, 0x40, 0xf1, 0xf4, 0x23, 0xcf,
	0x20, 0x29, 0x79, 0x01, 0x14, 0x05, 0x28, 0xdc, 0x3f, 0xef, 0xdd, 0xfc, 0x3c, 0xf3, 0xe2, 0xbe,
	0x25, 0xef, 0x79, 0x01, 0x4d, 0x70, 0x96, 0x73, 0x93, 0xd8, 0x1d, 0xdd, 0x0a, 0x50, 0xb8, 0xe7,
	0x82, 0x0d, 0x19, 0x77, 0x80, 0x9c, 0xe0, 0x5d, 0x51, 0x28, 0xa9, 0x0d, 0xdd, 0x0e, 0xb6, 0xc3,
	0xfd, 0xd8, 0x4e, 0xe4, 0x14, 0xef, 0x29, 0x0d, 0xbc, 0x98, 0xe4, 0x40, 0x7b, 0x2d, 0x59, 0xcd,
	0xe4, 0x19, 0xee, 0x57, 0xa2, 0xcc, 0x72, 0x48, 0x66, 0x22, 0x07, 0xba, 0xb3, 0xe6, 0xc6, 0x1d,
	0xb8, 0x10, 0x39, 0x90, 0x57, 0x98, 0x28, 0x2d, 0x0a, 0x61, 0xc4, 0x27, 0x48, 0x3e, 0x6b, 0xae,
	0x14, 0xe8, 0x8a, 0xee, 0xae, 0xa5, 0x8f, 0x56, 0xfc, 0xca, 0xe2, 0xc1, 0x15, 0x3e, 0x7c, 0x07,
	0x55, 0xc5, 0x33, 0x70, 0x9d, 0x29, 0xf6, 0xe1, 0x8b, 0x81, 0x72, 0x5a, 0x51, 0xd4, 0x3e, 0xc4,
	0x8d, 0xe4, 0x05, 0x3e, 0x4a, 0x65, 0xa1, 0x78, 0x29, 0x64, 0x99, 0xb8, 0xcc, 0x56, 0x9b, 0x79,
	0xb4, 0x02, 0xaf, 0xbb, 0xfd, 0x20, 0xc4, 0x07, 0x17, 0x02, 0xf2, 0xe9, 0xbd, 0xb6, 0x67, 0xbe,
	0xaa, 0xcd, 0x4f, 0xd8, 0x6e, 0x46, 0x63, 0xec, 0x4b, 0x1b, 0x7a, 0x12, 0x75, 0x57, 0x8a, 0xdc,
	0x95, 0xa2, 0xa6, 0x99, 0x55, 0xd0, 0xbf, 0x7e, 0x80, 0xc2, 0xfe, 0xcb, 0xc7, 0x91, 0x3b, 0xf1,
	0xe6, 0xb5, 0x62, 0xa7, 0x19, 0x5d, 0x62, 0xbf, 0xe8, 0x4a, 0x91, 0xb3, 0x07, 0xc6, 0xcd, 0xba,
	0x0f, 0xa5, 0x9b, 0x3c, 0x76, 0xa6, 0xd1, 0x1b, 0xbc, 0x33, 0x6b, 0x0a, 0x91, 0xa7, 0xff, 0x79,
	0xe4, 0x7d, 0x51, 0x27, 0x3c, 0x5e, 0x09, 0xd7, 0x69, 0xdc, 0x39, 0xce, 0xdf, 0xce, 0x17, 0xcc,
	0xbb, 0x5d, 0x30, 0xef, 0x6e, 0xc1, 0xd0, 0xb7, 0x9a, 0xa1, 0x1f, 0x35, 0x43, 0x37, 0x35, 0x43,
	0xf3, 0x9a, 0xa1, 0x5f, 0x35, 0x43, 0xbf, 0x6b, 0xe6, 0xdd, 0xd5, 0x0c, 0x7d, 0x5f, 0x32, 0x6f,
	0xbe, 0x64, 0xde, 0xed, 0x92, 0x79, 0xf8, 0x24, 0x95, 0x45, 0x64, 0xf4, 0x35, 0xf0, 0x34, 0x95,
	0x7a, 0xea, 0xfe, 0xe1, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9a, 0x54, 0x5d, 0x95, 0xfc, 0x02,
	0x00, 0x00,
}

func (this *ScalaPbOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalaPbOptions)
	if !ok {
		that2, ok := that.(ScalaPbOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PackageName != that1.PackageName {
		return false
	}
	if this.FlatPackage != that1.FlatPackage {
		return false
	}
	if len(this.Import) != len(that1.Import) {
		return false
	}
	for i := range this.Import {
		if this.Import[i] != that1.Import[i] {
			return false
		}
	}
	if len(this.Preamble) != len(that1.Preamble) {
		return false
	}
	for i := range this.Preamble {
		if this.Preamble[i] != that1.Preamble[i] {
			return false
		}
	}
	if this.SingleFile != that1.SingleFile {
		return false
	}
	if this.PrimitiveWrappers != that1.PrimitiveWrappers {
		return false
	}
	return true
}
func (this *MessageOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageOptions)
	if !ok {
		that2, ok := that.(MessageOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Extends) != len(that1.Extends) {
		return false
	}
	for i := range this.Extends {
		if this.Extends[i] != that1.Extends[i] {
			return false
		}
	}
	if len(this.CompanionExtends) != len(that1.CompanionExtends) {
		return false
	}
	for i := range this.CompanionExtends {
		if this.CompanionExtends[i] != that1.CompanionExtends[i] {
			return false
		}
	}
	return true
}
func (this *FieldOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FieldOptions)
	if !ok {
		that2, ok := that.(FieldOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *ScalaPbOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&scalapb.ScalaPbOptions{")
	s = append(s, "PackageName: "+fmt.Sprintf("%#v", this.PackageName)+",\n")
	s = append(s, "FlatPackage: "+fmt.Sprintf("%#v", this.FlatPackage)+",\n")
	if this.Import != nil {
		s = append(s, "Import: "+fmt.Sprintf("%#v", this.Import)+",\n")
	}
	if this.Preamble != nil {
		s = append(s, "Preamble: "+fmt.Sprintf("%#v", this.Preamble)+",\n")
	}
	s = append(s, "SingleFile: "+fmt.Sprintf("%#v", this.SingleFile)+",\n")
	s = append(s, "PrimitiveWrappers: "+fmt.Sprintf("%#v", this.PrimitiveWrappers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MessageOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&scalapb.MessageOptions{")
	if this.Extends != nil {
		s = append(s, "Extends: "+fmt.Sprintf("%#v", this.Extends)+",\n")
	}
	if this.CompanionExtends != nil {
		s = append(s, "CompanionExtends: "+fmt.Sprintf("%#v", this.CompanionExtends)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FieldOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&scalapb.FieldOptions{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringScalapb(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ScalaPbOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScalaPbOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalaPbOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.PrimitiveWrappers {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	i--
	if m.SingleFile {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	if len(m.Preamble) > 0 {
		for iNdEx := len(m.Preamble) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Preamble[iNdEx])
			copy(dAtA[i:], m.Preamble[iNdEx])
			i = encodeVarintScalapb(dAtA, i, uint64(len(m.Preamble[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Import) > 0 {
		for iNdEx := len(m.Import) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Import[iNdEx])
			copy(dAtA[i:], m.Import[iNdEx])
			i = encodeVarintScalapb(dAtA, i, uint64(len(m.Import[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	i--
	if m.FlatPackage {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i -= len(m.PackageName)
	copy(dAtA[i:], m.PackageName)
	i = encodeVarintScalapb(dAtA, i, uint64(len(m.PackageName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MessageOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CompanionExtends) > 0 {
		for iNdEx := len(m.CompanionExtends) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CompanionExtends[iNdEx])
			copy(dAtA[i:], m.CompanionExtends[iNdEx])
			i = encodeVarintScalapb(dAtA, i, uint64(len(m.CompanionExtends[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Extends) > 0 {
		for iNdEx := len(m.Extends) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Extends[iNdEx])
			copy(dAtA[i:], m.Extends[iNdEx])
			i = encodeVarintScalapb(dAtA, i, uint64(len(m.Extends[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FieldOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintScalapb(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintScalapb(dAtA []byte, offset int, v uint64) int {
	offset -= sovScalapb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ScalaPbOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PackageName)
	n += 1 + l + sovScalapb(uint64(l))
	n += 2
	if len(m.Import) > 0 {
		for _, s := range m.Import {
			l = len(s)
			n += 1 + l + sovScalapb(uint64(l))
		}
	}
	if len(m.Preamble) > 0 {
		for _, s := range m.Preamble {
			l = len(s)
			n += 1 + l + sovScalapb(uint64(l))
		}
	}
	n += 2
	n += 2
	return n
}

func (m *MessageOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Extends) > 0 {
		for _, s := range m.Extends {
			l = len(s)
			n += 1 + l + sovScalapb(uint64(l))
		}
	}
	if len(m.CompanionExtends) > 0 {
		for _, s := range m.CompanionExtends {
			l = len(s)
			n += 1 + l + sovScalapb(uint64(l))
		}
	}
	return n
}

func (m *FieldOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovScalapb(uint64(l))
	return n
}

func sovScalapb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozScalapb(x uint64) (n int) {
	return sovScalapb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ScalaPbOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalaPbOptions{`,
		`PackageName:` + fmt.Sprintf("%v", this.PackageName) + `,`,
		`FlatPackage:` + fmt.Sprintf("%v", this.FlatPackage) + `,`,
		`Import:` + fmt.Sprintf("%v", this.Import) + `,`,
		`Preamble:` + fmt.Sprintf("%v", this.Preamble) + `,`,
		`SingleFile:` + fmt.Sprintf("%v", this.SingleFile) + `,`,
		`PrimitiveWrappers:` + fmt.Sprintf("%v", this.PrimitiveWrappers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageOptions{`,
		`Extends:` + fmt.Sprintf("%v", this.Extends) + `,`,
		`CompanionExtends:` + fmt.Sprintf("%v", this.CompanionExtends) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FieldOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FieldOptions{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringScalapb(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ScalaPbOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScalapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScalaPbOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScalaPbOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScalapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScalapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScalapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlatPackage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScalapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlatPackage = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Import", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScalapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScalapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScalapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Import = append(m.Import, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preamble", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScalapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScalapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScalapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Preamble = append(m.Preamble, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleFile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScalapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SingleFile = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimitiveWrappers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScalapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrimitiveWrappers = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipScalapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScalapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScalapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScalapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extends", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScalapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScalapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScalapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extends = append(m.Extends, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompanionExtends", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScalapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScalapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScalapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompanionExtends = append(m.CompanionExtends, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScalapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScalapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScalapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScalapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScalapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScalapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScalapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScalapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScalapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScalapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipScalapb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowScalapb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScalapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScalapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthScalapb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupScalapb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthScalapb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthScalapb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowScalapb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupScalapb = fmt.Errorf("proto: unexpected end of group")
)
