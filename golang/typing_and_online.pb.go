// Code generated by protoc-gen-gogo.
// source: typing_and_online.proto
// DO NOT EDIT!

package dialog

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/wrappers"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/gogo/protobuf/types"

import strconv "strconv"

import strings "strings"
import reflect "reflect"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TypingType int32

const (
	TYPINGTYPE_UNKNOWN TypingType = 0
	TYPINGTYPE_TEXT    TypingType = 1
)

var TypingType_name = map[int32]string{
	0: "TYPINGTYPE_UNKNOWN",
	1: "TYPINGTYPE_TEXT",
}
var TypingType_value = map[string]int32{
	"TYPINGTYPE_UNKNOWN": 0,
	"TYPINGTYPE_TEXT":    1,
}

func (TypingType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypingAndOnline, []int{0} }

type DeviceType int32

const (
	DEVICETYPE_UNKNOWN DeviceType = 0
	DEVICETYPE_GENERIC DeviceType = 1
	DEVICETYPE_PC      DeviceType = 2
	DEVICETYPE_MOBILE  DeviceType = 3
	DEVICETYPE_TABLET  DeviceType = 4
	DEVICETYPE_WATCH   DeviceType = 5
	DEVICETYPE_MIRROR  DeviceType = 6
	DEVICETYPE_CAR     DeviceType = 7
	DEVICETYPE_TABLE   DeviceType = 8
)

var DeviceType_name = map[int32]string{
	0: "DEVICETYPE_UNKNOWN",
	1: "DEVICETYPE_GENERIC",
	2: "DEVICETYPE_PC",
	3: "DEVICETYPE_MOBILE",
	4: "DEVICETYPE_TABLET",
	5: "DEVICETYPE_WATCH",
	6: "DEVICETYPE_MIRROR",
	7: "DEVICETYPE_CAR",
	8: "DEVICETYPE_TABLE",
}
var DeviceType_value = map[string]int32{
	"DEVICETYPE_UNKNOWN": 0,
	"DEVICETYPE_GENERIC": 1,
	"DEVICETYPE_PC":      2,
	"DEVICETYPE_MOBILE":  3,
	"DEVICETYPE_TABLET":  4,
	"DEVICETYPE_WATCH":   5,
	"DEVICETYPE_MIRROR":  6,
	"DEVICETYPE_CAR":     7,
	"DEVICETYPE_TABLE":   8,
}

func (DeviceType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypingAndOnline, []int{1} }

// Sending typing notification
type RequestTyping struct {
	Peer       *OutPeer   `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	TypingType TypingType `protobuf:"varint,3,opt,name=typing_type,json=typingType,proto3,enum=dialog.TypingType" json:"typing_type,omitempty"`
}

func (m *RequestTyping) Reset()                    { *m = RequestTyping{} }
func (*RequestTyping) ProtoMessage()               {}
func (*RequestTyping) Descriptor() ([]byte, []int) { return fileDescriptorTypingAndOnline, []int{0} }

func (m *RequestTyping) GetPeer() *OutPeer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *RequestTyping) GetTypingType() TypingType {
	if m != nil {
		return m.TypingType
	}
	return TYPINGTYPE_UNKNOWN
}

// Stop typing
type RequestStopTyping struct {
	Peer       *OutPeer   `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	TypingType TypingType `protobuf:"varint,2,opt,name=typing_type,json=typingType,proto3,enum=dialog.TypingType" json:"typing_type,omitempty"`
}

func (m *RequestStopTyping) Reset()                    { *m = RequestStopTyping{} }
func (*RequestStopTyping) ProtoMessage()               {}
func (*RequestStopTyping) Descriptor() ([]byte, []int) { return fileDescriptorTypingAndOnline, []int{1} }

func (m *RequestStopTyping) GetPeer() *OutPeer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *RequestStopTyping) GetTypingType() TypingType {
	if m != nil {
		return m.TypingType
	}
	return TYPINGTYPE_UNKNOWN
}

// Sending online state
type RequestSetOnline struct {
	IsOnline       bool                         `protobuf:"varint,1,opt,name=is_online,json=isOnline,proto3" json:"is_online,omitempty"`
	Timeout        int64                        `protobuf:"varint,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
	DeviceType     DeviceType                   `protobuf:"varint,3,opt,name=device_type,json=deviceType,proto3,enum=dialog.DeviceType" json:"device_type,omitempty"`
	DeviceCategory *google_protobuf.StringValue `protobuf:"bytes,4,opt,name=device_category,json=deviceCategory" json:"device_category,omitempty"`
}

func (m *RequestSetOnline) Reset()                    { *m = RequestSetOnline{} }
func (*RequestSetOnline) ProtoMessage()               {}
func (*RequestSetOnline) Descriptor() ([]byte, []int) { return fileDescriptorTypingAndOnline, []int{2} }

func (m *RequestSetOnline) GetIsOnline() bool {
	if m != nil {
		return m.IsOnline
	}
	return false
}

func (m *RequestSetOnline) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *RequestSetOnline) GetDeviceType() DeviceType {
	if m != nil {
		return m.DeviceType
	}
	return DEVICETYPE_UNKNOWN
}

func (m *RequestSetOnline) GetDeviceCategory() *google_protobuf.StringValue {
	if m != nil {
		return m.DeviceCategory
	}
	return nil
}

// Update about pausing notifications
type UpdatePauseNotifications struct {
	Timeout int32 `protobuf:"varint,1,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *UpdatePauseNotifications) Reset()      { *m = UpdatePauseNotifications{} }
func (*UpdatePauseNotifications) ProtoMessage() {}
func (*UpdatePauseNotifications) Descriptor() ([]byte, []int) {
	return fileDescriptorTypingAndOnline, []int{3}
}

func (m *UpdatePauseNotifications) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

// Update about restoring notifications
type UpdateRestoreNotifications struct {
}

func (m *UpdateRestoreNotifications) Reset()      { *m = UpdateRestoreNotifications{} }
func (*UpdateRestoreNotifications) ProtoMessage() {}
func (*UpdateRestoreNotifications) Descriptor() ([]byte, []int) {
	return fileDescriptorTypingAndOnline, []int{4}
}

// Pause notifications
type RequestPauseNotifications struct {
	Timeout int32 `protobuf:"varint,1,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *RequestPauseNotifications) Reset()      { *m = RequestPauseNotifications{} }
func (*RequestPauseNotifications) ProtoMessage() {}
func (*RequestPauseNotifications) Descriptor() ([]byte, []int) {
	return fileDescriptorTypingAndOnline, []int{5}
}

func (m *RequestPauseNotifications) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

// Restoring notifications
type RequestRestoreNotifications struct {
}

func (m *RequestRestoreNotifications) Reset()      { *m = RequestRestoreNotifications{} }
func (*RequestRestoreNotifications) ProtoMessage() {}
func (*RequestRestoreNotifications) Descriptor() ([]byte, []int) {
	return fileDescriptorTypingAndOnline, []int{6}
}

// Update about user's typing
type UpdateTyping struct {
	Peer       *Peer      `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	Uid        int32      `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	TypingType TypingType `protobuf:"varint,3,opt,name=typing_type,json=typingType,proto3,enum=dialog.TypingType" json:"typing_type,omitempty"`
}

func (m *UpdateTyping) Reset()                    { *m = UpdateTyping{} }
func (*UpdateTyping) ProtoMessage()               {}
func (*UpdateTyping) Descriptor() ([]byte, []int) { return fileDescriptorTypingAndOnline, []int{7} }

func (m *UpdateTyping) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateTyping) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateTyping) GetTypingType() TypingType {
	if m != nil {
		return m.TypingType
	}
	return TYPINGTYPE_UNKNOWN
}

// Update about user's typing stop
type UpdateTypingStop struct {
	Peer       *Peer      `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	Uid        int32      `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	TypingType TypingType `protobuf:"varint,3,opt,name=typing_type,json=typingType,proto3,enum=dialog.TypingType" json:"typing_type,omitempty"`
}

func (m *UpdateTypingStop) Reset()                    { *m = UpdateTypingStop{} }
func (*UpdateTypingStop) ProtoMessage()               {}
func (*UpdateTypingStop) Descriptor() ([]byte, []int) { return fileDescriptorTypingAndOnline, []int{8} }

func (m *UpdateTypingStop) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateTypingStop) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateTypingStop) GetTypingType() TypingType {
	if m != nil {
		return m.TypingType
	}
	return TYPINGTYPE_UNKNOWN
}

// Update about user became online
type UpdateUserOnline struct {
	Uid            int32                        `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	DeviceType     DeviceType                   `protobuf:"varint,2,opt,name=device_type,json=deviceType,proto3,enum=dialog.DeviceType" json:"device_type,omitempty"`
	DeviceCategory *google_protobuf.StringValue `protobuf:"bytes,3,opt,name=device_category,json=deviceCategory" json:"device_category,omitempty"`
}

func (m *UpdateUserOnline) Reset()                    { *m = UpdateUserOnline{} }
func (*UpdateUserOnline) ProtoMessage()               {}
func (*UpdateUserOnline) Descriptor() ([]byte, []int) { return fileDescriptorTypingAndOnline, []int{9} }

func (m *UpdateUserOnline) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateUserOnline) GetDeviceType() DeviceType {
	if m != nil {
		return m.DeviceType
	}
	return DEVICETYPE_UNKNOWN
}

func (m *UpdateUserOnline) GetDeviceCategory() *google_protobuf.StringValue {
	if m != nil {
		return m.DeviceCategory
	}
	return nil
}

// Update about user became offline
type UpdateUserOffline struct {
	Uid            int32                        `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	DeviceType     DeviceType                   `protobuf:"varint,2,opt,name=device_type,json=deviceType,proto3,enum=dialog.DeviceType" json:"device_type,omitempty"`
	DeviceCategory *google_protobuf.StringValue `protobuf:"bytes,3,opt,name=device_category,json=deviceCategory" json:"device_category,omitempty"`
}

func (m *UpdateUserOffline) Reset()      { *m = UpdateUserOffline{} }
func (*UpdateUserOffline) ProtoMessage() {}
func (*UpdateUserOffline) Descriptor() ([]byte, []int) {
	return fileDescriptorTypingAndOnline, []int{10}
}

func (m *UpdateUserOffline) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateUserOffline) GetDeviceType() DeviceType {
	if m != nil {
		return m.DeviceType
	}
	return DEVICETYPE_UNKNOWN
}

func (m *UpdateUserOffline) GetDeviceCategory() *google_protobuf.StringValue {
	if m != nil {
		return m.DeviceCategory
	}
	return nil
}

// Update about user's last seen state
type UpdateUserLastSeen struct {
	Uid            int32                        `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Date           int64                        `protobuf:"varint,2,opt,name=date,proto3" json:"date,omitempty"`
	DeviceType     DeviceType                   `protobuf:"varint,3,opt,name=device_type,json=deviceType,proto3,enum=dialog.DeviceType" json:"device_type,omitempty"`
	DeviceCategory *google_protobuf.StringValue `protobuf:"bytes,4,opt,name=device_category,json=deviceCategory" json:"device_category,omitempty"`
}

func (m *UpdateUserLastSeen) Reset()      { *m = UpdateUserLastSeen{} }
func (*UpdateUserLastSeen) ProtoMessage() {}
func (*UpdateUserLastSeen) Descriptor() ([]byte, []int) {
	return fileDescriptorTypingAndOnline, []int{11}
}

func (m *UpdateUserLastSeen) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateUserLastSeen) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *UpdateUserLastSeen) GetDeviceType() DeviceType {
	if m != nil {
		return m.DeviceType
	}
	return DEVICETYPE_UNKNOWN
}

func (m *UpdateUserLastSeen) GetDeviceCategory() *google_protobuf.StringValue {
	if m != nil {
		return m.DeviceCategory
	}
	return nil
}

// Update about group online change
type UpdateGroupOnline struct {
	GroupId int32 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	// / amount of online users
	Count int32 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *UpdateGroupOnline) Reset()      { *m = UpdateGroupOnline{} }
func (*UpdateGroupOnline) ProtoMessage() {}
func (*UpdateGroupOnline) Descriptor() ([]byte, []int) {
	return fileDescriptorTypingAndOnline, []int{12}
}

func (m *UpdateGroupOnline) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupOnline) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func init() {
	proto.RegisterType((*RequestTyping)(nil), "dialog.RequestTyping")
	proto.RegisterType((*RequestStopTyping)(nil), "dialog.RequestStopTyping")
	proto.RegisterType((*RequestSetOnline)(nil), "dialog.RequestSetOnline")
	proto.RegisterType((*UpdatePauseNotifications)(nil), "dialog.UpdatePauseNotifications")
	proto.RegisterType((*UpdateRestoreNotifications)(nil), "dialog.UpdateRestoreNotifications")
	proto.RegisterType((*RequestPauseNotifications)(nil), "dialog.RequestPauseNotifications")
	proto.RegisterType((*RequestRestoreNotifications)(nil), "dialog.RequestRestoreNotifications")
	proto.RegisterType((*UpdateTyping)(nil), "dialog.UpdateTyping")
	proto.RegisterType((*UpdateTypingStop)(nil), "dialog.UpdateTypingStop")
	proto.RegisterType((*UpdateUserOnline)(nil), "dialog.UpdateUserOnline")
	proto.RegisterType((*UpdateUserOffline)(nil), "dialog.UpdateUserOffline")
	proto.RegisterType((*UpdateUserLastSeen)(nil), "dialog.UpdateUserLastSeen")
	proto.RegisterType((*UpdateGroupOnline)(nil), "dialog.UpdateGroupOnline")
	proto.RegisterEnum("dialog.TypingType", TypingType_name, TypingType_value)
	proto.RegisterEnum("dialog.DeviceType", DeviceType_name, DeviceType_value)
}
func (x TypingType) String() string {
	s, ok := TypingType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DeviceType) String() string {
	s, ok := DeviceType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *RequestTyping) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestTyping)
	if !ok {
		that2, ok := that.(RequestTyping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Peer.Equal(that1.Peer) {
		return false
	}
	if this.TypingType != that1.TypingType {
		return false
	}
	return true
}
func (this *RequestStopTyping) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestStopTyping)
	if !ok {
		that2, ok := that.(RequestStopTyping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Peer.Equal(that1.Peer) {
		return false
	}
	if this.TypingType != that1.TypingType {
		return false
	}
	return true
}
func (this *RequestSetOnline) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestSetOnline)
	if !ok {
		that2, ok := that.(RequestSetOnline)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.IsOnline != that1.IsOnline {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if this.DeviceType != that1.DeviceType {
		return false
	}
	if !this.DeviceCategory.Equal(that1.DeviceCategory) {
		return false
	}
	return true
}
func (this *UpdatePauseNotifications) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdatePauseNotifications)
	if !ok {
		that2, ok := that.(UpdatePauseNotifications)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *UpdateRestoreNotifications) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateRestoreNotifications)
	if !ok {
		that2, ok := that.(UpdateRestoreNotifications)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *RequestPauseNotifications) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestPauseNotifications)
	if !ok {
		that2, ok := that.(RequestPauseNotifications)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *RequestRestoreNotifications) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestRestoreNotifications)
	if !ok {
		that2, ok := that.(RequestRestoreNotifications)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *UpdateTyping) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateTyping)
	if !ok {
		that2, ok := that.(UpdateTyping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Peer.Equal(that1.Peer) {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.TypingType != that1.TypingType {
		return false
	}
	return true
}
func (this *UpdateTypingStop) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateTypingStop)
	if !ok {
		that2, ok := that.(UpdateTypingStop)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Peer.Equal(that1.Peer) {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.TypingType != that1.TypingType {
		return false
	}
	return true
}
func (this *UpdateUserOnline) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateUserOnline)
	if !ok {
		that2, ok := that.(UpdateUserOnline)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.DeviceType != that1.DeviceType {
		return false
	}
	if !this.DeviceCategory.Equal(that1.DeviceCategory) {
		return false
	}
	return true
}
func (this *UpdateUserOffline) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateUserOffline)
	if !ok {
		that2, ok := that.(UpdateUserOffline)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.DeviceType != that1.DeviceType {
		return false
	}
	if !this.DeviceCategory.Equal(that1.DeviceCategory) {
		return false
	}
	return true
}
func (this *UpdateUserLastSeen) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateUserLastSeen)
	if !ok {
		that2, ok := that.(UpdateUserLastSeen)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	if this.DeviceType != that1.DeviceType {
		return false
	}
	if !this.DeviceCategory.Equal(that1.DeviceCategory) {
		return false
	}
	return true
}
func (this *UpdateGroupOnline) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateGroupOnline)
	if !ok {
		that2, ok := that.(UpdateGroupOnline)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *RequestTyping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.RequestTyping{")
	if this.Peer != nil {
		s = append(s, "Peer: "+fmt.Sprintf("%#v", this.Peer)+",\n")
	}
	s = append(s, "TypingType: "+fmt.Sprintf("%#v", this.TypingType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestStopTyping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.RequestStopTyping{")
	if this.Peer != nil {
		s = append(s, "Peer: "+fmt.Sprintf("%#v", this.Peer)+",\n")
	}
	s = append(s, "TypingType: "+fmt.Sprintf("%#v", this.TypingType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestSetOnline) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.RequestSetOnline{")
	s = append(s, "IsOnline: "+fmt.Sprintf("%#v", this.IsOnline)+",\n")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "DeviceType: "+fmt.Sprintf("%#v", this.DeviceType)+",\n")
	if this.DeviceCategory != nil {
		s = append(s, "DeviceCategory: "+fmt.Sprintf("%#v", this.DeviceCategory)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdatePauseNotifications) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.UpdatePauseNotifications{")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateRestoreNotifications) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&dialog.UpdateRestoreNotifications{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestPauseNotifications) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestPauseNotifications{")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestRestoreNotifications) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&dialog.RequestRestoreNotifications{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateTyping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.UpdateTyping{")
	if this.Peer != nil {
		s = append(s, "Peer: "+fmt.Sprintf("%#v", this.Peer)+",\n")
	}
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "TypingType: "+fmt.Sprintf("%#v", this.TypingType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateTypingStop) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.UpdateTypingStop{")
	if this.Peer != nil {
		s = append(s, "Peer: "+fmt.Sprintf("%#v", this.Peer)+",\n")
	}
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "TypingType: "+fmt.Sprintf("%#v", this.TypingType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateUserOnline) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.UpdateUserOnline{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "DeviceType: "+fmt.Sprintf("%#v", this.DeviceType)+",\n")
	if this.DeviceCategory != nil {
		s = append(s, "DeviceCategory: "+fmt.Sprintf("%#v", this.DeviceCategory)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateUserOffline) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.UpdateUserOffline{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "DeviceType: "+fmt.Sprintf("%#v", this.DeviceType)+",\n")
	if this.DeviceCategory != nil {
		s = append(s, "DeviceCategory: "+fmt.Sprintf("%#v", this.DeviceCategory)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateUserLastSeen) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.UpdateUserLastSeen{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "DeviceType: "+fmt.Sprintf("%#v", this.DeviceType)+",\n")
	if this.DeviceCategory != nil {
		s = append(s, "DeviceCategory: "+fmt.Sprintf("%#v", this.DeviceCategory)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupOnline) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.UpdateGroupOnline{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypingAndOnline(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TypingAndOnline service

type TypingAndOnlineClient interface {
	Typing(ctx context.Context, in *RequestTyping, opts ...grpc.CallOption) (*ResponseVoid, error)
	StopTyping(ctx context.Context, in *RequestStopTyping, opts ...grpc.CallOption) (*ResponseVoid, error)
	SetOnline(ctx context.Context, in *RequestSetOnline, opts ...grpc.CallOption) (*ResponseVoid, error)
	PauseNotifications(ctx context.Context, in *RequestPauseNotifications, opts ...grpc.CallOption) (*ResponseVoid, error)
	RestoreNotifications(ctx context.Context, in *RequestRestoreNotifications, opts ...grpc.CallOption) (*ResponseVoid, error)
}

type typingAndOnlineClient struct {
	cc *grpc.ClientConn
}

func NewTypingAndOnlineClient(cc *grpc.ClientConn) TypingAndOnlineClient {
	return &typingAndOnlineClient{cc}
}

func (c *typingAndOnlineClient) Typing(ctx context.Context, in *RequestTyping, opts ...grpc.CallOption) (*ResponseVoid, error) {
	out := new(ResponseVoid)
	err := grpc.Invoke(ctx, "/dialog.TypingAndOnline/Typing", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *typingAndOnlineClient) StopTyping(ctx context.Context, in *RequestStopTyping, opts ...grpc.CallOption) (*ResponseVoid, error) {
	out := new(ResponseVoid)
	err := grpc.Invoke(ctx, "/dialog.TypingAndOnline/StopTyping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *typingAndOnlineClient) SetOnline(ctx context.Context, in *RequestSetOnline, opts ...grpc.CallOption) (*ResponseVoid, error) {
	out := new(ResponseVoid)
	err := grpc.Invoke(ctx, "/dialog.TypingAndOnline/SetOnline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *typingAndOnlineClient) PauseNotifications(ctx context.Context, in *RequestPauseNotifications, opts ...grpc.CallOption) (*ResponseVoid, error) {
	out := new(ResponseVoid)
	err := grpc.Invoke(ctx, "/dialog.TypingAndOnline/PauseNotifications", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *typingAndOnlineClient) RestoreNotifications(ctx context.Context, in *RequestRestoreNotifications, opts ...grpc.CallOption) (*ResponseVoid, error) {
	out := new(ResponseVoid)
	err := grpc.Invoke(ctx, "/dialog.TypingAndOnline/RestoreNotifications", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TypingAndOnline service

type TypingAndOnlineServer interface {
	Typing(context.Context, *RequestTyping) (*ResponseVoid, error)
	StopTyping(context.Context, *RequestStopTyping) (*ResponseVoid, error)
	SetOnline(context.Context, *RequestSetOnline) (*ResponseVoid, error)
	PauseNotifications(context.Context, *RequestPauseNotifications) (*ResponseVoid, error)
	RestoreNotifications(context.Context, *RequestRestoreNotifications) (*ResponseVoid, error)
}

func RegisterTypingAndOnlineServer(s *grpc.Server, srv TypingAndOnlineServer) {
	s.RegisterService(&_TypingAndOnline_serviceDesc, srv)
}

func _TypingAndOnline_Typing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestTyping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TypingAndOnlineServer).Typing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.TypingAndOnline/Typing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TypingAndOnlineServer).Typing(ctx, req.(*RequestTyping))
	}
	return interceptor(ctx, in, info, handler)
}

func _TypingAndOnline_StopTyping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestStopTyping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TypingAndOnlineServer).StopTyping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.TypingAndOnline/StopTyping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TypingAndOnlineServer).StopTyping(ctx, req.(*RequestStopTyping))
	}
	return interceptor(ctx, in, info, handler)
}

func _TypingAndOnline_SetOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestSetOnline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TypingAndOnlineServer).SetOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.TypingAndOnline/SetOnline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TypingAndOnlineServer).SetOnline(ctx, req.(*RequestSetOnline))
	}
	return interceptor(ctx, in, info, handler)
}

func _TypingAndOnline_PauseNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestPauseNotifications)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TypingAndOnlineServer).PauseNotifications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.TypingAndOnline/PauseNotifications",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TypingAndOnlineServer).PauseNotifications(ctx, req.(*RequestPauseNotifications))
	}
	return interceptor(ctx, in, info, handler)
}

func _TypingAndOnline_RestoreNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestRestoreNotifications)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TypingAndOnlineServer).RestoreNotifications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.TypingAndOnline/RestoreNotifications",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TypingAndOnlineServer).RestoreNotifications(ctx, req.(*RequestRestoreNotifications))
	}
	return interceptor(ctx, in, info, handler)
}

var _TypingAndOnline_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dialog.TypingAndOnline",
	HandlerType: (*TypingAndOnlineServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Typing",
			Handler:    _TypingAndOnline_Typing_Handler,
		},
		{
			MethodName: "StopTyping",
			Handler:    _TypingAndOnline_StopTyping_Handler,
		},
		{
			MethodName: "SetOnline",
			Handler:    _TypingAndOnline_SetOnline_Handler,
		},
		{
			MethodName: "PauseNotifications",
			Handler:    _TypingAndOnline_PauseNotifications_Handler,
		},
		{
			MethodName: "RestoreNotifications",
			Handler:    _TypingAndOnline_RestoreNotifications_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "typing_and_online.proto",
}

func (m *RequestTyping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestTyping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Peer.Size()))
		n1, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.TypingType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.TypingType))
	}
	return i, nil
}

func (m *RequestStopTyping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestStopTyping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Peer.Size()))
		n2, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.TypingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.TypingType))
	}
	return i, nil
}

func (m *RequestSetOnline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestSetOnline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsOnline {
		dAtA[i] = 0x8
		i++
		if m.IsOnline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Timeout))
	}
	if m.DeviceType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.DeviceType))
	}
	if m.DeviceCategory != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.DeviceCategory.Size()))
		n3, err := m.DeviceCategory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *UpdatePauseNotifications) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePauseNotifications) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Timeout))
	}
	return i, nil
}

func (m *UpdateRestoreNotifications) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateRestoreNotifications) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RequestPauseNotifications) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestPauseNotifications) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Timeout))
	}
	return i, nil
}

func (m *RequestRestoreNotifications) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestRestoreNotifications) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UpdateTyping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTyping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Peer.Size()))
		n4, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Uid))
	}
	if m.TypingType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.TypingType))
	}
	return i, nil
}

func (m *UpdateTypingStop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTypingStop) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Peer.Size()))
		n5, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Uid))
	}
	if m.TypingType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.TypingType))
	}
	return i, nil
}

func (m *UpdateUserOnline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserOnline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Uid))
	}
	if m.DeviceType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.DeviceType))
	}
	if m.DeviceCategory != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.DeviceCategory.Size()))
		n6, err := m.DeviceCategory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *UpdateUserOffline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserOffline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Uid))
	}
	if m.DeviceType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.DeviceType))
	}
	if m.DeviceCategory != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.DeviceCategory.Size()))
		n7, err := m.DeviceCategory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *UpdateUserLastSeen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserLastSeen) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Uid))
	}
	if m.Date != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Date))
	}
	if m.DeviceType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.DeviceType))
	}
	if m.DeviceCategory != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.DeviceCategory.Size()))
		n8, err := m.DeviceCategory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *UpdateGroupOnline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupOnline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.GroupId))
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypingAndOnline(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func encodeFixed64TypingAndOnline(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32TypingAndOnline(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTypingAndOnline(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RequestTyping) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovTypingAndOnline(uint64(l))
	}
	if m.TypingType != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.TypingType))
	}
	return n
}

func (m *RequestStopTyping) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovTypingAndOnline(uint64(l))
	}
	if m.TypingType != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.TypingType))
	}
	return n
}

func (m *RequestSetOnline) Size() (n int) {
	var l int
	_ = l
	if m.IsOnline {
		n += 2
	}
	if m.Timeout != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.Timeout))
	}
	if m.DeviceType != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.DeviceType))
	}
	if m.DeviceCategory != nil {
		l = m.DeviceCategory.Size()
		n += 1 + l + sovTypingAndOnline(uint64(l))
	}
	return n
}

func (m *UpdatePauseNotifications) Size() (n int) {
	var l int
	_ = l
	if m.Timeout != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.Timeout))
	}
	return n
}

func (m *UpdateRestoreNotifications) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RequestPauseNotifications) Size() (n int) {
	var l int
	_ = l
	if m.Timeout != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.Timeout))
	}
	return n
}

func (m *RequestRestoreNotifications) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UpdateTyping) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovTypingAndOnline(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.Uid))
	}
	if m.TypingType != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.TypingType))
	}
	return n
}

func (m *UpdateTypingStop) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovTypingAndOnline(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.Uid))
	}
	if m.TypingType != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.TypingType))
	}
	return n
}

func (m *UpdateUserOnline) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.Uid))
	}
	if m.DeviceType != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.DeviceType))
	}
	if m.DeviceCategory != nil {
		l = m.DeviceCategory.Size()
		n += 1 + l + sovTypingAndOnline(uint64(l))
	}
	return n
}

func (m *UpdateUserOffline) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.Uid))
	}
	if m.DeviceType != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.DeviceType))
	}
	if m.DeviceCategory != nil {
		l = m.DeviceCategory.Size()
		n += 1 + l + sovTypingAndOnline(uint64(l))
	}
	return n
}

func (m *UpdateUserLastSeen) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.Uid))
	}
	if m.Date != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.Date))
	}
	if m.DeviceType != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.DeviceType))
	}
	if m.DeviceCategory != nil {
		l = m.DeviceCategory.Size()
		n += 1 + l + sovTypingAndOnline(uint64(l))
	}
	return n
}

func (m *UpdateGroupOnline) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.GroupId))
	}
	if m.Count != 0 {
		n += 1 + sovTypingAndOnline(uint64(m.Count))
	}
	return n
}

func sovTypingAndOnline(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypingAndOnline(x uint64) (n int) {
	return sovTypingAndOnline(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *RequestTyping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestTyping{`,
		`Peer:` + strings.Replace(fmt.Sprintf("%v", this.Peer), "OutPeer", "OutPeer", 1) + `,`,
		`TypingType:` + fmt.Sprintf("%v", this.TypingType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestStopTyping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestStopTyping{`,
		`Peer:` + strings.Replace(fmt.Sprintf("%v", this.Peer), "OutPeer", "OutPeer", 1) + `,`,
		`TypingType:` + fmt.Sprintf("%v", this.TypingType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestSetOnline) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestSetOnline{`,
		`IsOnline:` + fmt.Sprintf("%v", this.IsOnline) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`DeviceType:` + fmt.Sprintf("%v", this.DeviceType) + `,`,
		`DeviceCategory:` + strings.Replace(fmt.Sprintf("%v", this.DeviceCategory), "StringValue", "google_protobuf.StringValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdatePauseNotifications) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdatePauseNotifications{`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateRestoreNotifications) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateRestoreNotifications{`,
		`}`,
	}, "")
	return s
}
func (this *RequestPauseNotifications) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestPauseNotifications{`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestRestoreNotifications) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestRestoreNotifications{`,
		`}`,
	}, "")
	return s
}
func (this *UpdateTyping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateTyping{`,
		`Peer:` + strings.Replace(fmt.Sprintf("%v", this.Peer), "Peer", "Peer", 1) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`TypingType:` + fmt.Sprintf("%v", this.TypingType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateTypingStop) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateTypingStop{`,
		`Peer:` + strings.Replace(fmt.Sprintf("%v", this.Peer), "Peer", "Peer", 1) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`TypingType:` + fmt.Sprintf("%v", this.TypingType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateUserOnline) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateUserOnline{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`DeviceType:` + fmt.Sprintf("%v", this.DeviceType) + `,`,
		`DeviceCategory:` + strings.Replace(fmt.Sprintf("%v", this.DeviceCategory), "StringValue", "google_protobuf.StringValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateUserOffline) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateUserOffline{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`DeviceType:` + fmt.Sprintf("%v", this.DeviceType) + `,`,
		`DeviceCategory:` + strings.Replace(fmt.Sprintf("%v", this.DeviceCategory), "StringValue", "google_protobuf.StringValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateUserLastSeen) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateUserLastSeen{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`DeviceType:` + fmt.Sprintf("%v", this.DeviceType) + `,`,
		`DeviceCategory:` + strings.Replace(fmt.Sprintf("%v", this.DeviceCategory), "StringValue", "google_protobuf.StringValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupOnline) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupOnline{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypingAndOnline(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *RequestTyping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestTyping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestTyping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &OutPeer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypingType", wireType)
			}
			m.TypingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypingType |= (TypingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypingAndOnline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestStopTyping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestStopTyping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestStopTyping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &OutPeer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypingType", wireType)
			}
			m.TypingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypingType |= (TypingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypingAndOnline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestSetOnline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestSetOnline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestSetOnline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOnline = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			m.DeviceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceType |= (DeviceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceCategory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceCategory == nil {
				m.DeviceCategory = &google_protobuf.StringValue{}
			}
			if err := m.DeviceCategory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypingAndOnline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePauseNotifications) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePauseNotifications: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePauseNotifications: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypingAndOnline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateRestoreNotifications) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateRestoreNotifications: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateRestoreNotifications: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypingAndOnline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestPauseNotifications) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestPauseNotifications: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestPauseNotifications: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypingAndOnline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestRestoreNotifications) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestRestoreNotifications: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestRestoreNotifications: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypingAndOnline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTyping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTyping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTyping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypingType", wireType)
			}
			m.TypingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypingType |= (TypingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypingAndOnline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTypingStop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTypingStop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTypingStop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypingType", wireType)
			}
			m.TypingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypingType |= (TypingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypingAndOnline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserOnline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserOnline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserOnline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			m.DeviceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceType |= (DeviceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceCategory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceCategory == nil {
				m.DeviceCategory = &google_protobuf.StringValue{}
			}
			if err := m.DeviceCategory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypingAndOnline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserOffline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserOffline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserOffline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			m.DeviceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceType |= (DeviceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceCategory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceCategory == nil {
				m.DeviceCategory = &google_protobuf.StringValue{}
			}
			if err := m.DeviceCategory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypingAndOnline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserLastSeen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserLastSeen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserLastSeen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			m.DeviceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceType |= (DeviceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceCategory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceCategory == nil {
				m.DeviceCategory = &google_protobuf.StringValue{}
			}
			if err := m.DeviceCategory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypingAndOnline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupOnline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupOnline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupOnline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypingAndOnline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypingAndOnline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypingAndOnline(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypingAndOnline
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypingAndOnline
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypingAndOnline
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypingAndOnline
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypingAndOnline(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypingAndOnline = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypingAndOnline   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("typing_and_online.proto", fileDescriptorTypingAndOnline) }

var fileDescriptorTypingAndOnline = []byte{
	// 990 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xcc, 0x56, 0xcf, 0x6f, 0xe3, 0xc4,
	0x17, 0xcf, 0x24, 0x69, 0x9a, 0xbe, 0xfe, 0x72, 0x66, 0xdb, 0xdd, 0xb4, 0xdf, 0xca, 0xbb, 0xeb,
	0x7e, 0xc5, 0x56, 0x41, 0xeb, 0x94, 0xac, 0x84, 0x60, 0x39, 0xac, 0x92, 0xac, 0x55, 0x22, 0x4a,
	0x12, 0x65, 0xdd, 0x2e, 0x7b, 0xaa, 0x9c, 0x78, 0x12, 0x06, 0xa5, 0xb6, 0xf1, 0x8f, 0xa2, 0xde,
	0x10, 0x12, 0x97, 0xe5, 0x82, 0xc4, 0x1f, 0xc0, 0x05, 0x04, 0x9c, 0xe0, 0xcf, 0xe0, 0xb8, 0x12,
	0x7b, 0xe0, 0x48, 0x0d, 0x48, 0x68, 0x4f, 0xfb, 0x27, 0x20, 0xdb, 0xe3, 0xc6, 0x71, 0x6c, 0x05,
	0xad, 0x8a, 0xc4, 0x29, 0xf1, 0x7b, 0xf3, 0x3e, 0x9f, 0xcf, 0x7b, 0xf3, 0xde, 0xcc, 0xc0, 0x0d,
	0xfb, 0xdc, 0xa0, 0xda, 0xe8, 0x44, 0xd1, 0xd4, 0x13, 0x5d, 0x1b, 0x53, 0x8d, 0x88, 0x86, 0xa9,
	0xdb, 0x3a, 0x2e, 0xa8, 0x54, 0x19, 0xeb, 0xa3, 0x6d, 0x7e, 0xa4, 0xeb, 0xa3, 0x31, 0xa9, 0xfa,
	0xd6, 0xbe, 0x33, 0xac, 0x7e, 0x62, 0x2a, 0x86, 0x41, 0x4c, 0x2b, 0x58, 0xb7, 0xbd, 0xc3, 0xfc,
	0x8a, 0x41, 0xab, 0x8a, 0xa6, 0xe9, 0xb6, 0x62, 0x53, 0x5d, 0x0b, 0xbd, 0x25, 0x95, 0x0c, 0xa9,
	0x46, 0xa3, 0xa6, 0x6b, 0xa7, 0xd4, 0x1a, 0x90, 0xf1, 0x58, 0xd1, 0x88, 0xee, 0x84, 0xc6, 0x65,
	0x83, 0x4c, 0x20, 0x37, 0xad, 0x81, 0x32, 0x56, 0x8c, 0x7e, 0x95, 0xfd, 0x06, 0x66, 0xe1, 0x5b,
	0x04, 0xab, 0x3d, 0xf2, 0xb1, 0x43, 0x2c, 0x5b, 0xf6, 0x45, 0xe3, 0x1a, 0xe4, 0xbd, 0xb8, 0x32,
	0xba, 0x85, 0xf6, 0x96, 0x6b, 0xeb, 0x62, 0x20, 0x59, 0xec, 0x38, 0x76, 0x97, 0x10, 0xb3, 0xb1,
	0xfa, 0xf4, 0xc5, 0xfe, 0x12, 0x2c, 0x9e, 0x51, 0x8b, 0xf6, 0xc7, 0xa4, 0xe7, 0xaf, 0xc5, 0x0d,
	0x58, 0x66, 0x29, 0xdb, 0xe7, 0x06, 0x29, 0xe7, 0x6e, 0xa1, 0xbd, 0xb5, 0x1a, 0x0e, 0x43, 0x03,
	0x60, 0xf9, 0xdc, 0x20, 0xf1, 0x68, 0xb0, 0x2f, 0x5d, 0xf7, 0x77, 0xdc, 0x07, 0x5b, 0x70, 0x83,
	0x9e, 0x8a, 0xea, 0x78, 0x24, 0x8e, 0x4c, 0x63, 0x20, 0x1e, 0x98, 0xc6, 0x80, 0x69, 0x13, 0x7e,
	0x40, 0x50, 0x62, 0xff, 0x1f, 0xd9, 0xba, 0x71, 0x75, 0x5a, 0xb3, 0x57, 0xaf, 0xf5, 0xeb, 0x2c,
	0x70, 0xa1, 0x56, 0x62, 0x77, 0xfc, 0x06, 0xc0, 0x15, 0x58, 0xa2, 0x16, 0xeb, 0x06, 0x5f, 0x6f,
	0x31, 0x4e, 0x50, 0xa4, 0x16, 0x5b, 0x7b, 0x07, 0x16, 0x6d, 0x7a, 0x4a, 0x74, 0xc7, 0xf6, 0xe5,
	0xe5, 0xe2, 0x2b, 0x43, 0xaf, 0x97, 0x8b, 0x4a, 0xce, 0xe8, 0x80, 0x24, 0xd6, 0xfd, 0xa1, 0xef,
	0x4a, 0xcc, 0x45, 0xbd, 0x74, 0x61, 0x19, 0xd6, 0x19, 0xc6, 0x40, 0xb1, 0xc9, 0x48, 0x37, 0xcf,
	0xcb, 0x79, 0xbf, 0x9c, 0x3b, 0x62, 0xd0, 0x85, 0x62, 0xd8, 0xa5, 0xe2, 0x23, 0xdb, 0xa4, 0xda,
	0xe8, 0x58, 0x19, 0x3b, 0x33, 0x88, 0x6b, 0x01, 0x46, 0x93, 0x41, 0xcc, 0xa9, 0x50, 0x13, 0xca,
	0x47, 0x86, 0xaa, 0xd8, 0xa4, 0xab, 0x38, 0x16, 0x69, 0xeb, 0x36, 0x1d, 0xd2, 0x41, 0xd0, 0xe3,
	0xd1, 0xe4, 0xbd, 0x32, 0x2d, 0xa4, 0x25, 0x2f, 0xec, 0xc0, 0x76, 0x00, 0xd2, 0x23, 0x96, 0xad,
	0x9b, 0xd3, 0x30, 0x82, 0x02, 0x5b, 0x8c, 0x2d, 0x81, 0xe3, 0xb5, 0x38, 0xc7, 0xca, 0xd3, 0x17,
	0xfb, 0x45, 0x28, 0x7c, 0x48, 0x55, 0x95, 0x68, 0x97, 0x14, 0x73, 0xb2, 0x78, 0x07, 0xfe, 0xc7,
	0xfe, 0x26, 0x29, 0x98, 0x13, 0xfc, 0x0d, 0x82, 0x95, 0x40, 0x3e, 0xeb, 0xe5, 0xea, 0x54, 0x2f,
	0xaf, 0x84, 0x9b, 0x98, 0xde, 0xc8, 0x37, 0x21, 0xe7, 0x50, 0xd5, 0xef, 0x90, 0x99, 0x22, 0x79,
	0x9e, 0xab, 0x98, 0x4a, 0xe1, 0x3b, 0x04, 0x5c, 0x54, 0xa6, 0x37, 0x7c, 0xff, 0x82, 0xd4, 0xfa,
	0x3f, 0x95, 0x3a, 0xbd, 0x51, 0x51, 0xa5, 0x3f, 0x5e, 0x2a, 0x3d, 0xb2, 0x88, 0xc9, 0x26, 0x89,
	0x11, 0xa3, 0x54, 0xe2, 0x7b, 0xd3, 0x13, 0x94, 0x4d, 0x9b, 0xa0, 0xa9, 0x91, 0x91, 0x66, 0x47,
	0x26, 0x37, 0x7f, 0x64, 0xe2, 0x33, 0x22, 0xfc, 0x84, 0xa0, 0x14, 0x51, 0x3c, 0x1c, 0xfe, 0xf7,
	0x25, 0x3f, 0x47, 0x80, 0x27, 0x92, 0x0f, 0x15, 0xef, 0x84, 0x23, 0xda, 0x7c, 0xcd, 0xb7, 0x21,
	0xef, 0x05, 0x25, 0x1f, 0x67, 0xbe, 0x2b, 0x9e, 0x56, 0xee, 0x55, 0xd3, 0xca, 0xbf, 0x42, 0x5a,
	0xfd, 0x70, 0x23, 0x0e, 0x4c, 0xdd, 0x31, 0x58, 0xef, 0xec, 0x41, 0x71, 0xe4, 0x7d, 0x9e, 0xa4,
	0x65, 0xb6, 0xe8, 0xbb, 0x5b, 0x2a, 0xde, 0x85, 0x85, 0x81, 0xee, 0x68, 0x76, 0x72, 0x83, 0x07,
	0xbe, 0xca, 0xdb, 0x00, 0x93, 0x3e, 0xc6, 0xd7, 0x01, 0xcb, 0x4f, 0xba, 0xad, 0xf6, 0x81, 0xfc,
	0xa4, 0x2b, 0x9d, 0x1c, 0xb5, 0xdf, 0x6b, 0x77, 0x1e, 0xb7, 0xb9, 0x0c, 0xbe, 0x06, 0xeb, 0x11,
	0xbb, 0x2c, 0x7d, 0x20, 0x73, 0xa8, 0xf2, 0x1c, 0x01, 0x4c, 0x0a, 0xe0, 0xc5, 0x3e, 0x94, 0x8e,
	0x5b, 0x4d, 0x29, 0x16, 0x3b, 0x6d, 0x3f, 0x90, 0xda, 0x52, 0xaf, 0xd5, 0xe4, 0x10, 0x2e, 0xc1,
	0x6a, 0xc4, 0xde, 0x6d, 0x72, 0x59, 0xbc, 0x09, 0xa5, 0x88, 0xe9, 0xfd, 0x4e, 0xa3, 0x75, 0x28,
	0x71, 0xb9, 0x98, 0x59, 0xae, 0x37, 0x0e, 0x25, 0x99, 0xcb, 0xe3, 0x0d, 0xe0, 0x22, 0xe6, 0xc7,
	0x75, 0xb9, 0xf9, 0x2e, 0xb7, 0x10, 0xc7, 0x68, 0xf5, 0x7a, 0x9d, 0x1e, 0x57, 0xc0, 0x18, 0xd6,
	0x22, 0xe6, 0x66, 0xbd, 0xc7, 0x2d, 0xc6, 0x00, 0x7c, 0x5c, 0xae, 0x58, 0xfb, 0x33, 0x0f, 0xeb,
	0x41, 0x49, 0xea, 0x9a, 0xca, 0x8a, 0xae, 0x40, 0x81, 0x9d, 0x87, 0x9b, 0xe1, 0xd6, 0x4f, 0x3d,
	0x4f, 0xb6, 0x37, 0x26, 0x66, 0xcb, 0xd0, 0x35, 0x8b, 0x1c, 0xeb, 0x54, 0x15, 0x2a, 0x9f, 0xfd,
	0xf2, 0xc7, 0x57, 0xd9, 0xff, 0x0b, 0x37, 0xab, 0x67, 0x6f, 0x54, 0xbd, 0xb3, 0xb6, 0x1a, 0x03,
	0x66, 0xdf, 0xf7, 0x51, 0x05, 0x9f, 0x02, 0x44, 0x9e, 0x10, 0x5b, 0x31, 0x9a, 0x89, 0x2b, 0x85,
	0x4a, 0xf4, 0xa9, 0xf6, 0x84, 0xdd, 0x54, 0xaa, 0x09, 0x84, 0x47, 0xf7, 0x11, 0x2c, 0x4d, 0x5e,
	0x01, 0xe5, 0x38, 0x5b, 0xe8, 0x49, 0x21, 0xbb, 0xeb, 0x93, 0xdd, 0x11, 0x84, 0x74, 0xb2, 0x10,
	0xc1, 0xe3, 0xfa, 0x1c, 0x01, 0x4e, 0xb8, 0xee, 0x6e, 0xc7, 0x58, 0x67, 0x97, 0xa4, 0xd0, 0xbf,
	0xe9, 0xd3, 0xef, 0x0b, 0xaf, 0xa7, 0xd2, 0xcf, 0x42, 0x79, 0x3a, 0xbe, 0x40, 0xb0, 0x91, 0x74,
	0x27, 0xe2, 0xdd, 0x98, 0x92, 0xa4, 0x45, 0x29, 0x5a, 0xde, 0xf2, 0xb5, 0xd4, 0x84, 0xbb, 0xa9,
	0x5a, 0x12, 0x6f, 0x61, 0x54, 0x69, 0x48, 0xee, 0x83, 0xeb, 0xb0, 0x11, 0xbd, 0x88, 0x2d, 0x62,
	0x7a, 0xd3, 0x64, 0x3d, 0xbb, 0xe0, 0x33, 0xbf, 0x5e, 0xf0, 0x99, 0x97, 0x17, 0x3c, 0xfa, 0xd4,
	0xe5, 0xd1, 0xf7, 0x2e, 0x8f, 0x7e, 0x76, 0x79, 0xf4, 0xcc, 0xe5, 0xd1, 0x6f, 0x2e, 0x8f, 0xfe,
	0x72, 0xf9, 0xcc, 0x4b, 0x97, 0x47, 0x5f, 0xfe, 0xce, 0x67, 0xfa, 0x05, 0xff, 0x28, 0xb9, 0xf7,
	0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf9, 0x16, 0x2c, 0x5d, 0xde, 0x0b, 0x00, 0x00,
}
