// Code generated by protoc-gen-gogo.
// source: stickers.proto
// DO NOT EDIT!

package dialog

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/wrappers"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/gogo/protobuf/types"

import bytes "bytes"

import strings "strings"
import reflect "reflect"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Descriptor of a Sticker
type StickerDescriptor struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// / Emoji code for sticker
	Emoji *google_protobuf.StringValue `protobuf:"bytes,2,opt,name=emoji" json:"emoji,omitempty"`
	// / Image of sticker 128x128 in WebP format
	Image_128 *ImageLocation `protobuf:"bytes,3,opt,name=image_128,json=image128" json:"image_128,omitempty"`
	// / Image of sticker 512x512 in WebP format
	Image_512 *ImageLocation `protobuf:"bytes,4,opt,name=image_512,json=image512" json:"image_512,omitempty"`
	// / Image of sticker 256x256 in WebP format
	Image_256 *ImageLocation `protobuf:"bytes,5,opt,name=image_256,json=image256" json:"image_256,omitempty"`
}

func (m *StickerDescriptor) Reset()                    { *m = StickerDescriptor{} }
func (*StickerDescriptor) ProtoMessage()               {}
func (*StickerDescriptor) Descriptor() ([]byte, []int) { return fileDescriptorStickers, []int{0} }

func (m *StickerDescriptor) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StickerDescriptor) GetEmoji() *google_protobuf.StringValue {
	if m != nil {
		return m.Emoji
	}
	return nil
}

func (m *StickerDescriptor) GetImage_128() *ImageLocation {
	if m != nil {
		return m.Image_128
	}
	return nil
}

func (m *StickerDescriptor) GetImage_512() *ImageLocation {
	if m != nil {
		return m.Image_512
	}
	return nil
}

func (m *StickerDescriptor) GetImage_256() *ImageLocation {
	if m != nil {
		return m.Image_256
	}
	return nil
}

// Sticker collection
type StickerCollection struct {
	// / Unique id of a collection
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// / Sticker pack title
	Title    *google_protobuf.StringValue `protobuf:"bytes,2,opt,name=title" json:"title,omitempty"`
	Stickers []*StickerDescriptor         `protobuf:"bytes,3,rep,name=stickers" json:"stickers,omitempty"`
	// / does this pack belongs to current user
	OwnedByMe *google_protobuf.BoolValue `protobuf:"bytes,4,opt,name=owned_by_me,json=ownedByMe" json:"owned_by_me,omitempty"`
}

func (m *StickerCollection) Reset()                    { *m = StickerCollection{} }
func (*StickerCollection) ProtoMessage()               {}
func (*StickerCollection) Descriptor() ([]byte, []int) { return fileDescriptorStickers, []int{1} }

func (m *StickerCollection) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StickerCollection) GetTitle() *google_protobuf.StringValue {
	if m != nil {
		return m.Title
	}
	return nil
}

func (m *StickerCollection) GetStickers() []*StickerDescriptor {
	if m != nil {
		return m.Stickers
	}
	return nil
}

func (m *StickerCollection) GetOwnedByMe() *google_protobuf.BoolValue {
	if m != nil {
		return m.OwnedByMe
	}
	return nil
}

// Stickers response
type ResponseStickersResponse struct {
	Collections []*StickerCollection `protobuf:"bytes,1,rep,name=collections" json:"collections,omitempty"`
	Seq         int32                `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	State       []byte               `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *ResponseStickersResponse) Reset()                    { *m = ResponseStickersResponse{} }
func (*ResponseStickersResponse) ProtoMessage()               {}
func (*ResponseStickersResponse) Descriptor() ([]byte, []int) { return fileDescriptorStickers, []int{2} }

func (m *ResponseStickersResponse) GetCollections() []*StickerCollection {
	if m != nil {
		return m.Collections
	}
	return nil
}

func (m *ResponseStickersResponse) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ResponseStickersResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

// Loading own stickers
type RequestLoadOwnStickers struct {
}

func (m *RequestLoadOwnStickers) Reset()                    { *m = RequestLoadOwnStickers{} }
func (*RequestLoadOwnStickers) ProtoMessage()               {}
func (*RequestLoadOwnStickers) Descriptor() ([]byte, []int) { return fileDescriptorStickers, []int{3} }

type ResponseLoadOwnStickers struct {
	OwnStickers []*StickerCollection `protobuf:"bytes,1,rep,name=own_stickers,json=ownStickers" json:"own_stickers,omitempty"`
}

func (m *ResponseLoadOwnStickers) Reset()                    { *m = ResponseLoadOwnStickers{} }
func (*ResponseLoadOwnStickers) ProtoMessage()               {}
func (*ResponseLoadOwnStickers) Descriptor() ([]byte, []int) { return fileDescriptorStickers, []int{4} }

func (m *ResponseLoadOwnStickers) GetOwnStickers() []*StickerCollection {
	if m != nil {
		return m.OwnStickers
	}
	return nil
}

// Load accessible stickers
type RequestLoadAcesssibleStickers struct {
}

func (m *RequestLoadAcesssibleStickers) Reset()      { *m = RequestLoadAcesssibleStickers{} }
func (*RequestLoadAcesssibleStickers) ProtoMessage() {}
func (*RequestLoadAcesssibleStickers) Descriptor() ([]byte, []int) {
	return fileDescriptorStickers, []int{5}
}

type ResponseLoadAcesssibleStickers struct {
	AccessibleStickers []*StickerCollection `protobuf:"bytes,1,rep,name=accessible_stickers,json=accessibleStickers" json:"accessible_stickers,omitempty"`
}

func (m *ResponseLoadAcesssibleStickers) Reset()      { *m = ResponseLoadAcesssibleStickers{} }
func (*ResponseLoadAcesssibleStickers) ProtoMessage() {}
func (*ResponseLoadAcesssibleStickers) Descriptor() ([]byte, []int) {
	return fileDescriptorStickers, []int{6}
}

func (m *ResponseLoadAcesssibleStickers) GetAccessibleStickers() []*StickerCollection {
	if m != nil {
		return m.AccessibleStickers
	}
	return nil
}

// Add a reference to other user's sticker pack
type RequestAddStickerPackReference struct {
	SourceStickerPack int32 `protobuf:"varint,1,opt,name=source_sticker_pack,json=sourceStickerPack,proto3" json:"source_sticker_pack,omitempty"`
}

func (m *RequestAddStickerPackReference) Reset()      { *m = RequestAddStickerPackReference{} }
func (*RequestAddStickerPackReference) ProtoMessage() {}
func (*RequestAddStickerPackReference) Descriptor() ([]byte, []int) {
	return fileDescriptorStickers, []int{7}
}

func (m *RequestAddStickerPackReference) GetSourceStickerPack() int32 {
	if m != nil {
		return m.SourceStickerPack
	}
	return 0
}

// Remove a reference to an other user's sticker pack
type RequestRemoveStickerPackReference struct {
	SourceStickerPack int32 `protobuf:"varint,1,opt,name=source_sticker_pack,json=sourceStickerPack,proto3" json:"source_sticker_pack,omitempty"`
}

func (m *RequestRemoveStickerPackReference) Reset()      { *m = RequestRemoveStickerPackReference{} }
func (*RequestRemoveStickerPackReference) ProtoMessage() {}
func (*RequestRemoveStickerPackReference) Descriptor() ([]byte, []int) {
	return fileDescriptorStickers, []int{8}
}

func (m *RequestRemoveStickerPackReference) GetSourceStickerPack() int32 {
	if m != nil {
		return m.SourceStickerPack
	}
	return 0
}

// Sticker collection changed
type UpdateStickerCollectionsChanged struct {
	UpdatedCollections []*StickerCollection `protobuf:"bytes,1,rep,name=updated_collections,json=updatedCollections" json:"updated_collections,omitempty"`
}

func (m *UpdateStickerCollectionsChanged) Reset()      { *m = UpdateStickerCollectionsChanged{} }
func (*UpdateStickerCollectionsChanged) ProtoMessage() {}
func (*UpdateStickerCollectionsChanged) Descriptor() ([]byte, []int) {
	return fileDescriptorStickers, []int{9}
}

func (m *UpdateStickerCollectionsChanged) GetUpdatedCollections() []*StickerCollection {
	if m != nil {
		return m.UpdatedCollections
	}
	return nil
}

// Sticker pack removed
type UpdateStickerPackRemoved struct {
	PackId int32 `protobuf:"varint,1,opt,name=pack_id,json=packId,proto3" json:"pack_id,omitempty"`
}

func (m *UpdateStickerPackRemoved) Reset()      { *m = UpdateStickerPackRemoved{} }
func (*UpdateStickerPackRemoved) ProtoMessage() {}
func (*UpdateStickerPackRemoved) Descriptor() ([]byte, []int) {
	return fileDescriptorStickers, []int{10}
}

func (m *UpdateStickerPackRemoved) GetPackId() int32 {
	if m != nil {
		return m.PackId
	}
	return 0
}

// Sticker pack was added
type UpdateStickerPackAdded struct {
	Pack *StickerCollection `protobuf:"bytes,1,opt,name=pack" json:"pack,omitempty"`
}

func (m *UpdateStickerPackAdded) Reset()                    { *m = UpdateStickerPackAdded{} }
func (*UpdateStickerPackAdded) ProtoMessage()               {}
func (*UpdateStickerPackAdded) Descriptor() ([]byte, []int) { return fileDescriptorStickers, []int{11} }

func (m *UpdateStickerPackAdded) GetPack() *StickerCollection {
	if m != nil {
		return m.Pack
	}
	return nil
}

// Adding sticker collection
type RequestAddStickerCollection struct {
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
}

func (m *RequestAddStickerCollection) Reset()      { *m = RequestAddStickerCollection{} }
func (*RequestAddStickerCollection) ProtoMessage() {}
func (*RequestAddStickerCollection) Descriptor() ([]byte, []int) {
	return fileDescriptorStickers, []int{12}
}

func (m *RequestAddStickerCollection) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

// Removing sticker collection
type RequestRemoveStickerCollection struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *RequestRemoveStickerCollection) Reset()      { *m = RequestRemoveStickerCollection{} }
func (*RequestRemoveStickerCollection) ProtoMessage() {}
func (*RequestRemoveStickerCollection) Descriptor() ([]byte, []int) {
	return fileDescriptorStickers, []int{13}
}

func (m *RequestRemoveStickerCollection) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

// Loading stickers
type RequestLoadStickerCollection struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *RequestLoadStickerCollection) Reset()      { *m = RequestLoadStickerCollection{} }
func (*RequestLoadStickerCollection) ProtoMessage() {}
func (*RequestLoadStickerCollection) Descriptor() ([]byte, []int) {
	return fileDescriptorStickers, []int{14}
}

func (m *RequestLoadStickerCollection) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type ResponseLoadStickerCollection struct {
	Collection *StickerCollection `protobuf:"bytes,1,opt,name=collection" json:"collection,omitempty"`
}

func (m *ResponseLoadStickerCollection) Reset()      { *m = ResponseLoadStickerCollection{} }
func (*ResponseLoadStickerCollection) ProtoMessage() {}
func (*ResponseLoadStickerCollection) Descriptor() ([]byte, []int) {
	return fileDescriptorStickers, []int{15}
}

func (m *ResponseLoadStickerCollection) GetCollection() *StickerCollection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func init() {
	proto.RegisterType((*StickerDescriptor)(nil), "dialog.StickerDescriptor")
	proto.RegisterType((*StickerCollection)(nil), "dialog.StickerCollection")
	proto.RegisterType((*ResponseStickersResponse)(nil), "dialog.ResponseStickersResponse")
	proto.RegisterType((*RequestLoadOwnStickers)(nil), "dialog.RequestLoadOwnStickers")
	proto.RegisterType((*ResponseLoadOwnStickers)(nil), "dialog.ResponseLoadOwnStickers")
	proto.RegisterType((*RequestLoadAcesssibleStickers)(nil), "dialog.RequestLoadAcesssibleStickers")
	proto.RegisterType((*ResponseLoadAcesssibleStickers)(nil), "dialog.ResponseLoadAcesssibleStickers")
	proto.RegisterType((*RequestAddStickerPackReference)(nil), "dialog.RequestAddStickerPackReference")
	proto.RegisterType((*RequestRemoveStickerPackReference)(nil), "dialog.RequestRemoveStickerPackReference")
	proto.RegisterType((*UpdateStickerCollectionsChanged)(nil), "dialog.UpdateStickerCollectionsChanged")
	proto.RegisterType((*UpdateStickerPackRemoved)(nil), "dialog.UpdateStickerPackRemoved")
	proto.RegisterType((*UpdateStickerPackAdded)(nil), "dialog.UpdateStickerPackAdded")
	proto.RegisterType((*RequestAddStickerCollection)(nil), "dialog.RequestAddStickerCollection")
	proto.RegisterType((*RequestRemoveStickerCollection)(nil), "dialog.RequestRemoveStickerCollection")
	proto.RegisterType((*RequestLoadStickerCollection)(nil), "dialog.RequestLoadStickerCollection")
	proto.RegisterType((*ResponseLoadStickerCollection)(nil), "dialog.ResponseLoadStickerCollection")
}
func (this *StickerDescriptor) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StickerDescriptor)
	if !ok {
		that2, ok := that.(StickerDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.Emoji.Equal(that1.Emoji) {
		return false
	}
	if !this.Image_128.Equal(that1.Image_128) {
		return false
	}
	if !this.Image_512.Equal(that1.Image_512) {
		return false
	}
	if !this.Image_256.Equal(that1.Image_256) {
		return false
	}
	return true
}
func (this *StickerCollection) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StickerCollection)
	if !ok {
		that2, ok := that.(StickerCollection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.Title.Equal(that1.Title) {
		return false
	}
	if len(this.Stickers) != len(that1.Stickers) {
		return false
	}
	for i := range this.Stickers {
		if !this.Stickers[i].Equal(that1.Stickers[i]) {
			return false
		}
	}
	if !this.OwnedByMe.Equal(that1.OwnedByMe) {
		return false
	}
	return true
}
func (this *ResponseStickersResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResponseStickersResponse)
	if !ok {
		that2, ok := that.(ResponseStickersResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Collections) != len(that1.Collections) {
		return false
	}
	for i := range this.Collections {
		if !this.Collections[i].Equal(that1.Collections[i]) {
			return false
		}
	}
	if this.Seq != that1.Seq {
		return false
	}
	if !bytes.Equal(this.State, that1.State) {
		return false
	}
	return true
}
func (this *RequestLoadOwnStickers) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestLoadOwnStickers)
	if !ok {
		that2, ok := that.(RequestLoadOwnStickers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *ResponseLoadOwnStickers) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResponseLoadOwnStickers)
	if !ok {
		that2, ok := that.(ResponseLoadOwnStickers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.OwnStickers) != len(that1.OwnStickers) {
		return false
	}
	for i := range this.OwnStickers {
		if !this.OwnStickers[i].Equal(that1.OwnStickers[i]) {
			return false
		}
	}
	return true
}
func (this *RequestLoadAcesssibleStickers) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestLoadAcesssibleStickers)
	if !ok {
		that2, ok := that.(RequestLoadAcesssibleStickers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *ResponseLoadAcesssibleStickers) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResponseLoadAcesssibleStickers)
	if !ok {
		that2, ok := that.(ResponseLoadAcesssibleStickers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.AccessibleStickers) != len(that1.AccessibleStickers) {
		return false
	}
	for i := range this.AccessibleStickers {
		if !this.AccessibleStickers[i].Equal(that1.AccessibleStickers[i]) {
			return false
		}
	}
	return true
}
func (this *RequestAddStickerPackReference) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestAddStickerPackReference)
	if !ok {
		that2, ok := that.(RequestAddStickerPackReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.SourceStickerPack != that1.SourceStickerPack {
		return false
	}
	return true
}
func (this *RequestRemoveStickerPackReference) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestRemoveStickerPackReference)
	if !ok {
		that2, ok := that.(RequestRemoveStickerPackReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.SourceStickerPack != that1.SourceStickerPack {
		return false
	}
	return true
}
func (this *UpdateStickerCollectionsChanged) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateStickerCollectionsChanged)
	if !ok {
		that2, ok := that.(UpdateStickerCollectionsChanged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.UpdatedCollections) != len(that1.UpdatedCollections) {
		return false
	}
	for i := range this.UpdatedCollections {
		if !this.UpdatedCollections[i].Equal(that1.UpdatedCollections[i]) {
			return false
		}
	}
	return true
}
func (this *UpdateStickerPackRemoved) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateStickerPackRemoved)
	if !ok {
		that2, ok := that.(UpdateStickerPackRemoved)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.PackId != that1.PackId {
		return false
	}
	return true
}
func (this *UpdateStickerPackAdded) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateStickerPackAdded)
	if !ok {
		that2, ok := that.(UpdateStickerPackAdded)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Pack.Equal(that1.Pack) {
		return false
	}
	return true
}
func (this *RequestAddStickerCollection) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestAddStickerCollection)
	if !ok {
		that2, ok := that.(RequestAddStickerCollection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	return true
}
func (this *RequestRemoveStickerCollection) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestRemoveStickerCollection)
	if !ok {
		that2, ok := that.(RequestRemoveStickerCollection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *RequestLoadStickerCollection) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestLoadStickerCollection)
	if !ok {
		that2, ok := that.(RequestLoadStickerCollection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *ResponseLoadStickerCollection) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResponseLoadStickerCollection)
	if !ok {
		that2, ok := that.(ResponseLoadStickerCollection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Collection.Equal(that1.Collection) {
		return false
	}
	return true
}
func (this *StickerDescriptor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dialog.StickerDescriptor{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Emoji != nil {
		s = append(s, "Emoji: "+fmt.Sprintf("%#v", this.Emoji)+",\n")
	}
	if this.Image_128 != nil {
		s = append(s, "Image_128: "+fmt.Sprintf("%#v", this.Image_128)+",\n")
	}
	if this.Image_512 != nil {
		s = append(s, "Image_512: "+fmt.Sprintf("%#v", this.Image_512)+",\n")
	}
	if this.Image_256 != nil {
		s = append(s, "Image_256: "+fmt.Sprintf("%#v", this.Image_256)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StickerCollection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.StickerCollection{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Title != nil {
		s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	}
	if this.Stickers != nil {
		s = append(s, "Stickers: "+fmt.Sprintf("%#v", this.Stickers)+",\n")
	}
	if this.OwnedByMe != nil {
		s = append(s, "OwnedByMe: "+fmt.Sprintf("%#v", this.OwnedByMe)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseStickersResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.ResponseStickersResponse{")
	if this.Collections != nil {
		s = append(s, "Collections: "+fmt.Sprintf("%#v", this.Collections)+",\n")
	}
	s = append(s, "Seq: "+fmt.Sprintf("%#v", this.Seq)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestLoadOwnStickers) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&dialog.RequestLoadOwnStickers{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseLoadOwnStickers) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.ResponseLoadOwnStickers{")
	if this.OwnStickers != nil {
		s = append(s, "OwnStickers: "+fmt.Sprintf("%#v", this.OwnStickers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestLoadAcesssibleStickers) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&dialog.RequestLoadAcesssibleStickers{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseLoadAcesssibleStickers) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.ResponseLoadAcesssibleStickers{")
	if this.AccessibleStickers != nil {
		s = append(s, "AccessibleStickers: "+fmt.Sprintf("%#v", this.AccessibleStickers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestAddStickerPackReference) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestAddStickerPackReference{")
	s = append(s, "SourceStickerPack: "+fmt.Sprintf("%#v", this.SourceStickerPack)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestRemoveStickerPackReference) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestRemoveStickerPackReference{")
	s = append(s, "SourceStickerPack: "+fmt.Sprintf("%#v", this.SourceStickerPack)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateStickerCollectionsChanged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.UpdateStickerCollectionsChanged{")
	if this.UpdatedCollections != nil {
		s = append(s, "UpdatedCollections: "+fmt.Sprintf("%#v", this.UpdatedCollections)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateStickerPackRemoved) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.UpdateStickerPackRemoved{")
	s = append(s, "PackId: "+fmt.Sprintf("%#v", this.PackId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateStickerPackAdded) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.UpdateStickerPackAdded{")
	if this.Pack != nil {
		s = append(s, "Pack: "+fmt.Sprintf("%#v", this.Pack)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestAddStickerCollection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestAddStickerCollection{")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestRemoveStickerCollection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestRemoveStickerCollection{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestLoadStickerCollection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestLoadStickerCollection{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseLoadStickerCollection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.ResponseLoadStickerCollection{")
	if this.Collection != nil {
		s = append(s, "Collection: "+fmt.Sprintf("%#v", this.Collection)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringStickers(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Stickers service

type StickersClient interface {
	LoadOwnStickers(ctx context.Context, in *RequestLoadOwnStickers, opts ...grpc.CallOption) (*ResponseLoadOwnStickers, error)
	LoadAcesssibleStickers(ctx context.Context, in *RequestLoadAcesssibleStickers, opts ...grpc.CallOption) (*ResponseLoadAcesssibleStickers, error)
	AddStickerPackReference(ctx context.Context, in *RequestAddStickerPackReference, opts ...grpc.CallOption) (*ResponseSeq, error)
	RemoveStickerPackReference(ctx context.Context, in *RequestRemoveStickerPackReference, opts ...grpc.CallOption) (*ResponseSeq, error)
	AddStickerCollection(ctx context.Context, in *RequestAddStickerCollection, opts ...grpc.CallOption) (*ResponseSeq, error)
	RemoveStickerCollection(ctx context.Context, in *RequestRemoveStickerCollection, opts ...grpc.CallOption) (*ResponseSeq, error)
	LoadStickerCollection(ctx context.Context, in *RequestLoadStickerCollection, opts ...grpc.CallOption) (*ResponseLoadStickerCollection, error)
}

type stickersClient struct {
	cc *grpc.ClientConn
}

func NewStickersClient(cc *grpc.ClientConn) StickersClient {
	return &stickersClient{cc}
}

func (c *stickersClient) LoadOwnStickers(ctx context.Context, in *RequestLoadOwnStickers, opts ...grpc.CallOption) (*ResponseLoadOwnStickers, error) {
	out := new(ResponseLoadOwnStickers)
	err := grpc.Invoke(ctx, "/dialog.Stickers/LoadOwnStickers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stickersClient) LoadAcesssibleStickers(ctx context.Context, in *RequestLoadAcesssibleStickers, opts ...grpc.CallOption) (*ResponseLoadAcesssibleStickers, error) {
	out := new(ResponseLoadAcesssibleStickers)
	err := grpc.Invoke(ctx, "/dialog.Stickers/LoadAcesssibleStickers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stickersClient) AddStickerPackReference(ctx context.Context, in *RequestAddStickerPackReference, opts ...grpc.CallOption) (*ResponseSeq, error) {
	out := new(ResponseSeq)
	err := grpc.Invoke(ctx, "/dialog.Stickers/AddStickerPackReference", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stickersClient) RemoveStickerPackReference(ctx context.Context, in *RequestRemoveStickerPackReference, opts ...grpc.CallOption) (*ResponseSeq, error) {
	out := new(ResponseSeq)
	err := grpc.Invoke(ctx, "/dialog.Stickers/RemoveStickerPackReference", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stickersClient) AddStickerCollection(ctx context.Context, in *RequestAddStickerCollection, opts ...grpc.CallOption) (*ResponseSeq, error) {
	out := new(ResponseSeq)
	err := grpc.Invoke(ctx, "/dialog.Stickers/AddStickerCollection", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stickersClient) RemoveStickerCollection(ctx context.Context, in *RequestRemoveStickerCollection, opts ...grpc.CallOption) (*ResponseSeq, error) {
	out := new(ResponseSeq)
	err := grpc.Invoke(ctx, "/dialog.Stickers/RemoveStickerCollection", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stickersClient) LoadStickerCollection(ctx context.Context, in *RequestLoadStickerCollection, opts ...grpc.CallOption) (*ResponseLoadStickerCollection, error) {
	out := new(ResponseLoadStickerCollection)
	err := grpc.Invoke(ctx, "/dialog.Stickers/LoadStickerCollection", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Stickers service

type StickersServer interface {
	LoadOwnStickers(context.Context, *RequestLoadOwnStickers) (*ResponseLoadOwnStickers, error)
	LoadAcesssibleStickers(context.Context, *RequestLoadAcesssibleStickers) (*ResponseLoadAcesssibleStickers, error)
	AddStickerPackReference(context.Context, *RequestAddStickerPackReference) (*ResponseSeq, error)
	RemoveStickerPackReference(context.Context, *RequestRemoveStickerPackReference) (*ResponseSeq, error)
	AddStickerCollection(context.Context, *RequestAddStickerCollection) (*ResponseSeq, error)
	RemoveStickerCollection(context.Context, *RequestRemoveStickerCollection) (*ResponseSeq, error)
	LoadStickerCollection(context.Context, *RequestLoadStickerCollection) (*ResponseLoadStickerCollection, error)
}

func RegisterStickersServer(s *grpc.Server, srv StickersServer) {
	s.RegisterService(&_Stickers_serviceDesc, srv)
}

func _Stickers_LoadOwnStickers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestLoadOwnStickers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StickersServer).LoadOwnStickers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Stickers/LoadOwnStickers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StickersServer).LoadOwnStickers(ctx, req.(*RequestLoadOwnStickers))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stickers_LoadAcesssibleStickers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestLoadAcesssibleStickers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StickersServer).LoadAcesssibleStickers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Stickers/LoadAcesssibleStickers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StickersServer).LoadAcesssibleStickers(ctx, req.(*RequestLoadAcesssibleStickers))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stickers_AddStickerPackReference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestAddStickerPackReference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StickersServer).AddStickerPackReference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Stickers/AddStickerPackReference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StickersServer).AddStickerPackReference(ctx, req.(*RequestAddStickerPackReference))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stickers_RemoveStickerPackReference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestRemoveStickerPackReference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StickersServer).RemoveStickerPackReference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Stickers/RemoveStickerPackReference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StickersServer).RemoveStickerPackReference(ctx, req.(*RequestRemoveStickerPackReference))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stickers_AddStickerCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestAddStickerCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StickersServer).AddStickerCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Stickers/AddStickerCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StickersServer).AddStickerCollection(ctx, req.(*RequestAddStickerCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stickers_RemoveStickerCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestRemoveStickerCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StickersServer).RemoveStickerCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Stickers/RemoveStickerCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StickersServer).RemoveStickerCollection(ctx, req.(*RequestRemoveStickerCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stickers_LoadStickerCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestLoadStickerCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StickersServer).LoadStickerCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Stickers/LoadStickerCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StickersServer).LoadStickerCollection(ctx, req.(*RequestLoadStickerCollection))
	}
	return interceptor(ctx, in, info, handler)
}

var _Stickers_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dialog.Stickers",
	HandlerType: (*StickersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoadOwnStickers",
			Handler:    _Stickers_LoadOwnStickers_Handler,
		},
		{
			MethodName: "LoadAcesssibleStickers",
			Handler:    _Stickers_LoadAcesssibleStickers_Handler,
		},
		{
			MethodName: "AddStickerPackReference",
			Handler:    _Stickers_AddStickerPackReference_Handler,
		},
		{
			MethodName: "RemoveStickerPackReference",
			Handler:    _Stickers_RemoveStickerPackReference_Handler,
		},
		{
			MethodName: "AddStickerCollection",
			Handler:    _Stickers_AddStickerCollection_Handler,
		},
		{
			MethodName: "RemoveStickerCollection",
			Handler:    _Stickers_RemoveStickerCollection_Handler,
		},
		{
			MethodName: "LoadStickerCollection",
			Handler:    _Stickers_LoadStickerCollection_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "stickers.proto",
}

func (m *StickerDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StickerDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.Id))
	}
	if m.Emoji != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.Emoji.Size()))
		n1, err := m.Emoji.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Image_128 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.Image_128.Size()))
		n2, err := m.Image_128.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Image_512 != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.Image_512.Size()))
		n3, err := m.Image_512.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Image_256 != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.Image_256.Size()))
		n4, err := m.Image_256.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *StickerCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StickerCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.Id))
	}
	if m.Title != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.Title.Size()))
		n5, err := m.Title.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Stickers) > 0 {
		for _, msg := range m.Stickers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintStickers(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.OwnedByMe != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.OwnedByMe.Size()))
		n6, err := m.OwnedByMe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *ResponseStickersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseStickersResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Collections) > 0 {
		for _, msg := range m.Collections {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStickers(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Seq != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.Seq))
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStickers(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	return i, nil
}

func (m *RequestLoadOwnStickers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestLoadOwnStickers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ResponseLoadOwnStickers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseLoadOwnStickers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OwnStickers) > 0 {
		for _, msg := range m.OwnStickers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStickers(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RequestLoadAcesssibleStickers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestLoadAcesssibleStickers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ResponseLoadAcesssibleStickers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseLoadAcesssibleStickers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccessibleStickers) > 0 {
		for _, msg := range m.AccessibleStickers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStickers(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RequestAddStickerPackReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestAddStickerPackReference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceStickerPack != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.SourceStickerPack))
	}
	return i, nil
}

func (m *RequestRemoveStickerPackReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestRemoveStickerPackReference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceStickerPack != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.SourceStickerPack))
	}
	return i, nil
}

func (m *UpdateStickerCollectionsChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStickerCollectionsChanged) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UpdatedCollections) > 0 {
		for _, msg := range m.UpdatedCollections {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStickers(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateStickerPackRemoved) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStickerPackRemoved) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PackId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.PackId))
	}
	return i, nil
}

func (m *UpdateStickerPackAdded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStickerPackAdded) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pack != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.Pack.Size()))
		n7, err := m.Pack.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *RequestAddStickerCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestAddStickerCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStickers(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	return i, nil
}

func (m *RequestRemoveStickerCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestRemoveStickerCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *RequestLoadStickerCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestLoadStickerCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *ResponseLoadStickerCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseLoadStickerCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Collection != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStickers(dAtA, i, uint64(m.Collection.Size()))
		n8, err := m.Collection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func encodeFixed64Stickers(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Stickers(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintStickers(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *StickerDescriptor) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStickers(uint64(m.Id))
	}
	if m.Emoji != nil {
		l = m.Emoji.Size()
		n += 1 + l + sovStickers(uint64(l))
	}
	if m.Image_128 != nil {
		l = m.Image_128.Size()
		n += 1 + l + sovStickers(uint64(l))
	}
	if m.Image_512 != nil {
		l = m.Image_512.Size()
		n += 1 + l + sovStickers(uint64(l))
	}
	if m.Image_256 != nil {
		l = m.Image_256.Size()
		n += 1 + l + sovStickers(uint64(l))
	}
	return n
}

func (m *StickerCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStickers(uint64(m.Id))
	}
	if m.Title != nil {
		l = m.Title.Size()
		n += 1 + l + sovStickers(uint64(l))
	}
	if len(m.Stickers) > 0 {
		for _, e := range m.Stickers {
			l = e.Size()
			n += 1 + l + sovStickers(uint64(l))
		}
	}
	if m.OwnedByMe != nil {
		l = m.OwnedByMe.Size()
		n += 1 + l + sovStickers(uint64(l))
	}
	return n
}

func (m *ResponseStickersResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Collections) > 0 {
		for _, e := range m.Collections {
			l = e.Size()
			n += 1 + l + sovStickers(uint64(l))
		}
	}
	if m.Seq != 0 {
		n += 1 + sovStickers(uint64(m.Seq))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovStickers(uint64(l))
	}
	return n
}

func (m *RequestLoadOwnStickers) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ResponseLoadOwnStickers) Size() (n int) {
	var l int
	_ = l
	if len(m.OwnStickers) > 0 {
		for _, e := range m.OwnStickers {
			l = e.Size()
			n += 1 + l + sovStickers(uint64(l))
		}
	}
	return n
}

func (m *RequestLoadAcesssibleStickers) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ResponseLoadAcesssibleStickers) Size() (n int) {
	var l int
	_ = l
	if len(m.AccessibleStickers) > 0 {
		for _, e := range m.AccessibleStickers {
			l = e.Size()
			n += 1 + l + sovStickers(uint64(l))
		}
	}
	return n
}

func (m *RequestAddStickerPackReference) Size() (n int) {
	var l int
	_ = l
	if m.SourceStickerPack != 0 {
		n += 1 + sovStickers(uint64(m.SourceStickerPack))
	}
	return n
}

func (m *RequestRemoveStickerPackReference) Size() (n int) {
	var l int
	_ = l
	if m.SourceStickerPack != 0 {
		n += 1 + sovStickers(uint64(m.SourceStickerPack))
	}
	return n
}

func (m *UpdateStickerCollectionsChanged) Size() (n int) {
	var l int
	_ = l
	if len(m.UpdatedCollections) > 0 {
		for _, e := range m.UpdatedCollections {
			l = e.Size()
			n += 1 + l + sovStickers(uint64(l))
		}
	}
	return n
}

func (m *UpdateStickerPackRemoved) Size() (n int) {
	var l int
	_ = l
	if m.PackId != 0 {
		n += 1 + sovStickers(uint64(m.PackId))
	}
	return n
}

func (m *UpdateStickerPackAdded) Size() (n int) {
	var l int
	_ = l
	if m.Pack != nil {
		l = m.Pack.Size()
		n += 1 + l + sovStickers(uint64(l))
	}
	return n
}

func (m *RequestAddStickerCollection) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovStickers(uint64(l))
	}
	return n
}

func (m *RequestRemoveStickerCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStickers(uint64(m.Id))
	}
	return n
}

func (m *RequestLoadStickerCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStickers(uint64(m.Id))
	}
	return n
}

func (m *ResponseLoadStickerCollection) Size() (n int) {
	var l int
	_ = l
	if m.Collection != nil {
		l = m.Collection.Size()
		n += 1 + l + sovStickers(uint64(l))
	}
	return n
}

func sovStickers(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStickers(x uint64) (n int) {
	return sovStickers(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *StickerDescriptor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StickerDescriptor{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Emoji:` + strings.Replace(fmt.Sprintf("%v", this.Emoji), "StringValue", "google_protobuf.StringValue", 1) + `,`,
		`Image_128:` + strings.Replace(fmt.Sprintf("%v", this.Image_128), "ImageLocation", "ImageLocation", 1) + `,`,
		`Image_512:` + strings.Replace(fmt.Sprintf("%v", this.Image_512), "ImageLocation", "ImageLocation", 1) + `,`,
		`Image_256:` + strings.Replace(fmt.Sprintf("%v", this.Image_256), "ImageLocation", "ImageLocation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StickerCollection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StickerCollection{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Title:` + strings.Replace(fmt.Sprintf("%v", this.Title), "StringValue", "google_protobuf.StringValue", 1) + `,`,
		`Stickers:` + strings.Replace(fmt.Sprintf("%v", this.Stickers), "StickerDescriptor", "StickerDescriptor", 1) + `,`,
		`OwnedByMe:` + strings.Replace(fmt.Sprintf("%v", this.OwnedByMe), "BoolValue", "google_protobuf.BoolValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseStickersResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseStickersResponse{`,
		`Collections:` + strings.Replace(fmt.Sprintf("%v", this.Collections), "StickerCollection", "StickerCollection", 1) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestLoadOwnStickers) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestLoadOwnStickers{`,
		`}`,
	}, "")
	return s
}
func (this *ResponseLoadOwnStickers) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseLoadOwnStickers{`,
		`OwnStickers:` + strings.Replace(fmt.Sprintf("%v", this.OwnStickers), "StickerCollection", "StickerCollection", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestLoadAcesssibleStickers) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestLoadAcesssibleStickers{`,
		`}`,
	}, "")
	return s
}
func (this *ResponseLoadAcesssibleStickers) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseLoadAcesssibleStickers{`,
		`AccessibleStickers:` + strings.Replace(fmt.Sprintf("%v", this.AccessibleStickers), "StickerCollection", "StickerCollection", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestAddStickerPackReference) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestAddStickerPackReference{`,
		`SourceStickerPack:` + fmt.Sprintf("%v", this.SourceStickerPack) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestRemoveStickerPackReference) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestRemoveStickerPackReference{`,
		`SourceStickerPack:` + fmt.Sprintf("%v", this.SourceStickerPack) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateStickerCollectionsChanged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateStickerCollectionsChanged{`,
		`UpdatedCollections:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedCollections), "StickerCollection", "StickerCollection", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateStickerPackRemoved) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateStickerPackRemoved{`,
		`PackId:` + fmt.Sprintf("%v", this.PackId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateStickerPackAdded) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateStickerPackAdded{`,
		`Pack:` + strings.Replace(fmt.Sprintf("%v", this.Pack), "StickerCollection", "StickerCollection", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestAddStickerCollection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestAddStickerCollection{`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestRemoveStickerCollection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestRemoveStickerCollection{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestLoadStickerCollection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestLoadStickerCollection{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseLoadStickerCollection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseLoadStickerCollection{`,
		`Collection:` + strings.Replace(fmt.Sprintf("%v", this.Collection), "StickerCollection", "StickerCollection", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringStickers(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *StickerDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickerDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickerDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emoji", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Emoji == nil {
				m.Emoji = &google_protobuf.StringValue{}
			}
			if err := m.Emoji.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image_128", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image_128 == nil {
				m.Image_128 = &ImageLocation{}
			}
			if err := m.Image_128.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image_512", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image_512 == nil {
				m.Image_512 = &ImageLocation{}
			}
			if err := m.Image_512.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image_256", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image_256 == nil {
				m.Image_256 = &ImageLocation{}
			}
			if err := m.Image_256.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StickerCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickerCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickerCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Title == nil {
				m.Title = &google_protobuf.StringValue{}
			}
			if err := m.Title.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stickers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stickers = append(m.Stickers, &StickerDescriptor{})
			if err := m.Stickers[len(m.Stickers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnedByMe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnedByMe == nil {
				m.OwnedByMe = &google_protobuf.BoolValue{}
			}
			if err := m.OwnedByMe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseStickersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseStickersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseStickersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collections = append(m.Collections, &StickerCollection{})
			if err := m.Collections[len(m.Collections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestLoadOwnStickers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestLoadOwnStickers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestLoadOwnStickers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseLoadOwnStickers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseLoadOwnStickers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseLoadOwnStickers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnStickers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnStickers = append(m.OwnStickers, &StickerCollection{})
			if err := m.OwnStickers[len(m.OwnStickers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestLoadAcesssibleStickers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestLoadAcesssibleStickers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestLoadAcesssibleStickers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseLoadAcesssibleStickers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseLoadAcesssibleStickers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseLoadAcesssibleStickers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessibleStickers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessibleStickers = append(m.AccessibleStickers, &StickerCollection{})
			if err := m.AccessibleStickers[len(m.AccessibleStickers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestAddStickerPackReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestAddStickerPackReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestAddStickerPackReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceStickerPack", wireType)
			}
			m.SourceStickerPack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceStickerPack |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestRemoveStickerPackReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestRemoveStickerPackReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestRemoveStickerPackReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceStickerPack", wireType)
			}
			m.SourceStickerPack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceStickerPack |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStickerCollectionsChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateStickerCollectionsChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateStickerCollectionsChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedCollections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedCollections = append(m.UpdatedCollections, &StickerCollection{})
			if err := m.UpdatedCollections[len(m.UpdatedCollections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStickerPackRemoved) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateStickerPackRemoved: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateStickerPackRemoved: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackId", wireType)
			}
			m.PackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStickerPackAdded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateStickerPackAdded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateStickerPackAdded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pack == nil {
				m.Pack = &StickerCollection{}
			}
			if err := m.Pack.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestAddStickerCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestAddStickerCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestAddStickerCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestRemoveStickerCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestRemoveStickerCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestRemoveStickerCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestLoadStickerCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestLoadStickerCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestLoadStickerCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseLoadStickerCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseLoadStickerCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseLoadStickerCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickers
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Collection == nil {
				m.Collection = &StickerCollection{}
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStickers(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStickers
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStickers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStickers
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStickers
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStickers(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStickers = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStickers   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("stickers.proto", fileDescriptorStickers) }

var fileDescriptorStickers = []byte{
	// 1024 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x96, 0xd1, 0x6f, 0xdb, 0x44,
	0x1c, 0xc7, 0x7b, 0xed, 0xda, 0xb5, 0xbf, 0x0e, 0x50, 0x9d, 0xb5, 0xf5, 0x42, 0xeb, 0x76, 0x1e,
	0x0b, 0xdd, 0x28, 0x0e, 0xf1, 0x68, 0x19, 0xd3, 0xa6, 0x2a, 0xd9, 0x10, 0xea, 0x34, 0x04, 0x4a,
	0xc5, 0x24, 0x84, 0x50, 0xb8, 0xf8, 0xae, 0xe1, 0xa8, 0xe3, 0x73, 0x7d, 0x4e, 0xaa, 0x4a, 0x20,
	0x55, 0x4c, 0xe2, 0x01, 0x78, 0x40, 0x42, 0x48, 0x3c, 0xf0, 0x07, 0xf0, 0x57, 0xf0, 0x8c, 0xc4,
	0xcb, 0x24, 0x5e, 0x78, 0xa4, 0x86, 0x07, 0xc4, 0xd3, 0xfe, 0x04, 0xe4, 0x4b, 0x1c, 0x7b, 0xb1,
	0xdd, 0xb4, 0x80, 0x78, 0x4a, 0x72, 0xf7, 0xfb, 0x7d, 0xef, 0x73, 0xdf, 0xbb, 0xfb, 0x2a, 0xf0,
	0xac, 0xf0, 0x99, 0xb5, 0x47, 0x3d, 0x61, 0xb8, 0x1e, 0xf7, 0xb9, 0x32, 0x45, 0x18, 0xb6, 0x79,
	0xab, 0xa8, 0xb5, 0x38, 0x6f, 0xd9, 0xb4, 0x2c, 0x47, 0x9b, 0x9d, 0xdd, 0xf2, 0x81, 0x87, 0x5d,
	0x77, 0x50, 0x57, 0x5c, 0xea, 0xcf, 0x63, 0x97, 0x95, 0xb1, 0xe3, 0x70, 0x1f, 0xfb, 0x8c, 0x3b,
	0xd1, 0xec, 0x1c, 0xa1, 0xbb, 0xcc, 0x61, 0xc9, 0xa1, 0x42, 0x9b, 0x09, 0x8b, 0xda, 0x36, 0x76,
	0x28, 0xef, 0x44, 0x83, 0xf3, 0x6d, 0x4a, 0x18, 0x6e, 0x60, 0x87, 0x34, 0x76, 0x99, 0x4d, 0x07,
	0xc3, 0xc2, 0xc2, 0x36, 0x76, 0x9b, 0xe5, 0xfe, 0x67, 0x6f, 0x58, 0xff, 0x71, 0x1c, 0xe6, 0x76,
	0x7a, 0xb8, 0xf7, 0xa8, 0xb0, 0x3c, 0xe6, 0xfa, 0xdc, 0x53, 0x96, 0x61, 0x9c, 0x11, 0x15, 0xad,
	0xa2, 0xb5, 0xc9, 0xda, 0x33, 0x5f, 0xfc, 0xf5, 0xca, 0x0c, 0x9c, 0xef, 0x32, 0xc1, 0x9a, 0x36,
	0xad, 0x8f, 0x33, 0xa2, 0x54, 0x61, 0x92, 0xb6, 0xf9, 0xc7, 0x4c, 0x1d, 0x5f, 0x45, 0x6b, 0xb3,
	0xe6, 0x92, 0xd1, 0x03, 0x37, 0xa2, 0x8d, 0x19, 0x3b, 0xbe, 0xc7, 0x9c, 0xd6, 0x43, 0x6c, 0x77,
	0xe8, 0x70, 0x7f, 0xaf, 0x53, 0xa9, 0xc2, 0x0c, 0x6b, 0xe3, 0x16, 0x6d, 0x54, 0xcc, 0x9b, 0xea,
	0x84, 0x94, 0x99, 0x37, 0x7a, 0x3e, 0x19, 0xdb, 0xe1, 0xc4, 0x03, 0x6e, 0xc9, 0xed, 0x0f, 0xf7,
	0x4f, 0xcb, 0xb6, 0x8a, 0x79, 0x33, 0x96, 0xd8, 0xa8, 0x98, 0xea, 0xb9, 0x33, 0x4b, 0x6c, 0x54,
	0xcc, 0x58, 0xc2, 0xdc, 0xd8, 0x54, 0x27, 0xcf, 0x2c, 0x61, 0x6e, 0x6c, 0xea, 0x9f, 0xc7, 0x06,
	0xde, 0xe5, 0xb6, 0x4d, 0xad, 0xb0, 0xfc, 0x14, 0x06, 0xfa, 0xcc, 0xb7, 0xe9, 0x3f, 0x32, 0x50,
	0x76, 0x2a, 0xf7, 0x60, 0x3a, 0xba, 0x66, 0xea, 0xc4, 0xea, 0xc4, 0xda, 0xac, 0x79, 0x29, 0x22,
	0x4f, 0x9d, 0x67, 0x8a, 0x3e, 0xea, 0x54, 0xb6, 0x61, 0x96, 0x1f, 0x38, 0x94, 0x34, 0x9a, 0x87,
	0x8d, 0x36, 0xed, 0xbb, 0x58, 0x4c, 0xe1, 0xd4, 0x38, 0xb7, 0x33, 0x61, 0x66, 0x64, 0x77, 0xed,
	0xf0, 0x2d, 0xaa, 0xff, 0x8c, 0x40, 0xad, 0x53, 0xe1, 0x72, 0x47, 0xd0, 0x3e, 0x81, 0x88, 0x7e,
	0x2b, 0xf7, 0x61, 0xd6, 0x1a, 0xb8, 0x23, 0x54, 0x94, 0x09, 0x1c, 0xfb, 0x37, 0xbc, 0x4c, 0xb2,
	0x59, 0x59, 0x81, 0x09, 0x41, 0xf7, 0xa5, 0x75, 0x29, 0x73, 0xc3, 0x19, 0xe5, 0x0a, 0x4c, 0x0a,
	0x1f, 0xfb, 0x54, 0xde, 0xab, 0x0b, 0x29, 0xff, 0xe4, 0xdc, 0xad, 0xe5, 0x60, 0xab, 0x08, 0x2a,
	0x6b, 0x1b, 0xc4, 0x6e, 0x19, 0x2d, 0xcf, 0xb5, 0x8c, 0x37, 0x3d, 0xd7, 0x8a, 0x80, 0xf5, 0x4d,
	0x58, 0xa8, 0xd3, 0xfd, 0x0e, 0x15, 0xfe, 0x03, 0x8e, 0xc9, 0xdb, 0x07, 0x4e, 0xb4, 0xa5, 0x5b,
	0x4b, 0xc1, 0xd6, 0x25, 0x58, 0x4c, 0x37, 0xca, 0x62, 0xbd, 0x0b, 0x8b, 0x91, 0xc6, 0x50, 0xa3,
	0x72, 0x1b, 0x2e, 0xf0, 0x03, 0xa7, 0x31, 0x38, 0xb5, 0x51, 0x26, 0xd4, 0xc3, 0xa3, 0x19, 0x2c,
	0x3b, 0x82, 0xf7, 0x0e, 0x2c, 0x27, 0x78, 0xab, 0x16, 0x15, 0x42, 0x6e, 0xf7, 0x94, 0xd8, 0x5f,
	0x22, 0xd0, 0x92, 0xdc, 0x69, 0x01, 0xe5, 0x3e, 0x14, 0xb0, 0x15, 0x0e, 0x87, 0xa3, 0x67, 0xd8,
	0x85, 0x12, 0x77, 0x9d, 0x76, 0x33, 0x9f, 0x86, 0x30, 0x12, 0xac, 0x4a, 0x48, 0xbf, 0xe9, 0x1d,
	0x6c, 0xed, 0xd5, 0xe9, 0x2e, 0xf5, 0xa8, 0x63, 0x51, 0xe5, 0x0e, 0x14, 0x04, 0xef, 0x78, 0xd6,
	0x00, 0xa4, 0xe1, 0x62, 0x6b, 0x2f, 0xfb, 0xc1, 0xcd, 0xf5, 0x2a, 0x13, 0x3a, 0x23, 0xcc, 0x38,
	0x42, 0x70, 0xb9, 0xff, 0xbd, 0x4e, 0xdb, 0xbc, 0x4b, 0xff, 0x7f, 0x84, 0x4f, 0x60, 0xe5, 0x5d,
	0x97, 0x60, 0x9f, 0xa6, 0xfc, 0x14, 0x77, 0x3f, 0xc2, 0x4e, 0x8b, 0x12, 0xe5, 0x3d, 0x28, 0x74,
	0x64, 0x09, 0x69, 0xfc, 0x9b, 0xa7, 0xa5, 0xf4, 0x45, 0x12, 0x2b, 0xe8, 0x35, 0x50, 0x9f, 0x5a,
	0xbd, 0xb7, 0xf1, 0xd0, 0x09, 0xa2, 0x94, 0xe0, 0x7c, 0xb8, 0xcf, 0x46, 0x5e, 0xbc, 0x4d, 0x85,
	0xb3, 0xdb, 0x44, 0x7f, 0x08, 0x0b, 0x29, 0x8d, 0x2a, 0x21, 0x94, 0x28, 0xb7, 0xe1, 0xdc, 0xc0,
	0xa9, 0xb3, 0x90, 0xca, 0x2e, 0xfd, 0x43, 0x78, 0x3e, 0x75, 0x37, 0x12, 0xc1, 0x7b, 0x25, 0x4a,
	0xd6, 0x50, 0x7d, 0x26, 0x3b, 0x3b, 0x47, 0x78, 0xff, 0xc1, 0xe0, 0xf6, 0x3d, 0x75, 0xfa, 0xa7,
	0x4e, 0xf7, 0x11, 0xf2, 0xef, 0xc3, 0x52, 0xe2, 0xa5, 0xfe, 0xc7, 0xe2, 0x87, 0x61, 0x0c, 0xc4,
	0xcf, 0x38, 0xad, 0xfe, 0x3a, 0x40, 0x7c, 0x5b, 0x46, 0x1e, 0x41, 0x3d, 0x51, 0x3c, 0xe2, 0xd1,
	0x9a, 0x8f, 0xa6, 0x61, 0x7a, 0x10, 0x16, 0x47, 0x08, 0x9e, 0x1b, 0xce, 0x3f, 0x2d, 0x5a, 0x26,
	0x3b, 0x58, 0x8b, 0x2b, 0xf1, 0x7c, 0x66, 0x80, 0xea, 0xeb, 0x9f, 0xfd, 0xf2, 0xc7, 0x37, 0xe3,
	0x25, 0xfd, 0x72, 0xb9, 0x5b, 0x29, 0x87, 0x00, 0xe5, 0x68, 0xaa, 0x3c, 0x1c, 0xd2, 0xe8, 0xba,
	0xf2, 0x3d, 0x82, 0x85, 0x9c, 0x28, 0xbb, 0x9a, 0x41, 0x92, 0x2e, 0x2b, 0x96, 0xb2, 0x80, 0xd2,
	0x75, 0xfa, 0x0d, 0xc9, 0xf5, 0xb2, 0xbe, 0x96, 0xcd, 0x95, 0x11, 0xc6, 0xe8, 0xba, 0xf2, 0x15,
	0x82, 0xc5, 0xbc, 0x74, 0x2b, 0x0d, 0xf1, 0xe5, 0xd4, 0x15, 0x0b, 0xc3, 0x80, 0x3b, 0x74, 0x5f,
	0x7f, 0x55, 0xd2, 0x18, 0xfa, 0xb5, 0x34, 0x4d, 0x8e, 0x4e, 0x88, 0xf3, 0x2d, 0x82, 0xe2, 0x09,
	0x61, 0x77, 0x6d, 0x88, 0x28, 0xbf, 0x34, 0x1b, 0xea, 0x35, 0x09, 0x55, 0xd1, 0xd7, 0xd3, 0x50,
	0xf9, 0x52, 0x21, 0xd7, 0x23, 0x04, 0x17, 0xb3, 0x1f, 0x7a, 0xae, 0x47, 0x71, 0x51, 0x36, 0x4b,
	0x45, 0xb2, 0xbc, 0xa4, 0x97, 0x4e, 0x32, 0x28, 0x16, 0x89, 0x0e, 0x2b, 0x2f, 0x0c, 0x4a, 0x27,
	0x59, 0x33, 0x8a, 0xe5, 0x84, 0xc3, 0xca, 0xd1, 0x09, 0x71, 0xbe, 0x43, 0x30, 0x9f, 0xfd, 0xbc,
	0x5f, 0xc8, 0xb8, 0xd9, 0x69, 0x94, 0xab, 0x59, 0x17, 0x3b, 0x55, 0xa6, 0x9b, 0x12, 0x6e, 0x5d,
	0x7f, 0x31, 0xfb, 0x5e, 0x67, 0xa1, 0xd5, 0xde, 0x08, 0xb6, 0x16, 0xe0, 0x62, 0x32, 0x24, 0x04,
	0xf5, 0xba, 0xcc, 0xa2, 0xe2, 0xf1, 0xb1, 0x36, 0xf6, 0xeb, 0xb1, 0x36, 0xf6, 0xe4, 0x58, 0x43,
	0x47, 0x81, 0x86, 0x7e, 0x08, 0x34, 0xf4, 0x53, 0xa0, 0xa1, 0xc7, 0x81, 0x86, 0x7e, 0x0b, 0x34,
	0xf4, 0x67, 0xa0, 0x8d, 0x3d, 0x09, 0x34, 0xf4, 0xf5, 0xef, 0xda, 0x58, 0x73, 0x4a, 0xfe, 0xf5,
	0xbc, 0xf1, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5d, 0x29, 0x09, 0xca, 0x4b, 0x0d, 0x00, 0x00,
}
