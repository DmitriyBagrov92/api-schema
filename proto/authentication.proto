syntax = "proto3";

package dialog;

import "empty.proto";
import "wrappers.proto";
import "annotations.proto";
import "definitions.proto";
import "miscellaneous.proto";
import "peers.proto";
import "users.proto";
import "scalapb.proto";

option go_package = "dialog";
option java_package = "im.dlg.grpc.services";

/// Способ активации при регистрации по телефону
enum PhoneActivationType {
  PHONE_ACTIVATION_TYPE_UNKNOWN = 0;

  /// Активация по коду
  PHONE_ACTIVATION_TYPE_CODE = 1;

  /// Активация по паролю
  PHONE_ACTIVATION_TYPE_PASSWORD = 2;
}

/// Способ активации при регистрации по email
enum EmailActivationType {
  EMAIL_ACTIVATION_TYPE_UNKNOWN = 0;

  /// Активация по коду
  EMAIL_ACTIVATION_TYPE_CODE = 1;

  /// Активация по OAuth2
  EMAIL_ACTIVATION_TYPE_OAUTH2 = 2;

  /// Активация по паролю
  EMAIL_ACTIVATION_TYPE_PASSWORD = 3;
}

/// Запрос на начало телефонной авторизации
message RequestStartPhoneAuth {
  /// Номер телефона использующегося для авторизации
  int64 phone_number = 1 [(dlg).log = log_sensitive];

  /// Часовой пояс пользователя
  google.protobuf.StringValue time_zone = 2;

  /// Список предпочтительных локалей пользователя (в формате ^[a-z]{2}(?:[-_][A-Z]{2})?$)
  repeated string preferred_languages = 3;
}

/// Ответ на запрос на начало телефонной авторизации
message ResponseStartPhoneAuth {
  /// Хэш транзакции -- идентифицирует авторизационную транзакцию начатую вызовом метода RequestStartPhoneAuth
  /// этот хэш необходимо использовать во всех дальнейших вызовах до момента успешной авторизации
  string transaction_hash = 1 [(dlg).log = log_sensitive];

  /// Соответствует ли переданный телефонный номер какому-либо активному пользователю (зарегистрирован ли он)
  bool is_registered = 2;

  /// Способ активации авторизации предлагаемый сервером клиенту
  PhoneActivationType activation_type = 3;
}

/// Активация авторизации с помощью телефонного звонка
message RequestSendCodeByPhoneCall {
  /// Хэш транзакции, полученный на предыдущем шаге из ответа ResponseStartPhoneAuth
  string transaction_hash = 1 [(dlg).log = log_sensitive];
}

/// Запрос на начало авторизации по электронной почте
message RequestStartEmailAuth {
  /// Электронная почта использующаяся для авторизации
  string email = 1;

  /// Часовой пояс пользователя
  google.protobuf.StringValue time_zone = 2;

  /// Список предпочтительных локалей пользователя (в формате ^[a-z]{2}(?:[-_][A-Z]{2})?$)
  repeated string preferred_languages = 3;
}

/// Ответ на запрос на начало авторизации по электронной почте
message ResponseStartEmailAuth {
  /// Хэш транзакции -- идентифицирует авторизационную транзакцию начатую вызовом метода RequestStartEmailAuth
  /// этот хэш необходимо использовать во всех дальнейших вызовах до момента успешной авторизации
  string transaction_hash = 1 [(dlg).log = log_sensitive];

  /// Соответствует ли переданная электронная почта какому-либо активному пользователю (зарегистрирован ли он)
  bool is_registered = 2;

  /// Способ активации авторизации предлагаемый сервером клиенту
  EmailActivationType activation_type = 3;
}

/// Запрос на начало авторизации с помощью сертификата
message RequestStartCertificateAuth {
  /// Предполагаемое имя пользователя, в случае если соответствие сертификата существующему на сервере пользователю не выявлено
  string name = 1;

  /// Часовой пояс пользователя
  google.protobuf.StringValue time_zone = 2;

  /// Список предпочтительных локалей пользователя (в формате ^[a-z]{2}(?:[-_][A-Z]{2})?$)
  repeated string preferred_languages = 3;
}

/// Запрос на начало авторизаци с помощью бот-токена
message RequestStartTokenAuth {
  /// Токен выданный при регистрации бота
  string token = 1 [(dlg).log = log_sensitive];

  /// Часовой пояс бота
  google.protobuf.StringValue time_zone = 2;

  /// Список предпочтительных локалей бота (в формате ^[a-z]{2}(?:[-_][A-Z]{2})?$)
  repeated string preferred_languages = 3;
}

/// Запрос на начало авторизации по паре логин-пароль
message RequestStartUsernameAuth {
  /// Логин пользователя
  string username = 1;

  /// Часовой пояс пользователя
  google.protobuf.StringValue time_zone = 2;

  /// Список предпочтительных локалей пользователя (в формате ^[a-z]{2}(?:[-_][A-Z]{2})?$)
  repeated string preferred_languages = 3;
}

/// Ответ на запрос на начало авторизации по паре логин-пароль
message ResponseStartUsernameAuth {
  /// Хэш транзакции -- идентифицирует авторизационную транзакцию начатую вызовом метода RequestStartUsernameAuth
  /// этот хэш необходимо использовать во всех дальнейших вызовах до момента успешной авторизации
  string transaction_hash = 1 [(dlg).log = log_sensitive];

  /// Соответствует ли переданный логин какому-либо активному пользователю (зарегистрирован ли он)
  bool is_registered = 2;
}

/// Запрос на перенос авторизованной сессии из внешней доверенной системы
message RequestApplyExternalSessionAuth {
  /// Идентификатор сессии во внешней доверенной системе
  string session_id = 1 [(dlg).log = log_sensitive];
}

/// Запрос на получение токена сессии для внешней системы
message RequestGetIdToken {
  /// Название (идентификатор) внешней системы
  string service = 1;
}

/// Ответ на запрос на получение токена сессии для внешней системы
message ResponseGetIdToken {
  /// Токен сессии
  string token = 1 [(dlg).log = log_sensitive];

  /// Срок действия токена сессии
  int64 expiration_date = 2;
}

/// Запрос на начало обобщенной авторизации, без указания предпочтительного способа активации
/// используется для вариантов OAuth и других подобных механизмов
message RequestStartAuthTransaction {
  /// Часовой пояс пользователя
  google.protobuf.StringValue time_zone = 1;

  /// Список предпочтительных локалей пользователя (в формате ^[a-z]{2}(?:[-_][A-Z]{2})?$)
  repeated string preferred_languages = 2;
}

/// Ответ на запрос на начало обобщенной авторизаци
message ResponseStartAuthTransaction {
  /// Хэш транзакции -- идентифицирует авторизационную транзакцию начатую вызовом метода RequestStartAuthTransaction
  /// этот хэш необходимо использовать во всех дальнейших вызовах до момента успешной авторизации
  string transaction_hash = 1 [(dlg).log = log_sensitive];
}

/// Запрос на валидацию кода внешней активации
message RequestValidateCode {
  /// Полученный ранее хэш транзакции
  string transaction_hash = 1  [(dlg).log = log_sensitive];

  /// Код, передаваемый серверу в качестве подтверждения прохождения внешней активации
  string code = 2 [(dlg).log = log_confidential];
}

/// Запрос на перепосылку кода внешней активации
message RequestResendCode {
  /// Полученный ранее хэш транзакции
  string transaction_hash = 1 [(dlg).log = log_sensitive];
}

/// Запрос на прохождение активации по паре логин-пароль
message RequestValidatePassword {
  /// Полученный ранее хэш транзакции
  string transaction_hash = 1 [(dlg).log = log_sensitive];

  /// Пароль
  string password = 2 [(dlg).log = log_confidential];
}

/// Запрос на загрузку параметров OAuth2-платформы
message RequestGetOAuth2Params {
  /// Полученный ранее хэш транзакции
  string transaction_hash = 1 [(dlg).log = log_sensitive];

  /// URL для редиректа после успешной авторизации на OAuth2-платформе
  string redirect_url = 2;
}

/// Ответ на запрос на загрузку параметров OAuth2-платформы
message ResponseGetOAuth2Params {
  /// Сформированный URL для аутентификации на OAuth2-платформе
  string auth_url = 1;
}

/// Запрос на финализацию аутентификации на OAuth2-платформе
message RequestCompleteOAuth2 {
  /// Полученный ранее хэш транзакции
  string transaction_hash = 1 [(dlg).log = log_sensitive];

  /// Код активации, полученный после успешной авторизации на OAuth2-платформе
  string code = 2 [(dlg).log = log_confidential];
}

/// Запрос на регистрацию пользователя
message RequestSignUp {
  /// Полученный ранее хэш транзакции
  string transaction_hash = 1 [(dlg).log = log_sensitive];

  /// Имя пользователя
  string name = 2;

  /// Пол пользователя
  Sex sex = 3;

  /// Желаемый пароль пользователя
  google.protobuf.StringValue password = 4 [(dlg).log = log_confidential];
}

/// Дополнительные данные о завершенной авторизации
enum AuthExtraInfoType {
  AUTH_EXTRA_INFO_TYPE_NONE = 0;

  /// Пароль, использованный при авторизации, должен быть изменён до следующей авторизации
  AUTH_EXTRA_INFO_TYPE_NEED_CHANGE_PASSWORD = 1;
}

/// Результат авторизации
message ResponseAuth {
  /// Структура авторизованного пользователя
  User user = 2;

  /// Конфигруация для авторизованного пользователя
  Config config = 3;

  /// Хэш конфигурации
  google.protobuf.Int64Value config_hash = 4;

  /// Дополнительная информация о завершенной авторизации
  repeated AuthExtraInfoType extra_info = 5;
}

/// Авторизованная сессия
message AuthSession {
  /// Идентификатор сессии
  string id = 1;

  /// Держатель сессии
  AuthHolder auth_holder = 2;

  /// Идентификатор приложения связанного с сессией
  int32 app_id = 3;

  /// Название приложения связанного с сессией
  string app_title = 4;

  /// Название устройства связанного с сессией
  string device_title = 5;

  /// Время создания сессии (от Unix epoch в секундах)
  int32 auth_time = 6;

  /// Двубуквенное обозначение страны, из которой была создана сессия
  string auth_location = 7 [(dlg).log = log_confidential];

  /// Географическая широта, из которой была создана сессия
  google.protobuf.DoubleValue latitude = 8 [(dlg).log = log_sensitive];

  /// Географическая долгота, из которой была создана сессия
  google.protobuf.DoubleValue longitude = 9 [(dlg).log = log_sensitive];
}

/// Держатель сессии
enum AuthHolder {
  AUTH_HOLDER_UNKNOWN = 0;

  // Держатель сессии -- текущее устройство пользователя
  AUTH_HOLDER_THISDEVICE = 1;

  /// Держатель сессии -- другое устройство пользователя
  AUTH_HOLDER_OTHERDEVICE = 2;
}

/// Запрос на получение списка сессий
message RequestGetAuthSessions {
}

/// Ответ на запрос на получение списка сессий
message ResponseGetAuthSessions {
  /// Список активных сессий пользователя
  repeated AuthSession user_auths = 1;
}

/// Запрос на завершение сессии
message RequestTerminateSession {
  /// Идентификатор сессии, которую необходимо завершить
  string id = 1;
}

/// Запрос на завершение всех сессий пользователя кроме текущей
message RequestTerminateAllSessions {
}

/// Запрос на завершение текущей сессии
message RequestSignOut {
}

/// Состояние клиента для принудительного обновления -- при получении WeakUpdate-а UpdateForceReloadState
/// все соотвтетствующие элементы состояния клиента должны быть перезагружены с сервера
message ForceReloadField {
  oneof body {
    /// Принудительное обновление списка диалогов
    ForceReloadDialogs force_reload_dialogs = 1;

    /// Принудительное обновления списка контактов
    ForceReloadContacts force_reload_contacts = 2;

    /// Принудительное обновление истории чата
    ForceReloadHistory force_reload_history = 3;
  }
}

/// см. ForceReloadField
message ForceReloadDialogs {
}

/// см. ForceReloadField
message ForceReloadContacts {
}

/// см. ForceReloadField
message ForceReloadHistory {
  /// Пир чата, историю которого необходимо обновить
  Peer peer = 1;
}

/// Запрос на изменение пароля пользователя
message RequestChangePassword {
  /// Старый пароль
  string old_password = 1 [(dlg).log = log_confidential];

  /// Новый пароль
  string new_password = 2 [(dlg).log = log_confidential];
}

/// Запрос на получение структуры текущего пользователя
message RequestGetSelf {
}

/// Ответ на запрос на получение структуры текущего пользователя
message ResponseGetSelf {
  /// Структура текущего пользователя
  User user = 1;
}

service Authentication {
  /// Метод начала авторизации по телефону
  rpc StartPhoneAuth (RequestStartPhoneAuth) returns (ResponseStartPhoneAuth) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/StartPhoneAuth"
      body: "*"
    };
  }

  /// Метод посылки телефонного кода активации с помощью звонка
  rpc SendCodeByPhoneCall (RequestSendCodeByPhoneCall) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/SendCodeByPhoneCall"
      body: "*"
    };
  }

  /// Метод начала авторизации по электронной почте
  rpc StartEmailAuth (RequestStartEmailAuth) returns (ResponseStartEmailAuth) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/StartEmailAuth"
      body: "*"
    };
  }

  /// Метод начала авторизации по сертификату
  rpc StartCertificateAuth (RequestStartCertificateAuth) returns (ResponseAuth) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/StartCertificateAuth"
      body: "*"
    };
  }

  /// Метод начала авторизации по токену (для ботов)
  rpc StartTokenAuth (RequestStartTokenAuth) returns (ResponseAuth) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/StartTokenAuth"
      body: "*"
    };
  }

  /// Метод начала авторизации по паре логин-пароль
  rpc StartUsernameAuth (RequestStartUsernameAuth) returns (ResponseStartUsernameAuth) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/StartUsernameAuth"
      body: "*"
    };
  }

  /// Метод начала авторизации переносом авторизованной сессии с внешней доверенной системы
  rpc ApplyExternalSessionAuth (RequestApplyExternalSessionAuth) returns (ResponseAuth) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/ApplyExternalSessionAuth"
      body: "*"
    };
  }

  /// Метод получения токена сессии для внешней системы
  rpc GetIdToken (RequestGetIdToken) returns (ResponseGetIdToken) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/RequestGetIdToken"
      body: "*"
    };
  }

  /// Метод начала обобщенной авторизации
  rpc StartAuthTransaction (RequestStartAuthTransaction) returns (ResponseStartAuthTransaction) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/RequestStartAuthTransaction"
      body: "*"
    };
  }

  /// Методя валидации активационного кода
  rpc ValidateCode (RequestValidateCode) returns (ResponseAuth) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/ValidateCode"
      body: "*"
    };
  }

  /// Метод перепосылки активационного кода
  rpc ResendCode (RequestResendCode) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/ResendCode"
      body: "*"
    };
  }

  /// Метод валидации пароля
  rpc ValidatePassword (RequestValidatePassword) returns (ResponseAuth) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/ValidatePassword"
      body: "*"
    };
  }

  /// Метод получения параметров OAuth2-платформы
  rpc GetOAuth2Params (RequestGetOAuth2Params) returns (ResponseGetOAuth2Params) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/GetOAuth2Params"
      body: "*"
    };
  }

  /// Метод финализации аутентификации на OAuth2-платформе
  rpc CompleteOAuth2 (RequestCompleteOAuth2) returns (ResponseAuth) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/CompleteOAuth2"
      body: "*"
    };
  }

  /// Метод регистрации пользователя
  rpc SignUp (RequestSignUp) returns (ResponseAuth) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/SignUp"
      body: "*"
    };
  }

  /// Метод получения авторизованных сессий
  rpc GetAuthSessions (RequestGetAuthSessions) returns (ResponseGetAuthSessions) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/GetAuthSessions"
      body: "*"
    };
  }

  /// Метод завершения сессии
  rpc TerminateSession (RequestTerminateSession) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/TerminateSession"
      body: "*"
    };
  }

  /// Метод завершения всех сессий пользователя кроме текущей
  rpc TerminateAllSessions (RequestTerminateAllSessions) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/TerminateAllSessions"
      body: "*"
    };
  }

  /// Метод завершения текущей сессии
  rpc SignOut (RequestSignOut) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/SignOut"
      body: "*"
    };
  }

  /// Мтеод изменения пароля пользователя
  rpc ChangePassword (RequestChangePassword) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/ChangePassword"
      body: "*"
    };
  }

  /// Метод получения структуры текущего пользователя
  rpc GetSelf (RequestGetSelf) returns (ResponseGetSelf) {
    option (google.api.http) = {
      post: "/v1/grpc/Authentication/GetSelf"
      body: "*"
    };
  }
}
