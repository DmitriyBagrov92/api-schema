// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stickers.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Stickers.pbobjc.h"
#import "google/api/Annotations.pbobjc.h"
#import "Definitions.pbobjc.h"
#import "Miscellaneous.pbobjc.h"
#import "MediaAndFiles.pbobjc.h"
#import "scalapb/Scalapb.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(GPBBoolValue);
GPBObjCClassDeclaration(GPBStringValue);
GPBObjCClassDeclaration(ImageLocation);
GPBObjCClassDeclaration(StickerCollection);
GPBObjCClassDeclaration(StickerDescriptor);

#pragma mark - StickersRoot

@implementation StickersRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[GAPIAnnotationsRoot extensionRegistry]];
    [registry addExtensions:[DefinitionsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - StickersRoot_FileDescriptor

static GPBFileDescriptor *StickersRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"dialog"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - StickerDescriptor

@implementation StickerDescriptor

@dynamic id_p;
@dynamic hasEmoji, emoji;
@dynamic hasImage128, image128;
@dynamic hasImage512, image512;
@dynamic hasImage256, image256;
@dynamic hasAnimatedStickerJson, animatedStickerJson;

typedef struct StickerDescriptor__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  GPBStringValue *emoji;
  ImageLocation *image128;
  ImageLocation *image512;
  ImageLocation *image256;
  GPBStringValue *animatedStickerJson;
} StickerDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = StickerDescriptor_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StickerDescriptor__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "emoji",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = StickerDescriptor_FieldNumber_Emoji,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StickerDescriptor__storage_, emoji),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image128",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageLocation),
        .number = StickerDescriptor_FieldNumber_Image128,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StickerDescriptor__storage_, image128),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image512",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageLocation),
        .number = StickerDescriptor_FieldNumber_Image512,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(StickerDescriptor__storage_, image512),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image256",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageLocation),
        .number = StickerDescriptor_FieldNumber_Image256,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(StickerDescriptor__storage_, image256),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "animatedStickerJson",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = StickerDescriptor_FieldNumber_AnimatedStickerJson,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(StickerDescriptor__storage_, animatedStickerJson),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StickerDescriptor class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StickerDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\003\005\203\000\004\005\203\000\005\005\203\000\006\023\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StickerCollection

@implementation StickerCollection

@dynamic id_p;
@dynamic hasTitle, title;
@dynamic stickersArray, stickersArray_Count;
@dynamic hasOwnedByMe, ownedByMe;
@dynamic clock;

typedef struct StickerCollection__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  GPBStringValue *title;
  NSMutableArray *stickersArray;
  GPBBoolValue *ownedByMe;
  int64_t clock;
} StickerCollection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = StickerCollection_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StickerCollection__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = StickerCollection_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StickerCollection__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stickersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(StickerDescriptor),
        .number = StickerCollection_FieldNumber_StickersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StickerCollection__storage_, stickersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ownedByMe",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = StickerCollection_FieldNumber_OwnedByMe,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StickerCollection__storage_, ownedByMe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clock",
        .dataTypeSpecific.clazz = Nil,
        .number = StickerCollection_FieldNumber_Clock,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(StickerCollection__storage_, clock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StickerCollection class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StickerCollection__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseStickersResponse

@implementation ResponseStickersResponse

@dynamic collectionsArray, collectionsArray_Count;
@dynamic seq;
@dynamic state;
@dynamic removedCollectionsArray, removedCollectionsArray_Count;
@dynamic clock;
@dynamic prevClock;

typedef struct ResponseStickersResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t seq;
  NSMutableArray *collectionsArray;
  NSData *state;
  NSMutableArray *removedCollectionsArray;
  int64_t clock;
  int64_t prevClock;
} ResponseStickersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "collectionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(StickerCollection),
        .number = ResponseStickersResponse_FieldNumber_CollectionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseStickersResponse__storage_, collectionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "seq",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseStickersResponse_FieldNumber_Seq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseStickersResponse__storage_, seq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "state",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseStickersResponse_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseStickersResponse__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "removedCollectionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(StickerCollection),
        .number = ResponseStickersResponse_FieldNumber_RemovedCollectionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseStickersResponse__storage_, removedCollectionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clock",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseStickersResponse_FieldNumber_Clock,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseStickersResponse__storage_, clock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "prevClock",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseStickersResponse_FieldNumber_PrevClock,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseStickersResponse__storage_, prevClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseStickersResponse class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseStickersResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestLoadOwnStickers

@implementation RequestLoadOwnStickers

@dynamic fromClock;

typedef struct RequestLoadOwnStickers__storage_ {
  uint32_t _has_storage_[1];
  int64_t fromClock;
} RequestLoadOwnStickers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromClock",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadOwnStickers_FieldNumber_FromClock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadOwnStickers__storage_, fromClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadOwnStickers class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadOwnStickers__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseLoadOwnStickers

@implementation ResponseLoadOwnStickers

@dynamic ownStickersArray, ownStickersArray_Count;
@dynamic removedCollectionsArray, removedCollectionsArray_Count;
@dynamic clock;
@dynamic prevClock;

typedef struct ResponseLoadOwnStickers__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *ownStickersArray;
  NSMutableArray *removedCollectionsArray;
  int64_t clock;
  int64_t prevClock;
} ResponseLoadOwnStickers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ownStickersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(StickerCollection),
        .number = ResponseLoadOwnStickers_FieldNumber_OwnStickersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadOwnStickers__storage_, ownStickersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "removedCollectionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(StickerCollection),
        .number = ResponseLoadOwnStickers_FieldNumber_RemovedCollectionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadOwnStickers__storage_, removedCollectionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clock",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadOwnStickers_FieldNumber_Clock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseLoadOwnStickers__storage_, clock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "prevClock",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadOwnStickers_FieldNumber_PrevClock,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseLoadOwnStickers__storage_, prevClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadOwnStickers class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadOwnStickers__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestLoadAcesssibleStickers

@implementation RequestLoadAcesssibleStickers

@dynamic fromClock;

typedef struct RequestLoadAcesssibleStickers__storage_ {
  uint32_t _has_storage_[1];
  int64_t fromClock;
} RequestLoadAcesssibleStickers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromClock",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadAcesssibleStickers_FieldNumber_FromClock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadAcesssibleStickers__storage_, fromClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadAcesssibleStickers class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadAcesssibleStickers__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseLoadAcesssibleStickers

@implementation ResponseLoadAcesssibleStickers

@dynamic accessibleStickersArray, accessibleStickersArray_Count;
@dynamic removedCollectionsArray, removedCollectionsArray_Count;
@dynamic clock;
@dynamic prevClock;

typedef struct ResponseLoadAcesssibleStickers__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *accessibleStickersArray;
  NSMutableArray *removedCollectionsArray;
  int64_t clock;
  int64_t prevClock;
} ResponseLoadAcesssibleStickers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accessibleStickersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(StickerCollection),
        .number = ResponseLoadAcesssibleStickers_FieldNumber_AccessibleStickersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadAcesssibleStickers__storage_, accessibleStickersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "removedCollectionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(StickerCollection),
        .number = ResponseLoadAcesssibleStickers_FieldNumber_RemovedCollectionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadAcesssibleStickers__storage_, removedCollectionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clock",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadAcesssibleStickers_FieldNumber_Clock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseLoadAcesssibleStickers__storage_, clock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "prevClock",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadAcesssibleStickers_FieldNumber_PrevClock,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseLoadAcesssibleStickers__storage_, prevClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadAcesssibleStickers class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadAcesssibleStickers__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestAddStickerPackReference

@implementation RequestAddStickerPackReference

@dynamic sourceStickerPack;

typedef struct RequestAddStickerPackReference__storage_ {
  uint32_t _has_storage_[1];
  int32_t sourceStickerPack;
} RequestAddStickerPackReference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sourceStickerPack",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestAddStickerPackReference_FieldNumber_SourceStickerPack,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestAddStickerPackReference__storage_, sourceStickerPack),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestAddStickerPackReference class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestAddStickerPackReference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestRemoveStickerPackReference

@implementation RequestRemoveStickerPackReference

@dynamic sourceStickerPack;

typedef struct RequestRemoveStickerPackReference__storage_ {
  uint32_t _has_storage_[1];
  int32_t sourceStickerPack;
} RequestRemoveStickerPackReference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sourceStickerPack",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestRemoveStickerPackReference_FieldNumber_SourceStickerPack,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestRemoveStickerPackReference__storage_, sourceStickerPack),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestRemoveStickerPackReference class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestRemoveStickerPackReference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateStickerCollectionsChanged

@implementation UpdateStickerCollectionsChanged

@dynamic updatedCollectionsArray, updatedCollectionsArray_Count;

typedef struct UpdateStickerCollectionsChanged__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *updatedCollectionsArray;
} UpdateStickerCollectionsChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "updatedCollectionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(StickerCollection),
        .number = UpdateStickerCollectionsChanged_FieldNumber_UpdatedCollectionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpdateStickerCollectionsChanged__storage_, updatedCollectionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateStickerCollectionsChanged class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateStickerCollectionsChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateStickerPackRemoved

@implementation UpdateStickerPackRemoved

@dynamic packId;

typedef struct UpdateStickerPackRemoved__storage_ {
  uint32_t _has_storage_[1];
  int32_t packId;
} UpdateStickerPackRemoved__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "packId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateStickerPackRemoved_FieldNumber_PackId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateStickerPackRemoved__storage_, packId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateStickerPackRemoved class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateStickerPackRemoved__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateStickerPackAdded

@implementation UpdateStickerPackAdded

@dynamic hasPack, pack;

typedef struct UpdateStickerPackAdded__storage_ {
  uint32_t _has_storage_[1];
  StickerCollection *pack;
} UpdateStickerPackAdded__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pack",
        .dataTypeSpecific.clazz = GPBObjCClass(StickerCollection),
        .number = UpdateStickerPackAdded_FieldNumber_Pack,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateStickerPackAdded__storage_, pack),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateStickerPackAdded class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateStickerPackAdded__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestAddStickerCollection

@implementation RequestAddStickerCollection

@dynamic title;

typedef struct RequestAddStickerCollection__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
} RequestAddStickerCollection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestAddStickerCollection_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestAddStickerCollection__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestAddStickerCollection class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestAddStickerCollection__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestRemoveStickerCollection

@implementation RequestRemoveStickerCollection

@dynamic id_p;

typedef struct RequestRemoveStickerCollection__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
} RequestRemoveStickerCollection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestRemoveStickerCollection_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestRemoveStickerCollection__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestRemoveStickerCollection class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestRemoveStickerCollection__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestLoadStickerCollection

@implementation RequestLoadStickerCollection

@dynamic id_p;

typedef struct RequestLoadStickerCollection__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
} RequestLoadStickerCollection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadStickerCollection_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadStickerCollection__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadStickerCollection class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadStickerCollection__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseLoadStickerCollection

@implementation ResponseLoadStickerCollection

@dynamic hasCollection, collection;

typedef struct ResponseLoadStickerCollection__storage_ {
  uint32_t _has_storage_[1];
  StickerCollection *collection;
} ResponseLoadStickerCollection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "collection",
        .dataTypeSpecific.clazz = GPBObjCClass(StickerCollection),
        .number = ResponseLoadStickerCollection_FieldNumber_Collection,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseLoadStickerCollection__storage_, collection),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadStickerCollection class]
                                     rootClass:[StickersRoot class]
                                          file:StickersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadStickerCollection__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
