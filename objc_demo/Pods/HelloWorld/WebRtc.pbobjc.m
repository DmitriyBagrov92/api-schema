// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: web_rtc.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "WebRtc.pbobjc.h"
#import "google/api/Annotations.pbobjc.h"
#import "Definitions.pbobjc.h"
#import "Miscellaneous.pbobjc.h"
#import "Peers.pbobjc.h"
#import "DeviceInfo.pbobjc.h"
#import "scalapb/Scalapb.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AdvertiseMaster);
GPBObjCClassDeclaration(AdvertisePeer);
GPBObjCClassDeclaration(AdvertiseSelf);
GPBObjCClassDeclaration(Answer);
GPBObjCClassDeclaration(CallLogEntry);
GPBObjCClassDeclaration(CallMember);
GPBObjCClassDeclaration(CallMemberStateHolder);
GPBObjCClassDeclaration(CallNameChanged);
GPBObjCClassDeclaration(CallStats);
GPBObjCClassDeclaration(Candidate);
GPBObjCClassDeclaration(ClientInfo);
GPBObjCClassDeclaration(CloseSession);
GPBObjCClassDeclaration(DTMF);
GPBObjCClassDeclaration(EnableConnection);
GPBObjCClassDeclaration(GPBBoolValue);
GPBObjCClassDeclaration(GPBBytesValue);
GPBObjCClassDeclaration(GPBInt32Value);
GPBObjCClassDeclaration(GPBInt64Value);
GPBObjCClassDeclaration(GPBStringValue);
GPBObjCClassDeclaration(GotICECandidate);
GPBObjCClassDeclaration(GroupOutPeer);
GPBObjCClassDeclaration(ICECandidate);
GPBObjCClassDeclaration(ICEServer);
GPBObjCClassDeclaration(NeedDisconnect);
GPBObjCClassDeclaration(NeedOffer);
GPBObjCClassDeclaration(NegotinationSuccessful);
GPBObjCClassDeclaration(Offer);
GPBObjCClassDeclaration(OnRenegotiationNeeded);
GPBObjCClassDeclaration(OutPeer);
GPBObjCClassDeclaration(Peer);
GPBObjCClassDeclaration(PeerSettings);
GPBObjCClassDeclaration(RemovedICECandidates);
GPBObjCClassDeclaration(UserOutPeer);

#pragma mark - WebRtcRoot

@implementation WebRtcRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[GAPIAnnotationsRoot extensionRegistry]];
    [registry addExtensions:[DefinitionsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - WebRtcRoot_FileDescriptor

static GPBFileDescriptor *WebRtcRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"dialog"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum CallDisposedReason

GPBEnumDescriptor *CallDisposedReason_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CalldisposedreasonUnknown\000Calldisposedre"
        "asonRejected\000CalldisposedreasonBusy\000Call"
        "disposedreasonEnded\000CalldisposedreasonAn"
        "swerTimeout\000";
    static const int32_t values[] = {
        CallDisposedReason_CalldisposedreasonUnknown,
        CallDisposedReason_CalldisposedreasonRejected,
        CallDisposedReason_CalldisposedreasonBusy,
        CallDisposedReason_CalldisposedreasonEnded,
        CallDisposedReason_CalldisposedreasonAnswerTimeout,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CallDisposedReason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CallDisposedReason_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CallDisposedReason_IsValidValue(int32_t value__) {
  switch (value__) {
    case CallDisposedReason_CalldisposedreasonUnknown:
    case CallDisposedReason_CalldisposedreasonRejected:
    case CallDisposedReason_CalldisposedreasonBusy:
    case CallDisposedReason_CalldisposedreasonEnded:
    case CallDisposedReason_CalldisposedreasonAnswerTimeout:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RejectCallReason

GPBEnumDescriptor *RejectCallReason_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RejectcallreasonUnknown\000Rejectcallreason"
        "Decline\000RejectcallreasonBusy\000";
    static const int32_t values[] = {
        RejectCallReason_RejectcallreasonUnknown,
        RejectCallReason_RejectcallreasonDecline,
        RejectCallReason_RejectcallreasonBusy,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RejectCallReason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RejectCallReason_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RejectCallReason_IsValidValue(int32_t value__) {
  switch (value__) {
    case RejectCallReason_RejectcallreasonUnknown:
    case RejectCallReason_RejectcallreasonDecline:
    case RejectCallReason_RejectcallreasonBusy:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum DTMFCode

GPBEnumDescriptor *DTMFCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DtmfcodeUnknown\000DtmfcodeZero\000DtmfcodeOne"
        "\000DtmfcodeTwo\000DtmfcodeThree\000DtmfcodeFour\000"
        "DtmfcodeFive\000DtmfcodeSix\000DtmfcodeSeven\000D"
        "tmfcodeEight\000DtmfcodeNine\000DtmfcodeAsteri"
        "sk\000DtmfcodePound\000DtmfcodeA\000DtmfcodeB\000Dtm"
        "fcodeC\000DtmfcodeD\000";
    static const int32_t values[] = {
        DTMFCode_DtmfcodeUnknown,
        DTMFCode_DtmfcodeZero,
        DTMFCode_DtmfcodeOne,
        DTMFCode_DtmfcodeTwo,
        DTMFCode_DtmfcodeThree,
        DTMFCode_DtmfcodeFour,
        DTMFCode_DtmfcodeFive,
        DTMFCode_DtmfcodeSix,
        DTMFCode_DtmfcodeSeven,
        DTMFCode_DtmfcodeEight,
        DTMFCode_DtmfcodeNine,
        DTMFCode_DtmfcodeAsterisk,
        DTMFCode_DtmfcodePound,
        DTMFCode_DtmfcodeA,
        DTMFCode_DtmfcodeB,
        DTMFCode_DtmfcodeC,
        DTMFCode_DtmfcodeD,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DTMFCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DTMFCode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DTMFCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case DTMFCode_DtmfcodeUnknown:
    case DTMFCode_DtmfcodeZero:
    case DTMFCode_DtmfcodeOne:
    case DTMFCode_DtmfcodeTwo:
    case DTMFCode_DtmfcodeThree:
    case DTMFCode_DtmfcodeFour:
    case DTMFCode_DtmfcodeFive:
    case DTMFCode_DtmfcodeSix:
    case DTMFCode_DtmfcodeSeven:
    case DTMFCode_DtmfcodeEight:
    case DTMFCode_DtmfcodeNine:
    case DTMFCode_DtmfcodeAsterisk:
    case DTMFCode_DtmfcodePound:
    case DTMFCode_DtmfcodeA:
    case DTMFCode_DtmfcodeB:
    case DTMFCode_DtmfcodeC:
    case DTMFCode_DtmfcodeD:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CallStatsType

GPBEnumDescriptor *CallStatsType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CallstatstypeUnknown\000CallstatstypeTurnSe"
        "rverRoundTripTime\000CallstatstypeIceConnec"
        "tionFailed\000CallstatstypeIceConnectionCon"
        "nected\000CallstatstypeIceConnectionDidNotC"
        "onnect\000CallstatstypeIceConnectionConnect"
        "edTime\000CallstatstypePeerConnectionCreate"
        "AnswerFailed\000CallstatstypePeerConnection"
        "CreateOfferFailed\000CallstatstypePeerConne"
        "ctionSetRemoteDescriptionFailed\000Callstat"
        "stypePeerConnectionSetLocalDescriptionFa"
        "iled\000";
    static const int32_t values[] = {
        CallStatsType_CallstatstypeUnknown,
        CallStatsType_CallstatstypeTurnServerRoundTripTime,
        CallStatsType_CallstatstypeIceConnectionFailed,
        CallStatsType_CallstatstypeIceConnectionConnected,
        CallStatsType_CallstatstypeIceConnectionDidNotConnect,
        CallStatsType_CallstatstypeIceConnectionConnectedTime,
        CallStatsType_CallstatstypePeerConnectionCreateAnswerFailed,
        CallStatsType_CallstatstypePeerConnectionCreateOfferFailed,
        CallStatsType_CallstatstypePeerConnectionSetRemoteDescriptionFailed,
        CallStatsType_CallstatstypePeerConnectionSetLocalDescriptionFailed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CallStatsType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CallStatsType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CallStatsType_IsValidValue(int32_t value__) {
  switch (value__) {
    case CallStatsType_CallstatstypeUnknown:
    case CallStatsType_CallstatstypeTurnServerRoundTripTime:
    case CallStatsType_CallstatstypeIceConnectionFailed:
    case CallStatsType_CallstatstypeIceConnectionConnected:
    case CallStatsType_CallstatstypeIceConnectionDidNotConnect:
    case CallStatsType_CallstatstypeIceConnectionConnectedTime:
    case CallStatsType_CallstatstypePeerConnectionCreateAnswerFailed:
    case CallStatsType_CallstatstypePeerConnectionCreateOfferFailed:
    case CallStatsType_CallstatstypePeerConnectionSetRemoteDescriptionFailed:
    case CallStatsType_CallstatstypePeerConnectionSetLocalDescriptionFailed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CallMemberState

GPBEnumDescriptor *CallMemberState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CallmemberstateUnknown\000CallmemberstateRi"
        "nging\000CallmemberstateRingingReached\000Call"
        "memberstateConnecting\000CallmemberstateCon"
        "nected\000CallmemberstateEnded\000";
    static const int32_t values[] = {
        CallMemberState_CallmemberstateUnknown,
        CallMemberState_CallmemberstateRinging,
        CallMemberState_CallmemberstateRingingReached,
        CallMemberState_CallmemberstateConnecting,
        CallMemberState_CallmemberstateConnected,
        CallMemberState_CallmemberstateEnded,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CallMemberState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CallMemberState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CallMemberState_IsValidValue(int32_t value__) {
  switch (value__) {
    case CallMemberState_CallmemberstateUnknown:
    case CallMemberState_CallmemberstateRinging:
    case CallMemberState_CallmemberstateRingingReached:
    case CallMemberState_CallmemberstateConnecting:
    case CallMemberState_CallmemberstateConnected:
    case CallMemberState_CallmemberstateEnded:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UpdateIncomingCallDeprecated

@implementation UpdateIncomingCallDeprecated

@dynamic callId;
@dynamic hasAttemptIndex, attemptIndex;

typedef struct UpdateIncomingCallDeprecated__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Value *attemptIndex;
  int64_t callId;
} UpdateIncomingCallDeprecated__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateIncomingCallDeprecated_FieldNumber_CallId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateIncomingCallDeprecated__storage_, callId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "attemptIndex",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateIncomingCallDeprecated_FieldNumber_AttemptIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateIncomingCallDeprecated__storage_, attemptIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateIncomingCallDeprecated class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateIncomingCallDeprecated__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateIncomingCall

@implementation UpdateIncomingCall

@dynamic callId;
@dynamic eventBusId;
@dynamic hasPeer, peer;
@dynamic hasDisplayName, displayName;
@dynamic hasAttemptIndex, attemptIndex;
@dynamic hasOutPeer, outPeer;
@dynamic video;

typedef struct UpdateIncomingCall__storage_ {
  uint32_t _has_storage_[1];
  NSString *eventBusId;
  Peer *peer;
  GPBStringValue *displayName;
  GPBInt32Value *attemptIndex;
  OutPeer *outPeer;
  int64_t callId;
} UpdateIncomingCall__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateIncomingCall_FieldNumber_CallId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateIncomingCall__storage_, callId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "eventBusId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateIncomingCall_FieldNumber_EventBusId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateIncomingCall__storage_, eventBusId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateIncomingCall_FieldNumber_Peer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateIncomingCall__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = UpdateIncomingCall_FieldNumber_DisplayName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateIncomingCall__storage_, displayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attemptIndex",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateIncomingCall_FieldNumber_AttemptIndex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateIncomingCall__storage_, attemptIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outPeer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = UpdateIncomingCall_FieldNumber_OutPeer,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UpdateIncomingCall__storage_, outPeer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateIncomingCall_FieldNumber_Video,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateIncomingCall class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateIncomingCall__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateCallHandled

@implementation UpdateCallHandled

@dynamic callId;
@dynamic hasAttemptIndex, attemptIndex;

typedef struct UpdateCallHandled__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Value *attemptIndex;
  int64_t callId;
} UpdateCallHandled__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateCallHandled_FieldNumber_CallId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateCallHandled__storage_, callId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "attemptIndex",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateCallHandled_FieldNumber_AttemptIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateCallHandled__storage_, attemptIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateCallHandled class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateCallHandled__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateCallDisposed

@implementation UpdateCallDisposed

@dynamic callId;
@dynamic hasAttemptIndex, attemptIndex;
@dynamic reason;

typedef struct UpdateCallDisposed__storage_ {
  uint32_t _has_storage_[1];
  CallDisposedReason reason;
  GPBInt32Value *attemptIndex;
  int64_t callId;
} UpdateCallDisposed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateCallDisposed_FieldNumber_CallId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateCallDisposed__storage_, callId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "attemptIndex",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateCallDisposed_FieldNumber_AttemptIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateCallDisposed__storage_, attemptIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reason",
        .dataTypeSpecific.enumDescFunc = CallDisposedReason_EnumDescriptor,
        .number = UpdateCallDisposed_FieldNumber_Reason,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateCallDisposed__storage_, reason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateCallDisposed class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateCallDisposed__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UpdateCallDisposed_Reason_RawValue(UpdateCallDisposed *message) {
  GPBDescriptor *descriptor = [UpdateCallDisposed descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpdateCallDisposed_FieldNumber_Reason];
  return GPBGetMessageRawEnumField(message, field);
}

void SetUpdateCallDisposed_Reason_RawValue(UpdateCallDisposed *message, int32_t value) {
  GPBDescriptor *descriptor = [UpdateCallDisposed descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpdateCallDisposed_FieldNumber_Reason];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - RequestGetCallInfo

@implementation RequestGetCallInfo

@dynamic callId;

typedef struct RequestGetCallInfo__storage_ {
  uint32_t _has_storage_[1];
  int64_t callId;
} RequestGetCallInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestGetCallInfo_FieldNumber_CallId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestGetCallInfo__storage_, callId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestGetCallInfo class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestGetCallInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetCallInfo

@implementation ResponseGetCallInfo

@dynamic hasPeer, peer;
@dynamic groupsArray, groupsArray_Count;
@dynamic usersArray, usersArray_Count;
@dynamic eventBusId;
@dynamic hasDisplayName, displayName;

typedef struct ResponseGetCallInfo__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSMutableArray *groupsArray;
  NSMutableArray *usersArray;
  NSString *eventBusId;
  GPBStringValue *displayName;
} ResponseGetCallInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = ResponseGetCallInfo_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseGetCallInfo__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupOutPeer),
        .number = ResponseGetCallInfo_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseGetCallInfo__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "usersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOutPeer),
        .number = ResponseGetCallInfo_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseGetCallInfo__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "eventBusId",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseGetCallInfo_FieldNumber_EventBusId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseGetCallInfo__storage_, eventBusId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = ResponseGetCallInfo_FieldNumber_DisplayName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseGetCallInfo__storage_, displayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetCallInfo class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetCallInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CallLogEntry

@implementation CallLogEntry

@dynamic id_p;
@dynamic callDate;
@dynamic hasInitiator, initiator;
@dynamic hasRecipient, recipient;
@dynamic hasDuration, duration;
@dynamic hasAnswered, answered;
@dynamic hasFinished, finished;
@dynamic hasDisplayName, displayName;
@dynamic hasRejected, rejected;

typedef struct CallLogEntry__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *initiator;
  OutPeer *recipient;
  GPBInt64Value *duration;
  GPBBoolValue *answered;
  GPBBoolValue *finished;
  GPBStringValue *displayName;
  GPBBoolValue *rejected;
  int64_t id_p;
  int64_t callDate;
} CallLogEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = CallLogEntry_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CallLogEntry__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "callDate",
        .dataTypeSpecific.clazz = Nil,
        .number = CallLogEntry_FieldNumber_CallDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CallLogEntry__storage_, callDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "initiator",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = CallLogEntry_FieldNumber_Initiator,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CallLogEntry__storage_, initiator),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recipient",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = CallLogEntry_FieldNumber_Recipient,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CallLogEntry__storage_, recipient),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = CallLogEntry_FieldNumber_Duration,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CallLogEntry__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "answered",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = CallLogEntry_FieldNumber_Answered,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CallLogEntry__storage_, answered),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "finished",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = CallLogEntry_FieldNumber_Finished,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CallLogEntry__storage_, finished),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = CallLogEntry_FieldNumber_DisplayName,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(CallLogEntry__storage_, displayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rejected",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = CallLogEntry_FieldNumber_Rejected,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(CallLogEntry__storage_, rejected),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CallLogEntry class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CallLogEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestLoadCalls

@implementation RequestLoadCalls

@dynamic hasNextOffset, nextOffset;
@dynamic limit;

typedef struct RequestLoadCalls__storage_ {
  uint32_t _has_storage_[1];
  int32_t limit;
  GPBBytesValue *nextOffset;
} RequestLoadCalls__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nextOffset",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBytesValue),
        .number = RequestLoadCalls_FieldNumber_NextOffset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadCalls__storage_, nextOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadCalls_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestLoadCalls__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadCalls class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadCalls__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseLoadCalls

@implementation ResponseLoadCalls

@dynamic callsArray, callsArray_Count;
@dynamic usersArray, usersArray_Count;
@dynamic groupsArray, groupsArray_Count;
@dynamic hasNextOffset, nextOffset;

typedef struct ResponseLoadCalls__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *callsArray;
  NSMutableArray *usersArray;
  NSMutableArray *groupsArray;
  GPBBytesValue *nextOffset;
} ResponseLoadCalls__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(CallLogEntry),
        .number = ResponseLoadCalls_FieldNumber_CallsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadCalls__storage_, callsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "usersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOutPeer),
        .number = ResponseLoadCalls_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadCalls__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupOutPeer),
        .number = ResponseLoadCalls_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadCalls__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextOffset",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBytesValue),
        .number = ResponseLoadCalls_FieldNumber_NextOffset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseLoadCalls__storage_, nextOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadCalls class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadCalls__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestDoCall

@implementation RequestDoCall

@dynamic hasPeer, peer;
@dynamic timeout;

typedef struct RequestDoCall__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  int64_t timeout;
} RequestDoCall__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestDoCall_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestDoCall__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timeout",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestDoCall_FieldNumber_Timeout,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestDoCall__storage_, timeout),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestDoCall class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestDoCall__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseDoCall

@implementation ResponseDoCall

@dynamic callId;
@dynamic eventBusId;
@dynamic deviceId;

typedef struct ResponseDoCall__storage_ {
  uint32_t _has_storage_[1];
  NSString *eventBusId;
  int64_t callId;
  int64_t deviceId;
} ResponseDoCall__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callId",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseDoCall_FieldNumber_CallId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseDoCall__storage_, callId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "eventBusId",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseDoCall_FieldNumber_EventBusId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseDoCall__storage_, eventBusId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseDoCall_FieldNumber_DeviceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseDoCall__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseDoCall class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseDoCall__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestJoinCall

@implementation RequestJoinCall

@dynamic callId;

typedef struct RequestJoinCall__storage_ {
  uint32_t _has_storage_[1];
  int64_t callId;
} RequestJoinCall__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestJoinCall_FieldNumber_CallId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestJoinCall__storage_, callId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestJoinCall class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestJoinCall__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestRejectCall

@implementation RequestRejectCall

@dynamic callId;
@dynamic reason;

typedef struct RequestRejectCall__storage_ {
  uint32_t _has_storage_[1];
  RejectCallReason reason;
  int64_t callId;
} RequestRejectCall__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestRejectCall_FieldNumber_CallId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestRejectCall__storage_, callId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "reason",
        .dataTypeSpecific.enumDescFunc = RejectCallReason_EnumDescriptor,
        .number = RequestRejectCall_FieldNumber_Reason,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestRejectCall__storage_, reason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestRejectCall class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestRejectCall__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RequestRejectCall_Reason_RawValue(RequestRejectCall *message) {
  GPBDescriptor *descriptor = [RequestRejectCall descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestRejectCall_FieldNumber_Reason];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRequestRejectCall_Reason_RawValue(RequestRejectCall *message, int32_t value) {
  GPBDescriptor *descriptor = [RequestRejectCall descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestRejectCall_FieldNumber_Reason];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - RequestDeleteCall

@implementation RequestDeleteCall

@dynamic callId;

typedef struct RequestDeleteCall__storage_ {
  uint32_t _has_storage_[1];
  int64_t callId;
} RequestDeleteCall__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestDeleteCall_FieldNumber_CallId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestDeleteCall__storage_, callId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestDeleteCall class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestDeleteCall__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestChangeCallDisplayName

@implementation RequestChangeCallDisplayName

@dynamic callId;
@dynamic hasDisplayName, displayName;

typedef struct RequestChangeCallDisplayName__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *displayName;
  int64_t callId;
} RequestChangeCallDisplayName__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestChangeCallDisplayName_FieldNumber_CallId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestChangeCallDisplayName__storage_, callId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestChangeCallDisplayName_FieldNumber_DisplayName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestChangeCallDisplayName__storage_, displayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestChangeCallDisplayName class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestChangeCallDisplayName__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ICEServer

@implementation ICEServer

@dynamic URL;
@dynamic hasUsername, username;
@dynamic hasCredential, credential;

typedef struct ICEServer__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  GPBStringValue *username;
  GPBStringValue *credential;
} ICEServer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = ICEServer_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ICEServer__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = ICEServer_FieldNumber_Username,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ICEServer__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "credential",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = ICEServer_FieldNumber_Credential,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ICEServer__storage_, credential),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ICEServer class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ICEServer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ICECandidate

@implementation ICECandidate

@dynamic sdpMLineIndex;
@dynamic sdpMid;
@dynamic sdp;

typedef struct ICECandidate__storage_ {
  uint32_t _has_storage_[1];
  int32_t sdpMLineIndex;
  NSString *sdpMid;
  NSString *sdp;
} ICECandidate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sdpMLineIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = ICECandidate_FieldNumber_SdpMLineIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ICECandidate__storage_, sdpMLineIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sdpMid",
        .dataTypeSpecific.clazz = Nil,
        .number = ICECandidate_FieldNumber_SdpMid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ICECandidate__storage_, sdpMid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sdp",
        .dataTypeSpecific.clazz = Nil,
        .number = ICECandidate_FieldNumber_Sdp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ICECandidate__storage_, sdp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ICECandidate class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ICECandidate__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WebRTCSignaling

@implementation WebRTCSignaling

@dynamic bodyOneOfCase;
@dynamic advertiseSelf;
@dynamic advertiseMaster;
@dynamic advertisePeer;
@dynamic candidate;
@dynamic gotIcecandidate;
@dynamic removedIcecandidates;
@dynamic offer;
@dynamic answer;
@dynamic needOffer;
@dynamic negotinationSuccessful;
@dynamic enableConnection;
@dynamic onRenegotiationNeeded;
@dynamic closeSession;
@dynamic needDisconnect;
@dynamic dTmf;
@dynamic callStats;
@dynamic callNameChanged;

typedef struct WebRTCSignaling__storage_ {
  uint32_t _has_storage_[2];
  AdvertiseSelf *advertiseSelf;
  AdvertiseMaster *advertiseMaster;
  AdvertisePeer *advertisePeer;
  Candidate *candidate;
  GotICECandidate *gotIcecandidate;
  RemovedICECandidates *removedIcecandidates;
  Offer *offer;
  Answer *answer;
  NeedOffer *needOffer;
  NegotinationSuccessful *negotinationSuccessful;
  EnableConnection *enableConnection;
  OnRenegotiationNeeded *onRenegotiationNeeded;
  CloseSession *closeSession;
  NeedDisconnect *needDisconnect;
  DTMF *dTmf;
  CallStats *callStats;
  CallNameChanged *callNameChanged;
} WebRTCSignaling__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "advertiseSelf",
        .dataTypeSpecific.clazz = GPBObjCClass(AdvertiseSelf),
        .number = WebRTCSignaling_FieldNumber_AdvertiseSelf,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, advertiseSelf),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "advertiseMaster",
        .dataTypeSpecific.clazz = GPBObjCClass(AdvertiseMaster),
        .number = WebRTCSignaling_FieldNumber_AdvertiseMaster,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, advertiseMaster),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "advertisePeer",
        .dataTypeSpecific.clazz = GPBObjCClass(AdvertisePeer),
        .number = WebRTCSignaling_FieldNumber_AdvertisePeer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, advertisePeer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "candidate",
        .dataTypeSpecific.clazz = GPBObjCClass(Candidate),
        .number = WebRTCSignaling_FieldNumber_Candidate,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, candidate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gotIcecandidate",
        .dataTypeSpecific.clazz = GPBObjCClass(GotICECandidate),
        .number = WebRTCSignaling_FieldNumber_GotIcecandidate,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, gotIcecandidate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "removedIcecandidates",
        .dataTypeSpecific.clazz = GPBObjCClass(RemovedICECandidates),
        .number = WebRTCSignaling_FieldNumber_RemovedIcecandidates,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, removedIcecandidates),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offer",
        .dataTypeSpecific.clazz = GPBObjCClass(Offer),
        .number = WebRTCSignaling_FieldNumber_Offer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, offer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "answer",
        .dataTypeSpecific.clazz = GPBObjCClass(Answer),
        .number = WebRTCSignaling_FieldNumber_Answer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, answer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "needOffer",
        .dataTypeSpecific.clazz = GPBObjCClass(NeedOffer),
        .number = WebRTCSignaling_FieldNumber_NeedOffer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, needOffer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "negotinationSuccessful",
        .dataTypeSpecific.clazz = GPBObjCClass(NegotinationSuccessful),
        .number = WebRTCSignaling_FieldNumber_NegotinationSuccessful,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, negotinationSuccessful),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "enableConnection",
        .dataTypeSpecific.clazz = GPBObjCClass(EnableConnection),
        .number = WebRTCSignaling_FieldNumber_EnableConnection,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, enableConnection),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "onRenegotiationNeeded",
        .dataTypeSpecific.clazz = GPBObjCClass(OnRenegotiationNeeded),
        .number = WebRTCSignaling_FieldNumber_OnRenegotiationNeeded,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, onRenegotiationNeeded),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "closeSession",
        .dataTypeSpecific.clazz = GPBObjCClass(CloseSession),
        .number = WebRTCSignaling_FieldNumber_CloseSession,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, closeSession),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "needDisconnect",
        .dataTypeSpecific.clazz = GPBObjCClass(NeedDisconnect),
        .number = WebRTCSignaling_FieldNumber_NeedDisconnect,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, needDisconnect),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dTmf",
        .dataTypeSpecific.clazz = GPBObjCClass(DTMF),
        .number = WebRTCSignaling_FieldNumber_DTmf,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, dTmf),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "callStats",
        .dataTypeSpecific.clazz = GPBObjCClass(CallStats),
        .number = WebRTCSignaling_FieldNumber_CallStats,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, callStats),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "callNameChanged",
        .dataTypeSpecific.clazz = GPBObjCClass(CallNameChanged),
        .number = WebRTCSignaling_FieldNumber_CallNameChanged,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebRTCSignaling__storage_, callNameChanged),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WebRTCSignaling class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WebRTCSignaling__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\016\001\r\000\002\017\000\003\r\000\005\004c\010\000\006\010c\t\000\t\t\000\n\026\000\013\020\000\014\025\000\r\014\000\016\016\000\017\002"
        "b\000\020\t\000\021\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void WebRTCSignaling_ClearBodyOneOfCase(WebRTCSignaling *message) {
  GPBDescriptor *descriptor = [WebRTCSignaling descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - AdvertiseSelf

@implementation AdvertiseSelf

@dynamic hasPeerSettings, peerSettings;

typedef struct AdvertiseSelf__storage_ {
  uint32_t _has_storage_[1];
  PeerSettings *peerSettings;
} AdvertiseSelf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerSettings",
        .dataTypeSpecific.clazz = GPBObjCClass(PeerSettings),
        .number = AdvertiseSelf_FieldNumber_PeerSettings,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AdvertiseSelf__storage_, peerSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AdvertiseSelf class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AdvertiseSelf__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AdvertiseMaster

@implementation AdvertiseMaster

@dynamic serverArray, serverArray_Count;
@dynamic hasCallApiVersion, callApiVersion;
@dynamic hasCallName, callName;

typedef struct AdvertiseMaster__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *serverArray;
  GPBInt32Value *callApiVersion;
  GPBStringValue *callName;
} AdvertiseMaster__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "serverArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ICEServer),
        .number = AdvertiseMaster_FieldNumber_ServerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AdvertiseMaster__storage_, serverArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "callApiVersion",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = AdvertiseMaster_FieldNumber_CallApiVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AdvertiseMaster__storage_, callApiVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "callName",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = AdvertiseMaster_FieldNumber_CallName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AdvertiseMaster__storage_, callName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AdvertiseMaster class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AdvertiseMaster__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AdvertisePeer

@implementation AdvertisePeer

@dynamic deviceId;
@dynamic hasPeerSettings, peerSettings;
@dynamic iceServersArray, iceServersArray_Count;

typedef struct AdvertisePeer__storage_ {
  uint32_t _has_storage_[1];
  PeerSettings *peerSettings;
  NSMutableArray *iceServersArray;
  int64_t deviceId;
} AdvertisePeer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = AdvertisePeer_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AdvertisePeer__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "peerSettings",
        .dataTypeSpecific.clazz = GPBObjCClass(PeerSettings),
        .number = AdvertisePeer_FieldNumber_PeerSettings,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AdvertisePeer__storage_, peerSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "iceServersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ICEServer),
        .number = AdvertisePeer_FieldNumber_IceServersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AdvertisePeer__storage_, iceServersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AdvertisePeer class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AdvertisePeer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Candidate

@implementation Candidate

@dynamic sessionId;
@dynamic index;
@dynamic id_p;
@dynamic sdp;

typedef struct Candidate__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  NSString *id_p;
  NSString *sdp;
  int64_t sessionId;
} Candidate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = Candidate_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Candidate__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = Candidate_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Candidate__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Candidate_FieldNumber_Id_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Candidate__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sdp",
        .dataTypeSpecific.clazz = Nil,
        .number = Candidate_FieldNumber_Sdp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Candidate__storage_, sdp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Candidate class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Candidate__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GotICECandidate

@implementation GotICECandidate

@dynamic sessionId;
@dynamic hasCandidate, candidate;

typedef struct GotICECandidate__storage_ {
  uint32_t _has_storage_[1];
  ICECandidate *candidate;
  int64_t sessionId;
} GotICECandidate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = GotICECandidate_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GotICECandidate__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "candidate",
        .dataTypeSpecific.clazz = GPBObjCClass(ICECandidate),
        .number = GotICECandidate_FieldNumber_Candidate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GotICECandidate__storage_, candidate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GotICECandidate class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GotICECandidate__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemovedICECandidates

@implementation RemovedICECandidates

@dynamic sessionId;
@dynamic candidateArray, candidateArray_Count;

typedef struct RemovedICECandidates__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *candidateArray;
  int64_t sessionId;
} RemovedICECandidates__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = RemovedICECandidates_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemovedICECandidates__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "candidateArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ICECandidate),
        .number = RemovedICECandidates_FieldNumber_CandidateArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RemovedICECandidates__storage_, candidateArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemovedICECandidates class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemovedICECandidates__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Offer

@implementation Offer

@dynamic sessionId;
@dynamic sdp;
@dynamic hasPeerSettings, peerSettings;

typedef struct Offer__storage_ {
  uint32_t _has_storage_[1];
  NSString *sdp;
  PeerSettings *peerSettings;
  int64_t sessionId;
} Offer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = Offer_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Offer__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sdp",
        .dataTypeSpecific.clazz = Nil,
        .number = Offer_FieldNumber_Sdp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Offer__storage_, sdp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "peerSettings",
        .dataTypeSpecific.clazz = GPBObjCClass(PeerSettings),
        .number = Offer_FieldNumber_PeerSettings,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Offer__storage_, peerSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Offer class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Offer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Answer

@implementation Answer

@dynamic sessionId;
@dynamic sdp;

typedef struct Answer__storage_ {
  uint32_t _has_storage_[1];
  NSString *sdp;
  int64_t sessionId;
} Answer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = Answer_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Answer__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sdp",
        .dataTypeSpecific.clazz = Nil,
        .number = Answer_FieldNumber_Sdp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Answer__storage_, sdp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Answer class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Answer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NeedOffer

@implementation NeedOffer

@dynamic device;
@dynamic sessionId;
@dynamic hasPeerSettings, peerSettings;

typedef struct NeedOffer__storage_ {
  uint32_t _has_storage_[1];
  PeerSettings *peerSettings;
  int64_t device;
  int64_t sessionId;
} NeedOffer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "device",
        .dataTypeSpecific.clazz = Nil,
        .number = NeedOffer_FieldNumber_Device,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NeedOffer__storage_, device),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = NeedOffer_FieldNumber_SessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NeedOffer__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "peerSettings",
        .dataTypeSpecific.clazz = GPBObjCClass(PeerSettings),
        .number = NeedOffer_FieldNumber_PeerSettings,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NeedOffer__storage_, peerSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NeedOffer class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NeedOffer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NegotinationSuccessful

@implementation NegotinationSuccessful

@dynamic device;
@dynamic sessionId;

typedef struct NegotinationSuccessful__storage_ {
  uint32_t _has_storage_[1];
  int64_t device;
  int64_t sessionId;
} NegotinationSuccessful__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "device",
        .dataTypeSpecific.clazz = Nil,
        .number = NegotinationSuccessful_FieldNumber_Device,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NegotinationSuccessful__storage_, device),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = NegotinationSuccessful_FieldNumber_SessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NegotinationSuccessful__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NegotinationSuccessful class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NegotinationSuccessful__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnableConnection

@implementation EnableConnection

@dynamic device;
@dynamic sessionId;

typedef struct EnableConnection__storage_ {
  uint32_t _has_storage_[1];
  int64_t device;
  int64_t sessionId;
} EnableConnection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "device",
        .dataTypeSpecific.clazz = Nil,
        .number = EnableConnection_FieldNumber_Device,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EnableConnection__storage_, device),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = EnableConnection_FieldNumber_SessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EnableConnection__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnableConnection class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnableConnection__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OnRenegotiationNeeded

@implementation OnRenegotiationNeeded

@dynamic device;
@dynamic sessionId;

typedef struct OnRenegotiationNeeded__storage_ {
  uint32_t _has_storage_[1];
  int64_t device;
  int64_t sessionId;
} OnRenegotiationNeeded__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "device",
        .dataTypeSpecific.clazz = Nil,
        .number = OnRenegotiationNeeded_FieldNumber_Device,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OnRenegotiationNeeded__storage_, device),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnRenegotiationNeeded_FieldNumber_SessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OnRenegotiationNeeded__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OnRenegotiationNeeded class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OnRenegotiationNeeded__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CloseSession

@implementation CloseSession

@dynamic device;
@dynamic sessionId;

typedef struct CloseSession__storage_ {
  uint32_t _has_storage_[1];
  int64_t device;
  int64_t sessionId;
} CloseSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "device",
        .dataTypeSpecific.clazz = Nil,
        .number = CloseSession_FieldNumber_Device,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CloseSession__storage_, device),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = CloseSession_FieldNumber_SessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CloseSession__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CloseSession class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CloseSession__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NeedDisconnect

@implementation NeedDisconnect

@dynamic device;

typedef struct NeedDisconnect__storage_ {
  uint32_t _has_storage_[1];
  int64_t device;
} NeedDisconnect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "device",
        .dataTypeSpecific.clazz = Nil,
        .number = NeedDisconnect_FieldNumber_Device,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NeedDisconnect__storage_, device),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NeedDisconnect class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NeedDisconnect__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DTMF

@implementation DTMF

@dynamic code;
@dynamic duration;

typedef struct DTMF__storage_ {
  uint32_t _has_storage_[1];
  DTMFCode code;
  int64_t duration;
} DTMF__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = DTMFCode_EnumDescriptor,
        .number = DTMF_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DTMF__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = DTMF_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DTMF__storage_, duration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DTMF class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DTMF__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DTMF_Code_RawValue(DTMF *message) {
  GPBDescriptor *descriptor = [DTMF descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DTMF_FieldNumber_Code];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDTMF_Code_RawValue(DTMF *message, int32_t value) {
  GPBDescriptor *descriptor = [DTMF descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DTMF_FieldNumber_Code];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - CallStats

@implementation CallStats

@dynamic type;
@dynamic value;

typedef struct CallStats__storage_ {
  uint32_t _has_storage_[1];
  CallStatsType type;
  NSString *value;
} CallStats__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = CallStatsType_EnumDescriptor,
        .number = CallStats_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CallStats__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = CallStats_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CallStats__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CallStats class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CallStats__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CallStats_Type_RawValue(CallStats *message) {
  GPBDescriptor *descriptor = [CallStats descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CallStats_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetCallStats_Type_RawValue(CallStats *message, int32_t value) {
  GPBDescriptor *descriptor = [CallStats descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CallStats_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - CallNameChanged

@implementation CallNameChanged

@dynamic hasCallName, callName;

typedef struct CallNameChanged__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *callName;
} CallNameChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callName",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = CallNameChanged_FieldNumber_CallName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CallNameChanged__storage_, callName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CallNameChanged class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CallNameChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ActiveCall

@implementation ActiveCall

@dynamic callId;
@dynamic hasPeer, peer;
@dynamic callMembersArray, callMembersArray_Count;

typedef struct ActiveCall__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSMutableArray *callMembersArray;
  int64_t callId;
} ActiveCall__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callId",
        .dataTypeSpecific.clazz = Nil,
        .number = ActiveCall_FieldNumber_CallId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ActiveCall__storage_, callId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = ActiveCall_FieldNumber_Peer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ActiveCall__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "callMembersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(CallMember),
        .number = ActiveCall_FieldNumber_CallMembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ActiveCall__storage_, callMembersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ActiveCall class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ActiveCall__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CallMemberStateHolder

@implementation CallMemberStateHolder

@dynamic state;
@dynamic hasFallbackIsRinging, fallbackIsRinging;
@dynamic hasFallbackIsConnected, fallbackIsConnected;
@dynamic hasFallbackIsConnecting, fallbackIsConnecting;
@dynamic hasFallbackIsRingingReached, fallbackIsRingingReached;
@dynamic hasFallbackIsEnded, fallbackIsEnded;

typedef struct CallMemberStateHolder__storage_ {
  uint32_t _has_storage_[1];
  CallMemberState state;
  GPBBoolValue *fallbackIsRinging;
  GPBBoolValue *fallbackIsConnected;
  GPBBoolValue *fallbackIsConnecting;
  GPBBoolValue *fallbackIsRingingReached;
  GPBBoolValue *fallbackIsEnded;
} CallMemberStateHolder__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = CallMemberState_EnumDescriptor,
        .number = CallMemberStateHolder_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CallMemberStateHolder__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fallbackIsRinging",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = CallMemberStateHolder_FieldNumber_FallbackIsRinging,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CallMemberStateHolder__storage_, fallbackIsRinging),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fallbackIsConnected",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = CallMemberStateHolder_FieldNumber_FallbackIsConnected,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CallMemberStateHolder__storage_, fallbackIsConnected),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fallbackIsConnecting",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = CallMemberStateHolder_FieldNumber_FallbackIsConnecting,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CallMemberStateHolder__storage_, fallbackIsConnecting),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fallbackIsRingingReached",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = CallMemberStateHolder_FieldNumber_FallbackIsRingingReached,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CallMemberStateHolder__storage_, fallbackIsRingingReached),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fallbackIsEnded",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = CallMemberStateHolder_FieldNumber_FallbackIsEnded,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CallMemberStateHolder__storage_, fallbackIsEnded),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CallMemberStateHolder class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CallMemberStateHolder__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CallMemberStateHolder_State_RawValue(CallMemberStateHolder *message) {
  GPBDescriptor *descriptor = [CallMemberStateHolder descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CallMemberStateHolder_FieldNumber_State];
  return GPBGetMessageRawEnumField(message, field);
}

void SetCallMemberStateHolder_State_RawValue(CallMemberStateHolder *message, int32_t value) {
  GPBDescriptor *descriptor = [CallMemberStateHolder descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CallMemberStateHolder_FieldNumber_State];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - CallMember

@implementation CallMember

@dynamic userId;
@dynamic hasState, state;

typedef struct CallMember__storage_ {
  uint32_t _has_storage_[1];
  int32_t userId;
  CallMemberStateHolder *state;
} CallMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = CallMember_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CallMember__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "state",
        .dataTypeSpecific.clazz = GPBObjCClass(CallMemberStateHolder),
        .number = CallMember_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CallMember__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CallMember class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CallMember__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerSettings

@implementation PeerSettings

@dynamic hasCanPreConnect, canPreConnect;
@dynamic hasSendsOffer, sendsOffer;
@dynamic hasWaitForCandidates, waitForCandidates;
@dynamic hasClientInfo, clientInfo;

typedef struct PeerSettings__storage_ {
  uint32_t _has_storage_[1];
  GPBBoolValue *canPreConnect;
  GPBBoolValue *sendsOffer;
  GPBBoolValue *waitForCandidates;
  ClientInfo *clientInfo;
} PeerSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "canPreConnect",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = PeerSettings_FieldNumber_CanPreConnect,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerSettings__storage_, canPreConnect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sendsOffer",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = PeerSettings_FieldNumber_SendsOffer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PeerSettings__storage_, sendsOffer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "waitForCandidates",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = PeerSettings_FieldNumber_WaitForCandidates,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PeerSettings__storage_, waitForCandidates),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(ClientInfo),
        .number = PeerSettings_FieldNumber_ClientInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PeerSettings__storage_, clientInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerSettings class]
                                     rootClass:[WebRtcRoot class]
                                          file:WebRtcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerSettings__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
