// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messaging.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Messaging.pbobjc.h"
#import "Wrappers.pbobjc.h"
#import "Empty.pbobjc.h"
#import "Duration.pbobjc.h"
#import "Annotations.pbobjc.h"
#import "Definitions.pbobjc.h"
#import "Miscellaneous.pbobjc.h"
#import "Peers.pbobjc.h"
#import "MediaAndFiles.pbobjc.h"
#import "Scalapb.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Any);
GPBObjCClassDeclaration(AudioLocation);
GPBObjCClassDeclaration(AudioMedia);
GPBObjCClassDeclaration(Avatar);
GPBObjCClassDeclaration(BinaryMessage);
GPBObjCClassDeclaration(Color);
GPBObjCClassDeclaration(DeletedMessage);
GPBObjCClassDeclaration(Dialog);
GPBObjCClassDeclaration(DialogData);
GPBObjCClassDeclaration(DialogGroup);
GPBObjCClassDeclaration(DialogIndex);
GPBObjCClassDeclaration(DialogListEntry);
GPBObjCClassDeclaration(DialogShort);
GPBObjCClassDeclaration(DocumentEx);
GPBObjCClassDeclaration(DocumentExPhoto);
GPBObjCClassDeclaration(DocumentExVideo);
GPBObjCClassDeclaration(DocumentExVoice);
GPBObjCClassDeclaration(DocumentMessage);
GPBObjCClassDeclaration(EmptyMessage);
GPBObjCClassDeclaration(FastThumb);
GPBObjCClassDeclaration(GPBBoolValue);
GPBObjCClassDeclaration(GPBBytesValue);
GPBObjCClassDeclaration(GPBDuration);
GPBObjCClassDeclaration(GPBInt32Value);
GPBObjCClassDeclaration(GPBInt64Value);
GPBObjCClassDeclaration(GPBStringValue);
GPBObjCClassDeclaration(GroupOutPeer);
GPBObjCClassDeclaration(HistoryMessage);
GPBObjCClassDeclaration(HistoryMessageLight);
GPBObjCClassDeclaration(ImageLocation);
GPBObjCClassDeclaration(ImageMedia);
GPBObjCClassDeclaration(InteractiveMedia);
GPBObjCClassDeclaration(InteractiveMediaButton);
GPBObjCClassDeclaration(InteractiveMediaConfirm);
GPBObjCClassDeclaration(InteractiveMediaGroup);
GPBObjCClassDeclaration(InteractiveMediaSelect);
GPBObjCClassDeclaration(InteractiveMediaSelectOption);
GPBObjCClassDeclaration(InteractiveMediaTranslation);
GPBObjCClassDeclaration(InteractiveMediaTranslationGroup);
GPBObjCClassDeclaration(InteractiveMediaWidget);
GPBObjCClassDeclaration(JsonMessage);
GPBObjCClassDeclaration(Mention);
GPBObjCClassDeclaration(MessageAttributes);
GPBObjCClassDeclaration(MessageContent);
GPBObjCClassDeclaration(MessageMedia);
GPBObjCClassDeclaration(MessageOverrides);
GPBObjCClassDeclaration(MessageReaction);
GPBObjCClassDeclaration(MessageStatus);
GPBObjCClassDeclaration(OutPeer);
GPBObjCClassDeclaration(ParagraphStyle);
GPBObjCClassDeclaration(Peer);
GPBObjCClassDeclaration(PinnedMessages);
GPBObjCClassDeclaration(ReferencedMessages);
GPBObjCClassDeclaration(ResponseGetLastConversationMessages);
GPBObjCClassDeclaration(ResponseGetLastConversationMessages_Pair);
GPBObjCClassDeclaration(ResponseGetUpdatedMessages);
GPBObjCClassDeclaration(ResponseGetUpdatedMessages_UpdatedMessage);
GPBObjCClassDeclaration(SearchPredicate);
GPBObjCClassDeclaration(ServiceEx);
GPBObjCClassDeclaration(ServiceExChangedAbout);
GPBObjCClassDeclaration(ServiceExChangedAvatar);
GPBObjCClassDeclaration(ServiceExChangedShortname);
GPBObjCClassDeclaration(ServiceExChangedTitle);
GPBObjCClassDeclaration(ServiceExChangedTopic);
GPBObjCClassDeclaration(ServiceExChatArchived);
GPBObjCClassDeclaration(ServiceExChatRestored);
GPBObjCClassDeclaration(ServiceExConferenceStatus);
GPBObjCClassDeclaration(ServiceExContactRegistered);
GPBObjCClassDeclaration(ServiceExGroupCreated);
GPBObjCClassDeclaration(ServiceExPhoneCall);
GPBObjCClassDeclaration(ServiceExPhoneMissed);
GPBObjCClassDeclaration(ServiceExPhoneRejected);
GPBObjCClassDeclaration(ServiceExUserInvited);
GPBObjCClassDeclaration(ServiceExUserJoined);
GPBObjCClassDeclaration(ServiceExUserKicked);
GPBObjCClassDeclaration(ServiceExUserLeft);
GPBObjCClassDeclaration(ServiceMessage);
GPBObjCClassDeclaration(StickerMessage);
GPBObjCClassDeclaration(TextCommand);
GPBObjCClassDeclaration(TextExMarkdown);
GPBObjCClassDeclaration(TextMessage);
GPBObjCClassDeclaration(TextMessageEx);
GPBObjCClassDeclaration(TextModernAttach);
GPBObjCClassDeclaration(TextModernField);
GPBObjCClassDeclaration(TextModernMessage);
GPBObjCClassDeclaration(UUIDValue);
GPBObjCClassDeclaration(UnsupportedMessage);
GPBObjCClassDeclaration(UpdateErrorCause);
GPBObjCClassDeclaration(UpdateErrorCause_Failed);
GPBObjCClassDeclaration(UpdateErrorCause_Rejected);
GPBObjCClassDeclaration(UserOutPeer);
GPBObjCClassDeclaration(WebpageMedia);

#pragma mark - MessagingRoot

@implementation MessagingRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[GAPIAnnotationsRoot extensionRegistry]];
    [registry addExtensions:[DefinitionsRoot extensionRegistry]];
    [registry addExtensions:[ScalapbRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - MessagingRoot_FileDescriptor

static GPBFileDescriptor *MessagingRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"dialog"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum InteractiveMediaStyle

GPBEnumDescriptor *InteractiveMediaStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "InteractiveMediaStyleUnknown\000Interactive"
        "MediaStyleDefault\000InteractiveMediaStyleP"
        "rimary\000InteractiveMediaStyleDanger\000";
    static const int32_t values[] = {
        InteractiveMediaStyle_InteractiveMediaStyleUnknown,
        InteractiveMediaStyle_InteractiveMediaStyleDefault,
        InteractiveMediaStyle_InteractiveMediaStylePrimary,
        InteractiveMediaStyle_InteractiveMediaStyleDanger,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(InteractiveMediaStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:InteractiveMediaStyle_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL InteractiveMediaStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case InteractiveMediaStyle_InteractiveMediaStyleUnknown:
    case InteractiveMediaStyle_InteractiveMediaStyleDefault:
    case InteractiveMediaStyle_InteractiveMediaStylePrimary:
    case InteractiveMediaStyle_InteractiveMediaStyleDanger:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MessageState

GPBEnumDescriptor *MessageState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MessageStateUnknown\000MessageStateSent\000Mes"
        "sageStateReceived\000MessageStateRead\000";
    static const int32_t values[] = {
        MessageState_MessageStateUnknown,
        MessageState_MessageStateSent,
        MessageState_MessageStateReceived,
        MessageState_MessageStateRead,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessageState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessageState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessageState_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessageState_MessageStateUnknown:
    case MessageState_MessageStateSent:
    case MessageState_MessageStateReceived:
    case MessageState_MessageStateRead:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ListLoadMode

GPBEnumDescriptor *ListLoadMode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ListLoadModeUnknown\000ListLoadModeForward\000"
        "ListLoadModeBackward\000ListLoadModeBoth\000";
    static const int32_t values[] = {
        ListLoadMode_ListLoadModeUnknown,
        ListLoadMode_ListLoadModeForward,
        ListLoadMode_ListLoadModeBackward,
        ListLoadMode_ListLoadModeBoth,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ListLoadMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ListLoadMode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ListLoadMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ListLoadMode_ListLoadModeUnknown:
    case ListLoadMode_ListLoadModeForward:
    case ListLoadMode_ListLoadModeBackward:
    case ListLoadMode_ListLoadModeBoth:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum DialogsFilter

GPBEnumDescriptor *DialogsFilter_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DialogsFilterUnknown\000DialogsFilterExclud"
        "efavourites\000DialogsFilterExcludearchived"
        "\000";
    static const int32_t values[] = {
        DialogsFilter_DialogsFilterUnknown,
        DialogsFilter_DialogsFilterExcludefavourites,
        DialogsFilter_DialogsFilterExcludearchived,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DialogsFilter)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DialogsFilter_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DialogsFilter_IsValidValue(int32_t value__) {
  switch (value__) {
    case DialogsFilter_DialogsFilterUnknown:
    case DialogsFilter_DialogsFilterExcludefavourites:
    case DialogsFilter_DialogsFilterExcludearchived:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MessageAttributes

@implementation MessageAttributes

@dynamic hasIsMentioned, isMentioned;
@dynamic hasIsHighlighted, isHighlighted;
@dynamic hasIsNotified, isNotified;
@dynamic hasIsOnlyForYou, isOnlyForYou;
@dynamic unclassified, unclassified_Count;

typedef struct MessageAttributes__storage_ {
  uint32_t _has_storage_[1];
  GPBBoolValue *isMentioned;
  GPBBoolValue *isHighlighted;
  GPBBoolValue *isNotified;
  GPBBoolValue *isOnlyForYou;
  NSMutableDictionary *unclassified;
} MessageAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isMentioned",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = MessageAttributes_FieldNumber_IsMentioned,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageAttributes__storage_, isMentioned),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isHighlighted",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = MessageAttributes_FieldNumber_IsHighlighted,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageAttributes__storage_, isHighlighted),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isNotified",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = MessageAttributes_FieldNumber_IsNotified,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageAttributes__storage_, isNotified),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isOnlyForYou",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = MessageAttributes_FieldNumber_IsOnlyForYou,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MessageAttributes__storage_, isOnlyForYou),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unclassified",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageAttributes_FieldNumber_Unclassified,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageAttributes__storage_, unclassified),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageAttributes class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageAttributes__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageMedia

@implementation MessageMedia

@dynamic hasWebpage, webpage;
@dynamic hasImage, image;
@dynamic hasAudio, audio;
@dynamic actionsArray, actionsArray_Count;

typedef struct MessageMedia__storage_ {
  uint32_t _has_storage_[1];
  WebpageMedia *webpage;
  ImageMedia *image;
  AudioMedia *audio;
  NSMutableArray *actionsArray;
} MessageMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "webpage",
        .dataTypeSpecific.clazz = GPBObjCClass(WebpageMedia),
        .number = MessageMedia_FieldNumber_Webpage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageMedia__storage_, webpage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageMedia),
        .number = MessageMedia_FieldNumber_Image,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageMedia__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.clazz = GPBObjCClass(AudioMedia),
        .number = MessageMedia_FieldNumber_Audio,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageMedia__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaGroup),
        .number = MessageMedia_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageMedia__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageMedia class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageMedia__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WebpageMedia

@implementation WebpageMedia

@dynamic hasURL, URL;
@dynamic hasTitle, title;
@dynamic hasDescription_p, description_p;
@dynamic hasImage, image;

typedef struct WebpageMedia__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *URL;
  GPBStringValue *title;
  GPBStringValue *description_p;
  ImageLocation *image;
} WebpageMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = WebpageMedia_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WebpageMedia__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = WebpageMedia_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WebpageMedia__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = WebpageMedia_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WebpageMedia__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageLocation),
        .number = WebpageMedia_FieldNumber_Image,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WebpageMedia__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WebpageMedia class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WebpageMedia__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ImageMedia

@implementation ImageMedia

@dynamic hasImage, image;

typedef struct ImageMedia__storage_ {
  uint32_t _has_storage_[1];
  ImageLocation *image;
} ImageMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "image",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageLocation),
        .number = ImageMedia_FieldNumber_Image,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ImageMedia__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ImageMedia class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ImageMedia__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AudioMedia

@implementation AudioMedia

@dynamic hasAudio, audio;

typedef struct AudioMedia__storage_ {
  uint32_t _has_storage_[1];
  AudioLocation *audio;
} AudioMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audio",
        .dataTypeSpecific.clazz = GPBObjCClass(AudioLocation),
        .number = AudioMedia_FieldNumber_Audio,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AudioMedia__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AudioMedia class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AudioMedia__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMediaWidget

@implementation InteractiveMediaWidget

@dynamic bodyOneOfCase;
@dynamic interactiveMediaButton;
@dynamic interactiveMediaSelect;

typedef struct InteractiveMediaWidget__storage_ {
  uint32_t _has_storage_[2];
  InteractiveMediaButton *interactiveMediaButton;
  InteractiveMediaSelect *interactiveMediaSelect;
} InteractiveMediaWidget__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "interactiveMediaButton",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaButton),
        .number = InteractiveMediaWidget_FieldNumber_InteractiveMediaButton,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InteractiveMediaWidget__storage_, interactiveMediaButton),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "interactiveMediaSelect",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaSelect),
        .number = InteractiveMediaWidget_FieldNumber_InteractiveMediaSelect,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InteractiveMediaWidget__storage_, interactiveMediaSelect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaWidget class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaWidget__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void InteractiveMediaWidget_ClearBodyOneOfCase(InteractiveMediaWidget *message) {
  GPBDescriptor *descriptor = [InteractiveMediaWidget descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - InteractiveMediaButton

@implementation InteractiveMediaButton

@dynamic value;
@dynamic hasLabel, label;

typedef struct InteractiveMediaButton__storage_ {
  uint32_t _has_storage_[1];
  NSString *value;
  GPBStringValue *label;
} InteractiveMediaButton__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMediaButton_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaButton__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaButton_FieldNumber_Label,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMediaButton__storage_, label),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaButton class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaButton__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMediaSelect

@implementation InteractiveMediaSelect

@dynamic optionsArray, optionsArray_Count;
@dynamic hasLabel, label;
@dynamic hasDefaultValue, defaultValue;

typedef struct InteractiveMediaSelect__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *optionsArray;
  GPBStringValue *label;
  GPBStringValue *defaultValue;
} InteractiveMediaSelect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "optionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaSelectOption),
        .number = InteractiveMediaSelect_FieldNumber_OptionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InteractiveMediaSelect__storage_, optionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaSelect_FieldNumber_Label,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaSelect__storage_, label),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "defaultValue",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaSelect_FieldNumber_DefaultValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMediaSelect__storage_, defaultValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaSelect class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaSelect__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMediaSelectOption

@implementation InteractiveMediaSelectOption

@dynamic value;
@dynamic label;

typedef struct InteractiveMediaSelectOption__storage_ {
  uint32_t _has_storage_[1];
  NSString *value;
  NSString *label;
} InteractiveMediaSelectOption__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMediaSelectOption_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaSelectOption__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMediaSelectOption_FieldNumber_Label,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMediaSelectOption__storage_, label),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaSelectOption class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaSelectOption__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMedia

@implementation InteractiveMedia

@dynamic id_p;
@dynamic hasWidget, widget;
@dynamic style;
@dynamic hasConfirm, confirm;

typedef struct InteractiveMedia__storage_ {
  uint32_t _has_storage_[1];
  InteractiveMediaStyle style;
  NSString *id_p;
  InteractiveMediaWidget *widget;
  InteractiveMediaConfirm *confirm;
} InteractiveMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMedia_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMedia__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "widget",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaWidget),
        .number = InteractiveMedia_FieldNumber_Widget,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMedia__storage_, widget),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "style",
        .dataTypeSpecific.enumDescFunc = InteractiveMediaStyle_EnumDescriptor,
        .number = InteractiveMedia_FieldNumber_Style,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InteractiveMedia__storage_, style),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "confirm",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaConfirm),
        .number = InteractiveMedia_FieldNumber_Confirm,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InteractiveMedia__storage_, confirm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMedia class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMedia__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t InteractiveMedia_Style_RawValue(InteractiveMedia *message) {
  GPBDescriptor *descriptor = [InteractiveMedia descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InteractiveMedia_FieldNumber_Style];
  return GPBGetMessageRawEnumField(message, field);
}

void SetInteractiveMedia_Style_RawValue(InteractiveMedia *message, int32_t value) {
  GPBDescriptor *descriptor = [InteractiveMedia descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InteractiveMedia_FieldNumber_Style];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - InteractiveMediaTranslation

@implementation InteractiveMediaTranslation

@dynamic id_p;
@dynamic value;

typedef struct InteractiveMediaTranslation__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *value;
} InteractiveMediaTranslation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMediaTranslation_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaTranslation__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMediaTranslation_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMediaTranslation__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaTranslation class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaTranslation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMediaTranslationGroup

@implementation InteractiveMediaTranslationGroup

@dynamic language;
@dynamic messagesArray, messagesArray_Count;

typedef struct InteractiveMediaTranslationGroup__storage_ {
  uint32_t _has_storage_[1];
  NSString *language;
  NSMutableArray *messagesArray;
} InteractiveMediaTranslationGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "language",
        .dataTypeSpecific.clazz = Nil,
        .number = InteractiveMediaTranslationGroup_FieldNumber_Language,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaTranslationGroup__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "messagesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaTranslation),
        .number = InteractiveMediaTranslationGroup_FieldNumber_MessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InteractiveMediaTranslationGroup__storage_, messagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaTranslationGroup class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaTranslationGroup__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMediaGroup

@implementation InteractiveMediaGroup

@dynamic actionsArray, actionsArray_Count;
@dynamic hasTitle, title;
@dynamic hasDescription_p, description_p;
@dynamic translationsArray, translationsArray_Count;

typedef struct InteractiveMediaGroup__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *actionsArray;
  GPBStringValue *title;
  GPBStringValue *description_p;
  NSMutableArray *translationsArray;
} InteractiveMediaGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "actionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMedia),
        .number = InteractiveMediaGroup_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InteractiveMediaGroup__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaGroup_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaGroup__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaGroup_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMediaGroup__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "translationsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InteractiveMediaTranslationGroup),
        .number = InteractiveMediaGroup_FieldNumber_TranslationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InteractiveMediaGroup__storage_, translationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaGroup class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaGroup__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InteractiveMediaConfirm

@implementation InteractiveMediaConfirm

@dynamic hasText, text;
@dynamic hasTitle, title;
@dynamic hasOk, ok;
@dynamic hasDismiss, dismiss;

typedef struct InteractiveMediaConfirm__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *text;
  GPBStringValue *title;
  GPBStringValue *ok;
  GPBStringValue *dismiss;
} InteractiveMediaConfirm__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaConfirm_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InteractiveMediaConfirm__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaConfirm_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InteractiveMediaConfirm__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ok",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaConfirm_FieldNumber_Ok,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InteractiveMediaConfirm__storage_, ok),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dismiss",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = InteractiveMediaConfirm_FieldNumber_Dismiss,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InteractiveMediaConfirm__storage_, dismiss),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InteractiveMediaConfirm class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InteractiveMediaConfirm__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateInteractiveMediaEvent

@implementation UpdateInteractiveMediaEvent

@dynamic hasMid, mid;
@dynamic id_p;
@dynamic value;
@dynamic userId;

typedef struct UpdateInteractiveMediaEvent__storage_ {
  uint32_t _has_storage_[1];
  UUIDValue *mid;
  NSString *id_p;
  NSString *value;
  NSString *userId;
} UpdateInteractiveMediaEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateInteractiveMediaEvent_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateInteractiveMediaEvent__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateInteractiveMediaEvent_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateInteractiveMediaEvent__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateInteractiveMediaEvent_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateInteractiveMediaEvent__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateInteractiveMediaEvent_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateInteractiveMediaEvent__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateInteractiveMediaEvent class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateInteractiveMediaEvent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestDoInteractiveMediaAction

@implementation RequestDoInteractiveMediaAction

@dynamic hasMid, mid;
@dynamic id_p;
@dynamic value;

typedef struct RequestDoInteractiveMediaAction__storage_ {
  uint32_t _has_storage_[1];
  UUIDValue *mid;
  NSString *id_p;
  NSString *value;
} RequestDoInteractiveMediaAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestDoInteractiveMediaAction_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestDoInteractiveMediaAction__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestDoInteractiveMediaAction_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestDoInteractiveMediaAction__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestDoInteractiveMediaAction_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestDoInteractiveMediaAction__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestDoInteractiveMediaAction class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestDoInteractiveMediaAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageOverrides

@implementation MessageOverrides

@dynamic hasSenderNameOverride, senderNameOverride;
@dynamic hasSenderPhotoOverride, senderPhotoOverride;
@dynamic hasSenderPhotoURLOverride, senderPhotoURLOverride;

typedef struct MessageOverrides__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *senderNameOverride;
  Avatar *senderPhotoOverride;
  GPBStringValue *senderPhotoURLOverride;
} MessageOverrides__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderNameOverride",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = MessageOverrides_FieldNumber_SenderNameOverride,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageOverrides__storage_, senderNameOverride),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "senderPhotoOverride",
        .dataTypeSpecific.clazz = GPBObjCClass(Avatar),
        .number = MessageOverrides_FieldNumber_SenderPhotoOverride,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageOverrides__storage_, senderPhotoOverride),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "senderPhotoURLOverride",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = MessageOverrides_FieldNumber_SenderPhotoURLOverride,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageOverrides__storage_, senderPhotoURLOverride),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageOverrides class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageOverrides__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\006\245\241!!\250\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageContent

@implementation MessageContent

@dynamic bodyOneOfCase;
@dynamic textMessage;
@dynamic serviceMessage;
@dynamic documentMessage;
@dynamic jsonMessage;
@dynamic unsupportedMessage;
@dynamic stickerMessage;
@dynamic binaryMessage;
@dynamic emptyMessage;
@dynamic deletedMessage;
@dynamic hasOverrides, overrides;
@dynamic extensionsArray, extensionsArray_Count;
@dynamic disableNotifications;

typedef struct MessageContent__storage_ {
  uint32_t _has_storage_[2];
  TextMessage *textMessage;
  ServiceMessage *serviceMessage;
  DocumentMessage *documentMessage;
  JsonMessage *jsonMessage;
  UnsupportedMessage *unsupportedMessage;
  StickerMessage *stickerMessage;
  BinaryMessage *binaryMessage;
  EmptyMessage *emptyMessage;
  DeletedMessage *deletedMessage;
  MessageOverrides *overrides;
  NSMutableArray *extensionsArray;
} MessageContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "textMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(TextMessage),
        .number = MessageContent_FieldNumber_TextMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, textMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serviceMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceMessage),
        .number = MessageContent_FieldNumber_ServiceMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, serviceMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "documentMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(DocumentMessage),
        .number = MessageContent_FieldNumber_DocumentMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, documentMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "jsonMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonMessage),
        .number = MessageContent_FieldNumber_JsonMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, jsonMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unsupportedMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(UnsupportedMessage),
        .number = MessageContent_FieldNumber_UnsupportedMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, unsupportedMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stickerMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(StickerMessage),
        .number = MessageContent_FieldNumber_StickerMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, stickerMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "binaryMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(BinaryMessage),
        .number = MessageContent_FieldNumber_BinaryMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, binaryMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "emptyMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(EmptyMessage),
        .number = MessageContent_FieldNumber_EmptyMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, emptyMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deletedMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(DeletedMessage),
        .number = MessageContent_FieldNumber_DeletedMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, deletedMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "overrides",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageOverrides),
        .number = MessageContent_FieldNumber_Overrides,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageContent__storage_, overrides),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Any),
        .number = MessageContent_FieldNumber_ExtensionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageContent__storage_, extensionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "disableNotifications",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageContent_FieldNumber_DisableNotifications,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageContent class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageContent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void MessageContent_ClearBodyOneOfCase(MessageContent *message) {
  GPBDescriptor *descriptor = [MessageContent descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - TextMessage

@implementation TextMessage

@dynamic text;
@dynamic hasExt, ext;
@dynamic mediaArray, mediaArray_Count;
@dynamic extensionsArray, extensionsArray_Count;
@dynamic mentionsArray, mentionsArray_Count;

typedef struct TextMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
  TextMessageEx *ext;
  NSMutableArray *mediaArray;
  NSMutableArray *extensionsArray;
  NSMutableArray *mentionsArray;
} TextMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = TextMessage_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextMessage__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ext",
        .dataTypeSpecific.clazz = GPBObjCClass(TextMessageEx),
        .number = TextMessage_FieldNumber_Ext,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextMessage__storage_, ext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mediaArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageMedia),
        .number = TextMessage_FieldNumber_MediaArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextMessage__storage_, mediaArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Any),
        .number = TextMessage_FieldNumber_ExtensionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextMessage__storage_, extensionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mentionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Mention),
        .number = TextMessage_FieldNumber_MentionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextMessage__storage_, mentionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Mention

@implementation Mention

@dynamic hasPeer, peer;
@dynamic all;

typedef struct Mention__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
} Mention__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = Mention_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Mention__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "all",
        .dataTypeSpecific.clazz = Nil,
        .number = Mention_FieldNumber_All,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Mention class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Mention__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextMessageEx

@implementation TextMessageEx

@dynamic bodyOneOfCase;
@dynamic textExMarkdown;
@dynamic textModernMessage;
@dynamic textCommand;

typedef struct TextMessageEx__storage_ {
  uint32_t _has_storage_[2];
  TextExMarkdown *textExMarkdown;
  TextModernMessage *textModernMessage;
  TextCommand *textCommand;
} TextMessageEx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "textExMarkdown",
        .dataTypeSpecific.clazz = GPBObjCClass(TextExMarkdown),
        .number = TextMessageEx_FieldNumber_TextExMarkdown,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TextMessageEx__storage_, textExMarkdown),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "textModernMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(TextModernMessage),
        .number = TextMessageEx_FieldNumber_TextModernMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TextMessageEx__storage_, textModernMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "textCommand",
        .dataTypeSpecific.clazz = GPBObjCClass(TextCommand),
        .number = TextMessageEx_FieldNumber_TextCommand,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TextMessageEx__storage_, textCommand),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextMessageEx class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextMessageEx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TextMessageEx_ClearBodyOneOfCase(TextMessageEx *message) {
  GPBDescriptor *descriptor = [TextMessageEx descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - TextExMarkdown

@implementation TextExMarkdown

@dynamic markdown;

typedef struct TextExMarkdown__storage_ {
  uint32_t _has_storage_[1];
  NSString *markdown;
} TextExMarkdown__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "markdown",
        .dataTypeSpecific.clazz = Nil,
        .number = TextExMarkdown_FieldNumber_Markdown,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextExMarkdown__storage_, markdown),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextExMarkdown class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextExMarkdown__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextModernMessage

@implementation TextModernMessage

@dynamic hasText, text;
@dynamic hasStyle, style;
@dynamic attachesArray, attachesArray_Count;

typedef struct TextModernMessage__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *text;
  ParagraphStyle *style;
  NSMutableArray *attachesArray;
} TextModernMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = TextModernMessage_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextModernMessage__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "style",
        .dataTypeSpecific.clazz = GPBObjCClass(ParagraphStyle),
        .number = TextModernMessage_FieldNumber_Style,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextModernMessage__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TextModernAttach),
        .number = TextModernMessage_FieldNumber_AttachesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextModernMessage__storage_, attachesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextModernMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextModernMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ParagraphStyle

@implementation ParagraphStyle

@dynamic hasShowParagraph, showParagraph;
@dynamic hasParagraphColor, paragraphColor;
@dynamic hasBgColor, bgColor;

typedef struct ParagraphStyle__storage_ {
  uint32_t _has_storage_[1];
  GPBBoolValue *showParagraph;
  Color *paragraphColor;
  Color *bgColor;
} ParagraphStyle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "showParagraph",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = ParagraphStyle_FieldNumber_ShowParagraph,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ParagraphStyle__storage_, showParagraph),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "paragraphColor",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = ParagraphStyle_FieldNumber_ParagraphColor,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ParagraphStyle__storage_, paragraphColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bgColor",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = ParagraphStyle_FieldNumber_BgColor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ParagraphStyle__storage_, bgColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ParagraphStyle class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ParagraphStyle__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextModernAttach

@implementation TextModernAttach

@dynamic hasTitle, title;
@dynamic hasTitleURL, titleURL;
@dynamic hasTitleIcon, titleIcon;
@dynamic hasText, text;
@dynamic hasStyle, style;
@dynamic fieldsArray, fieldsArray_Count;

typedef struct TextModernAttach__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *title;
  GPBStringValue *titleURL;
  ImageLocation *titleIcon;
  GPBStringValue *text;
  ParagraphStyle *style;
  NSMutableArray *fieldsArray;
} TextModernAttach__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = TextModernAttach_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextModernAttach__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "titleURL",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = TextModernAttach_FieldNumber_TitleURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextModernAttach__storage_, titleURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "titleIcon",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageLocation),
        .number = TextModernAttach_FieldNumber_TitleIcon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TextModernAttach__storage_, titleIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = TextModernAttach_FieldNumber_Text,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TextModernAttach__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "style",
        .dataTypeSpecific.clazz = GPBObjCClass(ParagraphStyle),
        .number = TextModernAttach_FieldNumber_Style,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TextModernAttach__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fieldsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TextModernField),
        .number = TextModernAttach_FieldNumber_FieldsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextModernAttach__storage_, fieldsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextModernAttach class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextModernAttach__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextModernField

@implementation TextModernField

@dynamic title;
@dynamic value;
@dynamic hasIsShort, isShort;

typedef struct TextModernField__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *value;
  GPBBoolValue *isShort;
} TextModernField__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = TextModernField_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextModernField__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = TextModernField_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextModernField__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isShort",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = TextModernField_FieldNumber_IsShort,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TextModernField__storage_, isShort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextModernField class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextModernField__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextCommand

@implementation TextCommand

@dynamic command;
@dynamic args;

typedef struct TextCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *command;
  NSString *args;
} TextCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "command",
        .dataTypeSpecific.clazz = Nil,
        .number = TextCommand_FieldNumber_Command,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextCommand__storage_, command),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "args",
        .dataTypeSpecific.clazz = Nil,
        .number = TextCommand_FieldNumber_Args,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextCommand__storage_, args),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextCommand class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextCommand__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceMessage

@implementation ServiceMessage

@dynamic text;
@dynamic hasExt, ext;

typedef struct ServiceMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
  ServiceEx *ext;
} ServiceMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceMessage_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceMessage__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ext",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceEx),
        .number = ServiceMessage_FieldNumber_Ext,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ServiceMessage__storage_, ext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceEx

@implementation ServiceEx

@dynamic bodyOneOfCase;
@dynamic userInvited;
@dynamic userJoined;
@dynamic userKicked;
@dynamic userLeft;
@dynamic groupCreated;
@dynamic changedShortname;
@dynamic changedTitle;
@dynamic changedTopic;
@dynamic changedAbout;
@dynamic changedAvatar;
@dynamic contactRegistered;
@dynamic phoneMissed;
@dynamic phoneCall;
@dynamic phoneRejected;
@dynamic chatArchived;
@dynamic chatRestored;
@dynamic conferenceStatus;

typedef struct ServiceEx__storage_ {
  uint32_t _has_storage_[2];
  ServiceExUserInvited *userInvited;
  ServiceExUserJoined *userJoined;
  ServiceExUserKicked *userKicked;
  ServiceExUserLeft *userLeft;
  ServiceExGroupCreated *groupCreated;
  ServiceExChangedShortname *changedShortname;
  ServiceExChangedTitle *changedTitle;
  ServiceExChangedTopic *changedTopic;
  ServiceExChangedAbout *changedAbout;
  ServiceExChangedAvatar *changedAvatar;
  ServiceExContactRegistered *contactRegistered;
  ServiceExPhoneMissed *phoneMissed;
  ServiceExPhoneCall *phoneCall;
  ServiceExPhoneRejected *phoneRejected;
  ServiceExChatArchived *chatArchived;
  ServiceExChatRestored *chatRestored;
  ServiceExConferenceStatus *conferenceStatus;
} ServiceEx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInvited",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExUserInvited),
        .number = ServiceEx_FieldNumber_UserInvited,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, userInvited),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userJoined",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExUserJoined),
        .number = ServiceEx_FieldNumber_UserJoined,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, userJoined),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userKicked",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExUserKicked),
        .number = ServiceEx_FieldNumber_UserKicked,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, userKicked),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userLeft",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExUserLeft),
        .number = ServiceEx_FieldNumber_UserLeft,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, userLeft),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupCreated",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExGroupCreated),
        .number = ServiceEx_FieldNumber_GroupCreated,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, groupCreated),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "changedShortname",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExChangedShortname),
        .number = ServiceEx_FieldNumber_ChangedShortname,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, changedShortname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "changedTitle",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExChangedTitle),
        .number = ServiceEx_FieldNumber_ChangedTitle,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, changedTitle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "changedTopic",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExChangedTopic),
        .number = ServiceEx_FieldNumber_ChangedTopic,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, changedTopic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "changedAbout",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExChangedAbout),
        .number = ServiceEx_FieldNumber_ChangedAbout,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, changedAbout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "changedAvatar",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExChangedAvatar),
        .number = ServiceEx_FieldNumber_ChangedAvatar,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, changedAvatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contactRegistered",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExContactRegistered),
        .number = ServiceEx_FieldNumber_ContactRegistered,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, contactRegistered),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "phoneMissed",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExPhoneMissed),
        .number = ServiceEx_FieldNumber_PhoneMissed,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, phoneMissed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "phoneCall",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExPhoneCall),
        .number = ServiceEx_FieldNumber_PhoneCall,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, phoneCall),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "phoneRejected",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExPhoneRejected),
        .number = ServiceEx_FieldNumber_PhoneRejected,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, phoneRejected),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatArchived",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExChatArchived),
        .number = ServiceEx_FieldNumber_ChatArchived,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, chatArchived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatRestored",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExChatRestored),
        .number = ServiceEx_FieldNumber_ChatRestored,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, chatRestored),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conferenceStatus",
        .dataTypeSpecific.clazz = GPBObjCClass(ServiceExConferenceStatus),
        .number = ServiceEx_FieldNumber_ConferenceStatus,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ServiceEx__storage_, conferenceStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceEx class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceEx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ServiceEx_ClearBodyOneOfCase(ServiceEx *message) {
  GPBDescriptor *descriptor = [ServiceEx descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ServiceExUserInvited

@implementation ServiceExUserInvited

@dynamic invitedUserId;

typedef struct ServiceExUserInvited__storage_ {
  uint32_t _has_storage_[1];
  NSString *invitedUserId;
} ServiceExUserInvited__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invitedUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExUserInvited_FieldNumber_InvitedUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExUserInvited__storage_, invitedUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExUserInvited class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExUserInvited__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExUserJoined

@implementation ServiceExUserJoined

@dynamic joinedUserId;

typedef struct ServiceExUserJoined__storage_ {
  uint32_t _has_storage_[1];
  NSString *joinedUserId;
} ServiceExUserJoined__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "joinedUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExUserJoined_FieldNumber_JoinedUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExUserJoined__storage_, joinedUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExUserJoined class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExUserJoined__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExUserKicked

@implementation ServiceExUserKicked

@dynamic kickedUserId;

typedef struct ServiceExUserKicked__storage_ {
  uint32_t _has_storage_[1];
  NSString *kickedUserId;
} ServiceExUserKicked__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "kickedUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExUserKicked_FieldNumber_KickedUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExUserKicked__storage_, kickedUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExUserKicked class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExUserKicked__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExUserLeft

@implementation ServiceExUserLeft

@dynamic leftUserId;

typedef struct ServiceExUserLeft__storage_ {
  uint32_t _has_storage_[1];
  NSString *leftUserId;
} ServiceExUserLeft__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "leftUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExUserLeft_FieldNumber_LeftUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExUserLeft__storage_, leftUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExUserLeft class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExUserLeft__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExGroupCreated

@implementation ServiceExGroupCreated


typedef struct ServiceExGroupCreated__storage_ {
  uint32_t _has_storage_[1];
} ServiceExGroupCreated__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExGroupCreated class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ServiceExGroupCreated__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExChangedShortname

@implementation ServiceExChangedShortname

@dynamic shortname;

typedef struct ServiceExChangedShortname__storage_ {
  uint32_t _has_storage_[1];
  NSString *shortname;
} ServiceExChangedShortname__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shortname",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExChangedShortname_FieldNumber_Shortname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExChangedShortname__storage_, shortname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExChangedShortname class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExChangedShortname__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExChangedTitle

@implementation ServiceExChangedTitle

@dynamic title;

typedef struct ServiceExChangedTitle__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
} ServiceExChangedTitle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExChangedTitle_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExChangedTitle__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExChangedTitle class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExChangedTitle__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExChangedTopic

@implementation ServiceExChangedTopic

@dynamic hasTopic, topic;

typedef struct ServiceExChangedTopic__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *topic;
} ServiceExChangedTopic__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topic",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = ServiceExChangedTopic_FieldNumber_Topic,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExChangedTopic__storage_, topic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExChangedTopic class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExChangedTopic__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExChangedAbout

@implementation ServiceExChangedAbout

@dynamic hasAbout, about;

typedef struct ServiceExChangedAbout__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *about;
} ServiceExChangedAbout__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "about",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = ServiceExChangedAbout_FieldNumber_About,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExChangedAbout__storage_, about),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExChangedAbout class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExChangedAbout__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExChangedAvatar

@implementation ServiceExChangedAvatar

@dynamic hasAvatar, avatar;

typedef struct ServiceExChangedAvatar__storage_ {
  uint32_t _has_storage_[1];
  Avatar *avatar;
} ServiceExChangedAvatar__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "avatar",
        .dataTypeSpecific.clazz = GPBObjCClass(Avatar),
        .number = ServiceExChangedAvatar_FieldNumber_Avatar,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExChangedAvatar__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExChangedAvatar class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExChangedAvatar__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExContactRegistered

@implementation ServiceExContactRegistered

@dynamic userId;

typedef struct ServiceExContactRegistered__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} ServiceExContactRegistered__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExContactRegistered_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExContactRegistered__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExContactRegistered class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExContactRegistered__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExPhoneMissed

@implementation ServiceExPhoneMissed


typedef struct ServiceExPhoneMissed__storage_ {
  uint32_t _has_storage_[1];
} ServiceExPhoneMissed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExPhoneMissed class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ServiceExPhoneMissed__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExPhoneCall

@implementation ServiceExPhoneCall

@dynamic durationSeconds;

typedef struct ServiceExPhoneCall__storage_ {
  uint32_t _has_storage_[1];
  int32_t durationSeconds;
} ServiceExPhoneCall__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "durationSeconds",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExPhoneCall_FieldNumber_DurationSeconds,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExPhoneCall__storage_, durationSeconds),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExPhoneCall class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExPhoneCall__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExPhoneRejected

@implementation ServiceExPhoneRejected


typedef struct ServiceExPhoneRejected__storage_ {
  uint32_t _has_storage_[1];
} ServiceExPhoneRejected__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExPhoneRejected class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ServiceExPhoneRejected__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExChatArchived

@implementation ServiceExChatArchived


typedef struct ServiceExChatArchived__storage_ {
  uint32_t _has_storage_[1];
} ServiceExChatArchived__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExChatArchived class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ServiceExChatArchived__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExChatRestored

@implementation ServiceExChatRestored


typedef struct ServiceExChatRestored__storage_ {
  uint32_t _has_storage_[1];
} ServiceExChatRestored__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExChatRestored class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ServiceExChatRestored__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceExConferenceStatus

@implementation ServiceExConferenceStatus

@dynamic conferenceId;
@dynamic conferenceStatus;

typedef struct ServiceExConferenceStatus__storage_ {
  uint32_t _has_storage_[1];
  NSString *conferenceId;
  NSString *conferenceStatus;
} ServiceExConferenceStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conferenceId",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExConferenceStatus_FieldNumber_ConferenceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceExConferenceStatus__storage_, conferenceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "conferenceStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = ServiceExConferenceStatus_FieldNumber_ConferenceStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ServiceExConferenceStatus__storage_, conferenceStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceExConferenceStatus class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceExConferenceStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DocumentMessage

@implementation DocumentMessage

@dynamic fileId;
@dynamic accessHash;
@dynamic fileSize;
@dynamic name;
@dynamic mimeType;
@dynamic hasThumb, thumb;
@dynamic hasExt, ext;
@dynamic hasCaption, caption;
@dynamic mentionsArray, mentionsArray_Count;

typedef struct DocumentMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t fileSize;
  NSString *fileId;
  NSString *name;
  NSString *mimeType;
  FastThumb *thumb;
  DocumentEx *ext;
  GPBStringValue *caption;
  NSMutableArray *mentionsArray;
  int64_t accessHash;
} DocumentMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileId",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentMessage_FieldNumber_FileId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, fileId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accessHash",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentMessage_FieldNumber_AccessHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, accessHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentMessage_FieldNumber_FileSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, fileSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentMessage_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mimeType",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentMessage_FieldNumber_MimeType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, mimeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thumb",
        .dataTypeSpecific.clazz = GPBObjCClass(FastThumb),
        .number = DocumentMessage_FieldNumber_Thumb,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, thumb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ext",
        .dataTypeSpecific.clazz = GPBObjCClass(DocumentEx),
        .number = DocumentMessage_FieldNumber_Ext,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, ext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "caption",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = DocumentMessage_FieldNumber_Caption,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, caption),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mentionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Mention),
        .number = DocumentMessage_FieldNumber_MentionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DocumentMessage__storage_, mentionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DocumentMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DocumentMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DocumentEx

@implementation DocumentEx

@dynamic bodyOneOfCase;
@dynamic photo;
@dynamic video;
@dynamic voice;

typedef struct DocumentEx__storage_ {
  uint32_t _has_storage_[2];
  DocumentExPhoto *photo;
  DocumentExVideo *video;
  DocumentExVoice *voice;
} DocumentEx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "photo",
        .dataTypeSpecific.clazz = GPBObjCClass(DocumentExPhoto),
        .number = DocumentEx_FieldNumber_Photo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DocumentEx__storage_, photo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.clazz = GPBObjCClass(DocumentExVideo),
        .number = DocumentEx_FieldNumber_Video,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DocumentEx__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voice",
        .dataTypeSpecific.clazz = GPBObjCClass(DocumentExVoice),
        .number = DocumentEx_FieldNumber_Voice,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DocumentEx__storage_, voice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DocumentEx class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DocumentEx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void DocumentEx_ClearBodyOneOfCase(DocumentEx *message) {
  GPBDescriptor *descriptor = [DocumentEx descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - DocumentExPhoto

@implementation DocumentExPhoto

@dynamic w;
@dynamic h;

typedef struct DocumentExPhoto__storage_ {
  uint32_t _has_storage_[1];
  int32_t w;
  int32_t h;
} DocumentExPhoto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "w",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentExPhoto_FieldNumber_W,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DocumentExPhoto__storage_, w),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "h",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentExPhoto_FieldNumber_H,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DocumentExPhoto__storage_, h),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DocumentExPhoto class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DocumentExPhoto__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DocumentExVideo

@implementation DocumentExVideo

@dynamic w;
@dynamic h;
@dynamic duration;

typedef struct DocumentExVideo__storage_ {
  uint32_t _has_storage_[1];
  int32_t w;
  int32_t h;
  int32_t duration;
} DocumentExVideo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "w",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentExVideo_FieldNumber_W,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DocumentExVideo__storage_, w),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "h",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentExVideo_FieldNumber_H,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DocumentExVideo__storage_, h),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentExVideo_FieldNumber_Duration,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DocumentExVideo__storage_, duration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DocumentExVideo class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DocumentExVideo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DocumentExVoice

@implementation DocumentExVoice

@dynamic duration;

typedef struct DocumentExVoice__storage_ {
  uint32_t _has_storage_[1];
  int32_t duration;
} DocumentExVoice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = DocumentExVoice_FieldNumber_Duration,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DocumentExVoice__storage_, duration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DocumentExVoice class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DocumentExVoice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - JsonMessage

@implementation JsonMessage

@dynamic rawJson;

typedef struct JsonMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *rawJson;
} JsonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rawJson",
        .dataTypeSpecific.clazz = Nil,
        .number = JsonMessage_FieldNumber_RawJson,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(JsonMessage__storage_, rawJson),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[JsonMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(JsonMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnsupportedMessage

@implementation UnsupportedMessage


typedef struct UnsupportedMessage__storage_ {
  uint32_t _has_storage_[1];
} UnsupportedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnsupportedMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(UnsupportedMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StickerMessage

@implementation StickerMessage

@dynamic hasStickerId, stickerId;
@dynamic hasFastPreview, fastPreview;
@dynamic hasImage512, image512;
@dynamic hasImage256, image256;
@dynamic hasStickerCollectionId, stickerCollectionId;
@dynamic hasStickerCollectionAccessHash, stickerCollectionAccessHash;
@dynamic hasEmoji, emoji;
@dynamic hasAnimatedStickerJson, animatedStickerJson;

typedef struct StickerMessage__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *stickerId;
  GPBBytesValue *fastPreview;
  ImageLocation *image512;
  ImageLocation *image256;
  GPBStringValue *stickerCollectionId;
  GPBInt64Value *stickerCollectionAccessHash;
  GPBStringValue *emoji;
  GPBStringValue *animatedStickerJson;
} StickerMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stickerId",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = StickerMessage_FieldNumber_StickerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, stickerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fastPreview",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBytesValue),
        .number = StickerMessage_FieldNumber_FastPreview,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, fastPreview),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image512",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageLocation),
        .number = StickerMessage_FieldNumber_Image512,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, image512),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image256",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageLocation),
        .number = StickerMessage_FieldNumber_Image256,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, image256),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stickerCollectionId",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = StickerMessage_FieldNumber_StickerCollectionId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, stickerCollectionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stickerCollectionAccessHash",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = StickerMessage_FieldNumber_StickerCollectionAccessHash,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, stickerCollectionAccessHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "emoji",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = StickerMessage_FieldNumber_Emoji,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, emoji),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "animatedStickerJson",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = StickerMessage_FieldNumber_AnimatedStickerJson,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(StickerMessage__storage_, animatedStickerJson),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StickerMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StickerMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\005\203\000\004\005\203\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BinaryMessage

@implementation BinaryMessage

@dynamic contentTag;
@dynamic msg;

typedef struct BinaryMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *contentTag;
  NSData *msg;
} BinaryMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contentTag",
        .dataTypeSpecific.clazz = Nil,
        .number = BinaryMessage_FieldNumber_ContentTag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BinaryMessage__storage_, contentTag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = Nil,
        .number = BinaryMessage_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BinaryMessage__storage_, msg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BinaryMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BinaryMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmptyMessage

@implementation EmptyMessage


typedef struct EmptyMessage__storage_ {
  uint32_t _has_storage_[1];
} EmptyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmptyMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(EmptyMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeletedMessage

@implementation DeletedMessage

@dynamic hasIsLocal, isLocal;

typedef struct DeletedMessage__storage_ {
  uint32_t _has_storage_[1];
  GPBBoolValue *isLocal;
} DeletedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isLocal",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = DeletedMessage_FieldNumber_IsLocal,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeletedMessage__storage_, isLocal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeletedMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeletedMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DialogShort

@implementation DialogShort

@dynamic hasPeer, peer;
@dynamic counter;
@dynamic date;

typedef struct DialogShort__storage_ {
  uint32_t _has_storage_[1];
  int32_t counter;
  Peer *peer;
  int64_t date;
} DialogShort__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = DialogShort_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DialogShort__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "counter",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogShort_FieldNumber_Counter,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DialogShort__storage_, counter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogShort_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DialogShort__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DialogShort class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DialogShort__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DialogGroup

@implementation DialogGroup

@dynamic title;
@dynamic key;
@dynamic dialogsArray, dialogsArray_Count;

typedef struct DialogGroup__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *key;
  NSMutableArray *dialogsArray;
} DialogGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogGroup_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DialogGroup__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogGroup_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DialogGroup__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dialogsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DialogShort),
        .number = DialogGroup_FieldNumber_DialogsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DialogGroup__storage_, dialogsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DialogGroup class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DialogGroup__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageReaction

@implementation MessageReaction

@dynamic usersArray, usersArray_Count;
@dynamic code;

typedef struct MessageReaction__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *usersArray;
  NSString *code;
} MessageReaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usersArray",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageReaction_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageReaction__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageReaction_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageReaction__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageReaction class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageReaction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchPredicate

@implementation SearchPredicate

@dynamic key;
@dynamic valuesArray, valuesArray_Count;

typedef struct SearchPredicate__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSMutableArray *valuesArray;
} SearchPredicate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchPredicate_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchPredicate__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "valuesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchPredicate_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchPredicate__storage_, valuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchPredicate class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchPredicate__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestSendMessage

@implementation RequestSendMessage

@dynamic hasPeer, peer;
@dynamic deduplicationId;
@dynamic hasMessage, message;
@dynamic hasIsOnlyForUser, isOnlyForUser;
@dynamic hasForward, forward;
@dynamic hasReply, reply;
@dynamic predicatesArray, predicatesArray_Count;
@dynamic whiteListArray, whiteListArray_Count;
@dynamic blackListArray, blackListArray_Count;

typedef struct RequestSendMessage__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  MessageContent *message;
  GPBStringValue *isOnlyForUser;
  ReferencedMessages *forward;
  ReferencedMessages *reply;
  NSMutableArray *predicatesArray;
  NSMutableArray *whiteListArray;
  NSMutableArray *blackListArray;
  int64_t deduplicationId;
} RequestSendMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestSendMessage_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deduplicationId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSendMessage_FieldNumber_DeduplicationId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, deduplicationId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = RequestSendMessage_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isOnlyForUser",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestSendMessage_FieldNumber_IsOnlyForUser,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, isOnlyForUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "forward",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = RequestSendMessage_FieldNumber_Forward,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, forward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reply",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = RequestSendMessage_FieldNumber_Reply,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, reply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "predicatesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPredicate),
        .number = RequestSendMessage_FieldNumber_PredicatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, predicatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "whiteListArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSendMessage_FieldNumber_WhiteListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, whiteListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blackListArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSendMessage_FieldNumber_BlackListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessage__storage_, blackListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestSendMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestSendMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestSendMessageAsync

@implementation RequestSendMessageAsync

@dynamic hasPeer, peer;
@dynamic deduplicationId;
@dynamic hasMessage, message;
@dynamic hasIsOnlyForUser, isOnlyForUser;
@dynamic hasForward, forward;
@dynamic hasReply, reply;
@dynamic predicatesArray, predicatesArray_Count;
@dynamic whiteListArray, whiteListArray_Count;
@dynamic blackListArray, blackListArray_Count;

typedef struct RequestSendMessageAsync__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  MessageContent *message;
  GPBStringValue *isOnlyForUser;
  ReferencedMessages *forward;
  ReferencedMessages *reply;
  NSMutableArray *predicatesArray;
  NSMutableArray *whiteListArray;
  NSMutableArray *blackListArray;
  int64_t deduplicationId;
} RequestSendMessageAsync__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestSendMessageAsync_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deduplicationId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSendMessageAsync_FieldNumber_DeduplicationId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, deduplicationId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = RequestSendMessageAsync_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isOnlyForUser",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestSendMessageAsync_FieldNumber_IsOnlyForUser,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, isOnlyForUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "forward",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = RequestSendMessageAsync_FieldNumber_Forward,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, forward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reply",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = RequestSendMessageAsync_FieldNumber_Reply,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, reply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "predicatesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPredicate),
        .number = RequestSendMessageAsync_FieldNumber_PredicatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, predicatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "whiteListArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSendMessageAsync_FieldNumber_WhiteListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, whiteListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blackListArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSendMessageAsync_FieldNumber_BlackListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSendMessageAsync__storage_, blackListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestSendMessageAsync class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestSendMessageAsync__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestUpdateMessage

@implementation RequestUpdateMessage

@dynamic hasMid, mid;
@dynamic hasUpdatedMessage, updatedMessage;
@dynamic lastEditedAt;
@dynamic hasPeer, peer;

typedef struct RequestUpdateMessage__storage_ {
  uint32_t _has_storage_[1];
  UUIDValue *mid;
  MessageContent *updatedMessage;
  Peer *peer;
  int64_t lastEditedAt;
} RequestUpdateMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestUpdateMessage_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestUpdateMessage__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updatedMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = RequestUpdateMessage_FieldNumber_UpdatedMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestUpdateMessage__storage_, updatedMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastEditedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestUpdateMessage_FieldNumber_LastEditedAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestUpdateMessage__storage_, lastEditedAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestUpdateMessage_FieldNumber_Peer,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestUpdateMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestUpdateMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestUpdateMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageReceived

@implementation RequestMessageReceived

@dynamic hasPeer, peer;
@dynamic date;

typedef struct RequestMessageReceived__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  int64_t date;
} RequestMessageReceived__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestMessageReceived_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageReceived__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageReceived_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestMessageReceived__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageReceived class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageReceived__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageRead

@implementation RequestMessageRead

@dynamic hasPeer, peer;
@dynamic date;

typedef struct RequestMessageRead__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  int64_t date;
} RequestMessageRead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestMessageRead_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageRead__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageRead_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestMessageRead__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageRead class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageRead__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestDeleteMessage

@implementation RequestDeleteMessage

@dynamic hasPeer, peer;
@dynamic hasMessageId, messageId;
@dynamic deleteForUserOnly;

typedef struct RequestDeleteMessage__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *messageId;
} RequestDeleteMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestDeleteMessage_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestDeleteMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestDeleteMessage_FieldNumber_MessageId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestDeleteMessage__storage_, messageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deleteForUserOnly",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestDeleteMessage_FieldNumber_DeleteForUserOnly,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestDeleteMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestDeleteMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestClearChat

@implementation RequestClearChat

@dynamic hasPeer, peer;
@dynamic lastMessageDate;

typedef struct RequestClearChat__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  int64_t lastMessageDate;
} RequestClearChat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestClearChat_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestClearChat__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastMessageDate",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestClearChat_FieldNumber_LastMessageDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestClearChat__storage_, lastMessageDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestClearChat class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestClearChat__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestDeleteChat

@implementation RequestDeleteChat

@dynamic hasPeer, peer;
@dynamic lastMessageDate;

typedef struct RequestDeleteChat__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  int64_t lastMessageDate;
} RequestDeleteChat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestDeleteChat_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestDeleteChat__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastMessageDate",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestDeleteChat_FieldNumber_LastMessageDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestDeleteChat__storage_, lastMessageDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestDeleteChat class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestDeleteChat__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestArchiveChat

@implementation RequestArchiveChat

@dynamic hasPeer, peer;

typedef struct RequestArchiveChat__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
} RequestArchiveChat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestArchiveChat_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestArchiveChat__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestArchiveChat class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestArchiveChat__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageSetReaction

@implementation RequestMessageSetReaction

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic code;

typedef struct RequestMessageSetReaction__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  UUIDValue *mid;
  NSString *code;
} RequestMessageSetReaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestMessageSetReaction_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageSetReaction__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestMessageSetReaction_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestMessageSetReaction__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageSetReaction_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestMessageSetReaction__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageSetReaction class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageSetReaction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageSetReactionAsync

@implementation RequestMessageSetReactionAsync

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic code;

typedef struct RequestMessageSetReactionAsync__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  UUIDValue *mid;
  NSString *code;
} RequestMessageSetReactionAsync__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestMessageSetReactionAsync_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageSetReactionAsync__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestMessageSetReactionAsync_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestMessageSetReactionAsync__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageSetReactionAsync_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestMessageSetReactionAsync__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageSetReactionAsync class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageSetReactionAsync__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageRemoveReaction

@implementation RequestMessageRemoveReaction

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic code;

typedef struct RequestMessageRemoveReaction__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  UUIDValue *mid;
  NSString *code;
} RequestMessageRemoveReaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestMessageRemoveReaction_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageRemoveReaction__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestMessageRemoveReaction_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestMessageRemoveReaction__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageRemoveReaction_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestMessageRemoveReaction__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageRemoveReaction class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageRemoveReaction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageRemoveReactionAsync

@implementation RequestMessageRemoveReactionAsync

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic code;

typedef struct RequestMessageRemoveReactionAsync__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  UUIDValue *mid;
  NSString *code;
} RequestMessageRemoveReactionAsync__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestMessageRemoveReactionAsync_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageRemoveReactionAsync__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestMessageRemoveReactionAsync_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestMessageRemoveReactionAsync__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageRemoveReactionAsync_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestMessageRemoveReactionAsync__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageRemoveReactionAsync class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageRemoveReactionAsync__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseReactionsResponse

@implementation ResponseReactionsResponse

@dynamic reactionsArray, reactionsArray_Count;

typedef struct ResponseReactionsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *reactionsArray;
} ResponseReactionsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reactionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageReaction),
        .number = ResponseReactionsResponse_FieldNumber_ReactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseReactionsResponse__storage_, reactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseReactionsResponse class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseReactionsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseSendMessage

@implementation ResponseSendMessage

@dynamic hasMessageId, messageId;
@dynamic messageDate;
@dynamic hasPreviousMessageId, previousMessageId;
@dynamic creatorUserId;
@dynamic clock;

typedef struct ResponseSendMessage__storage_ {
  uint32_t _has_storage_[1];
  UUIDValue *messageId;
  UUIDValue *previousMessageId;
  NSString *creatorUserId;
  int64_t messageDate;
  int64_t clock;
} ResponseSendMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageId",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = ResponseSendMessage_FieldNumber_MessageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseSendMessage__storage_, messageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "messageDate",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseSendMessage_FieldNumber_MessageDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseSendMessage__storage_, messageDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "previousMessageId",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = ResponseSendMessage_FieldNumber_PreviousMessageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseSendMessage__storage_, previousMessageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "creatorUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseSendMessage_FieldNumber_CreatorUserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseSendMessage__storage_, creatorUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clock",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseSendMessage_FieldNumber_Clock,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ResponseSendMessage__storage_, clock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseSendMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseSendMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessage

@implementation UpdateMessage

@dynamic attachOneOfCase;
@dynamic hasPeer, peer;
@dynamic senderUserId;
@dynamic date;
@dynamic hasMid, mid;
@dynamic hasMessage, message;
@dynamic hasAttributes, attributes;
@dynamic forward;
@dynamic reply;
@dynamic hasPreviousMid, previousMid;
@dynamic hasPrevMessageDate, prevMessageDate;
@dynamic unreadCounterClock;
@dynamic hasCounter, counter;
@dynamic hasMyReadDate, myReadDate;
@dynamic randomId;
@dynamic modifiedAt;
@dynamic hasPrevEditInPeerAt, prevEditInPeerAt;

typedef struct UpdateMessage__storage_ {
  uint32_t _has_storage_[2];
  Peer *peer;
  NSString *senderUserId;
  UUIDValue *mid;
  MessageContent *message;
  MessageAttributes *attributes;
  ReferencedMessages *forward;
  ReferencedMessages *reply;
  UUIDValue *previousMid;
  GPBInt64Value *prevMessageDate;
  GPBInt32Value *counter;
  GPBInt64Value *myReadDate;
  GPBInt64Value *prevEditInPeerAt;
  int64_t date;
  int64_t unreadCounterClock;
  int64_t randomId;
  int64_t modifiedAt;
} UpdateMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessage_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "senderUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessage_FieldNumber_SenderUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, senderUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessage_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessage_FieldNumber_Mid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = UpdateMessage_FieldNumber_Message,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attributes",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageAttributes),
        .number = UpdateMessage_FieldNumber_Attributes,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, attributes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "forward",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = UpdateMessage_FieldNumber_Forward,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, forward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reply",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = UpdateMessage_FieldNumber_Reply,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, reply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "previousMid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessage_FieldNumber_PreviousMid,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, previousMid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prevMessageDate",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = UpdateMessage_FieldNumber_PrevMessageDate,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, prevMessageDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unreadCounterClock",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessage_FieldNumber_UnreadCounterClock,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, unreadCounterClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "counter",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateMessage_FieldNumber_Counter,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, counter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "myReadDate",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = UpdateMessage_FieldNumber_MyReadDate,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, myReadDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessage_FieldNumber_RandomId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, randomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "modifiedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessage_FieldNumber_ModifiedAt,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, modifiedAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "prevEditInPeerAt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = UpdateMessage_FieldNumber_PrevEditInPeerAt,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(UpdateMessage__storage_, prevEditInPeerAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "attach",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void UpdateMessage_ClearAttachOneOfCase(UpdateMessage *message) {
  GPBDescriptor *descriptor = [UpdateMessage descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - UpdateMessageContentChanged

@implementation UpdateMessageContentChanged

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic hasMessage, message;
@dynamic editedAt;
@dynamic prevEditInPeerAt;
@dynamic hasIsSilent, isSilent;

typedef struct UpdateMessageContentChanged__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *mid;
  MessageContent *message;
  GPBBoolValue *isSilent;
  int64_t editedAt;
  int64_t prevEditInPeerAt;
} UpdateMessageContentChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageContentChanged_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageContentChanged__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessageContentChanged_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageContentChanged__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = UpdateMessageContentChanged_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageContentChanged__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "editedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageContentChanged_FieldNumber_EditedAt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessageContentChanged__storage_, editedAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "prevEditInPeerAt",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageContentChanged_FieldNumber_PrevEditInPeerAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateMessageContentChanged__storage_, prevEditInPeerAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isSilent",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = UpdateMessageContentChanged_FieldNumber_IsSilent,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UpdateMessageContentChanged__storage_, isSilent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageContentChanged class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageContentChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessageSent

@implementation UpdateMessageSent

@dynamic attachOneOfCase;
@dynamic hasPeer, peer;
@dynamic rid;
@dynamic date;
@dynamic hasMid, mid;
@dynamic hasPrevMid, prevMid;
@dynamic unreadCounterClock;
@dynamic hasUnreadCounter, unreadCounter;
@dynamic hasMyReadDate, myReadDate;
@dynamic forward;
@dynamic reply;

typedef struct UpdateMessageSent__storage_ {
  uint32_t _has_storage_[2];
  Peer *peer;
  UUIDValue *mid;
  UUIDValue *prevMid;
  GPBInt32Value *unreadCounter;
  GPBInt64Value *myReadDate;
  ReferencedMessages *forward;
  ReferencedMessages *reply;
  int64_t rid;
  int64_t date;
  int64_t unreadCounterClock;
} UpdateMessageSent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageSent_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rid",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageSent_FieldNumber_Rid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, rid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageSent_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessageSent_FieldNumber_Mid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prevMid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessageSent_FieldNumber_PrevMid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, prevMid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unreadCounterClock",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageSent_FieldNumber_UnreadCounterClock,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, unreadCounterClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unreadCounter",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateMessageSent_FieldNumber_UnreadCounter,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, unreadCounter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "myReadDate",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = UpdateMessageSent_FieldNumber_MyReadDate,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, myReadDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "forward",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = UpdateMessageSent_FieldNumber_Forward,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, forward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reply",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = UpdateMessageSent_FieldNumber_Reply,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(UpdateMessageSent__storage_, reply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageSent class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageSent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "attach",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void UpdateMessageSent_ClearAttachOneOfCase(UpdateMessageSent *message) {
  GPBDescriptor *descriptor = [UpdateMessageSent descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - UpdateMessageReceived

@implementation UpdateMessageReceived

@dynamic hasPeer, peer;
@dynamic startDate;
@dynamic receivedDate;

typedef struct UpdateMessageReceived__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  int64_t startDate;
  int64_t receivedDate;
} UpdateMessageReceived__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageReceived_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageReceived__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "startDate",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReceived_FieldNumber_StartDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageReceived__storage_, startDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "receivedDate",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReceived_FieldNumber_ReceivedDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageReceived__storage_, receivedDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageReceived class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageReceived__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessageRead

@implementation UpdateMessageRead

@dynamic hasPeer, peer;
@dynamic startDate;
@dynamic readDate;

typedef struct UpdateMessageRead__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  int64_t startDate;
  int64_t readDate;
} UpdateMessageRead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageRead_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageRead__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "startDate",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageRead_FieldNumber_StartDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageRead__storage_, startDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "readDate",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageRead_FieldNumber_ReadDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageRead__storage_, readDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageRead class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageRead__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessageReadByMe

@implementation UpdateMessageReadByMe

@dynamic hasPeer, peer;
@dynamic startDate;
@dynamic unreadCounterClock;
@dynamic hasUnreadCounter, unreadCounter;

typedef struct UpdateMessageReadByMe__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  GPBInt32Value *unreadCounter;
  int64_t startDate;
  int64_t unreadCounterClock;
} UpdateMessageReadByMe__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageReadByMe_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageReadByMe__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "startDate",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReadByMe_FieldNumber_StartDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageReadByMe__storage_, startDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unreadCounterClock",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReadByMe_FieldNumber_UnreadCounterClock,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageReadByMe__storage_, unreadCounterClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unreadCounter",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateMessageReadByMe_FieldNumber_UnreadCounter,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessageReadByMe__storage_, unreadCounter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageReadByMe class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageReadByMe__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessageDelete

@implementation UpdateMessageDelete

@dynamic hasPeer, peer;
@dynamic midsArray, midsArray_Count;
@dynamic hasCounter, counter;
@dynamic actionDate;

typedef struct UpdateMessageDelete__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSMutableArray *midsArray;
  GPBInt32Value *counter;
  int64_t actionDate;
} UpdateMessageDelete__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageDelete_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageDelete__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "midsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessageDelete_FieldNumber_MidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpdateMessageDelete__storage_, midsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "counter",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = UpdateMessageDelete_FieldNumber_Counter,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageDelete__storage_, counter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionDate",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageDelete_FieldNumber_ActionDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageDelete__storage_, actionDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageDelete class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageDelete__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateChatClear

@implementation UpdateChatClear

@dynamic hasPeer, peer;
@dynamic actionDate;

typedef struct UpdateChatClear__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  int64_t actionDate;
} UpdateChatClear__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateChatClear_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateChatClear__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionDate",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateChatClear_FieldNumber_ActionDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateChatClear__storage_, actionDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateChatClear class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateChatClear__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateChatDelete

@implementation UpdateChatDelete

@dynamic hasPeer, peer;
@dynamic actionDate;

typedef struct UpdateChatDelete__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  int64_t actionDate;
} UpdateChatDelete__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateChatDelete_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateChatDelete__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionDate",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateChatDelete_FieldNumber_ActionDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateChatDelete__storage_, actionDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateChatDelete class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateChatDelete__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateChatArchive

@implementation UpdateChatArchive

@dynamic hasPeer, peer;

typedef struct UpdateChatArchive__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
} UpdateChatArchive__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateChatArchive_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateChatArchive__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateChatArchive class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateChatArchive__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateChatGroupsChanged

@implementation UpdateChatGroupsChanged

@dynamic dialogsArray, dialogsArray_Count;

typedef struct UpdateChatGroupsChanged__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dialogsArray;
} UpdateChatGroupsChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dialogsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DialogGroup),
        .number = UpdateChatGroupsChanged_FieldNumber_DialogsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpdateChatGroupsChanged__storage_, dialogsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateChatGroupsChanged class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateChatGroupsChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateReactionsUpdate

@implementation UpdateReactionsUpdate

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic reactionsArray, reactionsArray_Count;

typedef struct UpdateReactionsUpdate__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *mid;
  NSMutableArray *reactionsArray;
} UpdateReactionsUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateReactionsUpdate_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateReactionsUpdate__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateReactionsUpdate_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateReactionsUpdate__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reactionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageReaction),
        .number = UpdateReactionsUpdate_FieldNumber_ReactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpdateReactionsUpdate__storage_, reactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateReactionsUpdate class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateReactionsUpdate__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateSendMessageError

@implementation UpdateSendMessageError

@dynamic hasPeer, peer;
@dynamic rid;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateSendMessageError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t rid;
  int64_t date;
} UpdateSendMessageError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateSendMessageError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateSendMessageError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rid",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateSendMessageError_FieldNumber_Rid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateSendMessageError__storage_, rid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateSendMessageError_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateSendMessageError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateSendMessageError_FieldNumber_HookId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateSendMessageError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateSendMessageError_FieldNumber_Cause,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateSendMessageError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateSendMessageError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateSendMessageError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateEditMessageError

@implementation UpdateEditMessageError

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateEditMessageError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *mid;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateEditMessageError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateEditMessageError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateEditMessageError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateEditMessageError_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateEditMessageError__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateEditMessageError_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateEditMessageError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateEditMessageError_FieldNumber_HookId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateEditMessageError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateEditMessageError_FieldNumber_Cause,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateEditMessageError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateEditMessageError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateEditMessageError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateDeleteMessageError

@implementation UpdateDeleteMessageError

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateDeleteMessageError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *mid;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateDeleteMessageError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateDeleteMessageError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateDeleteMessageError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateDeleteMessageError_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateDeleteMessageError__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateDeleteMessageError_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateDeleteMessageError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateDeleteMessageError_FieldNumber_HookId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateDeleteMessageError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateDeleteMessageError_FieldNumber_Cause,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateDeleteMessageError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateDeleteMessageError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateDeleteMessageError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessageReadError

@implementation UpdateMessageReadError

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateMessageReadError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *mid;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateMessageReadError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageReadError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageReadError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessageReadError_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageReadError__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReadError_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageReadError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReadError_FieldNumber_HookId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessageReadError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateMessageReadError_FieldNumber_Cause,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateMessageReadError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageReadError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageReadError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessageReceivedError

@implementation UpdateMessageReceivedError

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateMessageReceivedError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *mid;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateMessageReceivedError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageReceivedError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageReceivedError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessageReceivedError_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageReceivedError__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReceivedError_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageReceivedError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageReceivedError_FieldNumber_HookId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessageReceivedError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateMessageReceivedError_FieldNumber_Cause,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateMessageReceivedError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageReceivedError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageReceivedError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessageRemoveReactionError

@implementation UpdateMessageRemoveReactionError

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateMessageRemoveReactionError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *mid;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateMessageRemoveReactionError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageRemoveReactionError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageRemoveReactionError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessageRemoveReactionError_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageRemoveReactionError__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageRemoveReactionError_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageRemoveReactionError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageRemoveReactionError_FieldNumber_HookId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessageRemoveReactionError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateMessageRemoveReactionError_FieldNumber_Cause,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateMessageRemoveReactionError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageRemoveReactionError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageRemoveReactionError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMessageSetReactionError

@implementation UpdateMessageSetReactionError

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateMessageSetReactionError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  UUIDValue *mid;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateMessageSetReactionError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateMessageSetReactionError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMessageSetReactionError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateMessageSetReactionError_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateMessageSetReactionError__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageSetReactionError_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateMessageSetReactionError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateMessageSetReactionError_FieldNumber_HookId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateMessageSetReactionError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateMessageSetReactionError_FieldNumber_Cause,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateMessageSetReactionError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMessageSetReactionError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMessageSetReactionError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateClearChatError

@implementation UpdateClearChatError

@dynamic hasPeer, peer;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateClearChatError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateClearChatError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateClearChatError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateClearChatError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateClearChatError_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateClearChatError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateClearChatError_FieldNumber_HookId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateClearChatError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateClearChatError_FieldNumber_Cause,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateClearChatError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateClearChatError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateClearChatError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateDeleteChatError

@implementation UpdateDeleteChatError

@dynamic hasPeer, peer;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateDeleteChatError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateDeleteChatError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateDeleteChatError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateDeleteChatError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateDeleteChatError_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateDeleteChatError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateDeleteChatError_FieldNumber_HookId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateDeleteChatError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateDeleteChatError_FieldNumber_Cause,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateDeleteChatError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateDeleteChatError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateDeleteChatError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateFavouriteDialogError

@implementation UpdateFavouriteDialogError

@dynamic hasPeer, peer;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateFavouriteDialogError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateFavouriteDialogError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateFavouriteDialogError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateFavouriteDialogError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateFavouriteDialogError_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateFavouriteDialogError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateFavouriteDialogError_FieldNumber_HookId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateFavouriteDialogError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateFavouriteDialogError_FieldNumber_Cause,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateFavouriteDialogError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateFavouriteDialogError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateFavouriteDialogError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateUnfavouriteDialogError

@implementation UpdateUnfavouriteDialogError

@dynamic hasPeer, peer;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateUnfavouriteDialogError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateUnfavouriteDialogError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateUnfavouriteDialogError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateUnfavouriteDialogError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateUnfavouriteDialogError_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateUnfavouriteDialogError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateUnfavouriteDialogError_FieldNumber_HookId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateUnfavouriteDialogError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateUnfavouriteDialogError_FieldNumber_Cause,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateUnfavouriteDialogError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateUnfavouriteDialogError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateUnfavouriteDialogError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateReadDialogLaterError

@implementation UpdateReadDialogLaterError

@dynamic hasPeer, peer;
@dynamic date;
@dynamic hookId;
@dynamic hasCause, cause;

typedef struct UpdateReadDialogLaterError__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *hookId;
  UpdateErrorCause *cause;
  int64_t date;
} UpdateReadDialogLaterError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateReadDialogLaterError_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateReadDialogLaterError__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateReadDialogLaterError_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateReadDialogLaterError__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hookId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateReadDialogLaterError_FieldNumber_HookId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateReadDialogLaterError__storage_, hookId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cause",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause),
        .number = UpdateReadDialogLaterError_FieldNumber_Cause,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateReadDialogLaterError__storage_, cause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateReadDialogLaterError class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateReadDialogLaterError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateErrorCause

@implementation UpdateErrorCause

@dynamic valueOneOfCase;
@dynamic rejected;
@dynamic failed;

typedef struct UpdateErrorCause__storage_ {
  uint32_t _has_storage_[2];
  UpdateErrorCause_Rejected *rejected;
  UpdateErrorCause_Failed *failed;
} UpdateErrorCause__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rejected",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause_Rejected),
        .number = UpdateErrorCause_FieldNumber_Rejected,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(UpdateErrorCause__storage_, rejected),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "failed",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateErrorCause_Failed),
        .number = UpdateErrorCause_FieldNumber_Failed,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(UpdateErrorCause__storage_, failed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateErrorCause class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateErrorCause__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "value",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void UpdateErrorCause_ClearValueOneOfCase(UpdateErrorCause *message) {
  GPBDescriptor *descriptor = [UpdateErrorCause descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - UpdateErrorCause_Rejected

@implementation UpdateErrorCause_Rejected

@dynamic hasReason, reason;

typedef struct UpdateErrorCause_Rejected__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *reason;
} UpdateErrorCause_Rejected__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reason",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = UpdateErrorCause_Rejected_FieldNumber_Reason,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateErrorCause_Rejected__storage_, reason),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateErrorCause_Rejected class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateErrorCause_Rejected__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(UpdateErrorCause)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateErrorCause_Failed

@implementation UpdateErrorCause_Failed

@dynamic hasDescription_p, description_p;
@dynamic hasTag, tag;

typedef struct UpdateErrorCause_Failed__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *description_p;
  GPBStringValue *tag;
} UpdateErrorCause_Failed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = UpdateErrorCause_Failed_FieldNumber_Description_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateErrorCause_Failed__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tag",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = UpdateErrorCause_Failed_FieldNumber_Tag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateErrorCause_Failed__storage_, tag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateErrorCause_Failed class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateErrorCause_Failed__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(UpdateErrorCause)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateThreadCreated

@implementation UpdateThreadCreated

@dynamic hasPeer, peer;
@dynamic hasStartMessage, startMessage;

typedef struct UpdateThreadCreated__storage_ {
  uint32_t _has_storage_[1];
  GroupOutPeer *peer;
  UUIDValue *startMessage;
} UpdateThreadCreated__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupOutPeer),
        .number = UpdateThreadCreated_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateThreadCreated__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "startMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = UpdateThreadCreated_FieldNumber_StartMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateThreadCreated__storage_, startMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateThreadCreated class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateThreadCreated__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateThreadLifted

@implementation UpdateThreadLifted

@dynamic hasPeer, peer;

typedef struct UpdateThreadLifted__storage_ {
  uint32_t _has_storage_[1];
  GroupOutPeer *peer;
} UpdateThreadLifted__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupOutPeer),
        .number = UpdateThreadLifted_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateThreadLifted__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateThreadLifted class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateThreadLifted__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReferencedMessages

@implementation ReferencedMessages

@dynamic midsArray, midsArray_Count;

typedef struct ReferencedMessages__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *midsArray;
} ReferencedMessages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "midsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = ReferencedMessages_FieldNumber_MidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ReferencedMessages__storage_, midsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReferencedMessages class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReferencedMessages__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HistoryMessage

@implementation HistoryMessage

@dynamic attachOneOfCase;
@dynamic senderUserId;
@dynamic hasSenderPeer, senderPeer;
@dynamic hasHostPeer, hostPeer;
@dynamic hasMid, mid;
@dynamic hasPrevMid, prevMid;
@dynamic date;
@dynamic hasMessage, message;
@dynamic state;
@dynamic reactionsArray, reactionsArray_Count;
@dynamic hasAttribute, attribute;
@dynamic forward;
@dynamic reply;
@dynamic hasEditedAt, editedAt;
@dynamic randomId;

typedef struct HistoryMessage__storage_ {
  uint32_t _has_storage_[2];
  MessageState state;
  NSString *senderUserId;
  OutPeer *senderPeer;
  OutPeer *hostPeer;
  UUIDValue *mid;
  UUIDValue *prevMid;
  MessageContent *message;
  NSMutableArray *reactionsArray;
  MessageAttributes *attribute;
  ReferencedMessages *forward;
  ReferencedMessages *reply;
  GPBInt64Value *editedAt;
  int64_t date;
  int64_t randomId;
} HistoryMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = HistoryMessage_FieldNumber_SenderUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, senderUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "senderPeer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = HistoryMessage_FieldNumber_SenderPeer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, senderPeer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hostPeer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = HistoryMessage_FieldNumber_HostPeer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, hostPeer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = HistoryMessage_FieldNumber_Mid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prevMid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = HistoryMessage_FieldNumber_PrevMid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, prevMid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = HistoryMessage_FieldNumber_Date,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = HistoryMessage_FieldNumber_Message,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = MessageState_EnumDescriptor,
        .number = HistoryMessage_FieldNumber_State,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "reactionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageReaction),
        .number = HistoryMessage_FieldNumber_ReactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, reactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attribute",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageAttributes),
        .number = HistoryMessage_FieldNumber_Attribute,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, attribute),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "forward",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = HistoryMessage_FieldNumber_Forward,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, forward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reply",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = HistoryMessage_FieldNumber_Reply,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, reply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "editedAt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = HistoryMessage_FieldNumber_EditedAt,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, editedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomId",
        .dataTypeSpecific.clazz = Nil,
        .number = HistoryMessage_FieldNumber_RandomId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(HistoryMessage__storage_, randomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HistoryMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HistoryMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "attach",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t HistoryMessage_State_RawValue(HistoryMessage *message) {
  GPBDescriptor *descriptor = [HistoryMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:HistoryMessage_FieldNumber_State];
  return GPBGetMessageRawEnumField(message, field);
}

void SetHistoryMessage_State_RawValue(HistoryMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [HistoryMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:HistoryMessage_FieldNumber_State];
  GPBSetMessageRawEnumField(message, field, value);
}

void HistoryMessage_ClearAttachOneOfCase(HistoryMessage *message) {
  GPBDescriptor *descriptor = [HistoryMessage descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - RequestLoadHistory

@implementation RequestLoadHistory

@dynamic hasPeer, peer;
@dynamic date;
@dynamic loadMode;
@dynamic limit;

typedef struct RequestLoadHistory__storage_ {
  uint32_t _has_storage_[1];
  ListLoadMode loadMode;
  int32_t limit;
  OutPeer *peer;
  int64_t date;
} RequestLoadHistory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestLoadHistory_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadHistory__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadHistory_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestLoadHistory__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "loadMode",
        .dataTypeSpecific.enumDescFunc = ListLoadMode_EnumDescriptor,
        .number = RequestLoadHistory_FieldNumber_LoadMode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestLoadHistory__storage_, loadMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadHistory_FieldNumber_Limit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestLoadHistory__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadHistory class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadHistory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RequestLoadHistory_LoadMode_RawValue(RequestLoadHistory *message) {
  GPBDescriptor *descriptor = [RequestLoadHistory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestLoadHistory_FieldNumber_LoadMode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRequestLoadHistory_LoadMode_RawValue(RequestLoadHistory *message, int32_t value) {
  GPBDescriptor *descriptor = [RequestLoadHistory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestLoadHistory_FieldNumber_LoadMode];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ResponseLoadHistory

@implementation ResponseLoadHistory

@dynamic historyArray, historyArray_Count;
@dynamic userPeersArray, userPeersArray_Count;
@dynamic groupPeersArray, groupPeersArray_Count;
@dynamic hasCounter, counter;
@dynamic counterDate;
@dynamic hasLastConversationMessageDate, lastConversationMessageDate;
@dynamic countForeignAfterLastReturned;

typedef struct ResponseLoadHistory__storage_ {
  uint32_t _has_storage_[1];
  int32_t countForeignAfterLastReturned;
  NSMutableArray *historyArray;
  NSMutableArray *userPeersArray;
  NSMutableArray *groupPeersArray;
  GPBInt32Value *counter;
  GPBInt64Value *lastConversationMessageDate;
  int64_t counterDate;
} ResponseLoadHistory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "historyArray",
        .dataTypeSpecific.clazz = GPBObjCClass(HistoryMessage),
        .number = ResponseLoadHistory_FieldNumber_HistoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadHistory__storage_, historyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOutPeer),
        .number = ResponseLoadHistory_FieldNumber_UserPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadHistory__storage_, userPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupOutPeer),
        .number = ResponseLoadHistory_FieldNumber_GroupPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadHistory__storage_, groupPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "counter",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = ResponseLoadHistory_FieldNumber_Counter,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseLoadHistory__storage_, counter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "counterDate",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadHistory_FieldNumber_CounterDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseLoadHistory__storage_, counterDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastConversationMessageDate",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = ResponseLoadHistory_FieldNumber_LastConversationMessageDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseLoadHistory__storage_, lastConversationMessageDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "countForeignAfterLastReturned",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadHistory_FieldNumber_CountForeignAfterLastReturned,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseLoadHistory__storage_, countForeignAfterLastReturned),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadHistory class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadHistory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestHistoryDifference

@implementation RequestHistoryDifference

@dynamic clock;

typedef struct RequestHistoryDifference__storage_ {
  uint32_t _has_storage_[1];
  int64_t clock;
} RequestHistoryDifference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clock",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestHistoryDifference_FieldNumber_Clock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestHistoryDifference__storage_, clock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestHistoryDifference class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestHistoryDifference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseHistoryDifference

@implementation ResponseHistoryDifference

@dynamic historyArray, historyArray_Count;
@dynamic fromClock;
@dynamic clock;

typedef struct ResponseHistoryDifference__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *historyArray;
  int64_t fromClock;
  int64_t clock;
} ResponseHistoryDifference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "historyArray",
        .dataTypeSpecific.clazz = GPBObjCClass(HistoryMessage),
        .number = ResponseHistoryDifference_FieldNumber_HistoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseHistoryDifference__storage_, historyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fromClock",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseHistoryDifference_FieldNumber_FromClock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseHistoryDifference__storage_, fromClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "clock",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseHistoryDifference_FieldNumber_Clock,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseHistoryDifference__storage_, clock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseHistoryDifference class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseHistoryDifference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HistoryMessageLight

@implementation HistoryMessageLight

@dynamic attachOneOfCase;
@dynamic senderUserId;
@dynamic hasMessageId, messageId;
@dynamic date;
@dynamic hasMessage, message;
@dynamic forward;
@dynamic reply;
@dynamic editedAt;
@dynamic randomId;

typedef struct HistoryMessageLight__storage_ {
  uint32_t _has_storage_[2];
  NSString *senderUserId;
  UUIDValue *messageId;
  MessageContent *message;
  ReferencedMessages *forward;
  ReferencedMessages *reply;
  int64_t date;
  int64_t editedAt;
  int64_t randomId;
} HistoryMessageLight__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = HistoryMessageLight_FieldNumber_SenderUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HistoryMessageLight__storage_, senderUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = HistoryMessageLight_FieldNumber_MessageId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HistoryMessageLight__storage_, messageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = HistoryMessageLight_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HistoryMessageLight__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = HistoryMessageLight_FieldNumber_Message,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(HistoryMessageLight__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "forward",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = HistoryMessageLight_FieldNumber_Forward,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(HistoryMessageLight__storage_, forward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reply",
        .dataTypeSpecific.clazz = GPBObjCClass(ReferencedMessages),
        .number = HistoryMessageLight_FieldNumber_Reply,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(HistoryMessageLight__storage_, reply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "editedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = HistoryMessageLight_FieldNumber_EditedAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(HistoryMessageLight__storage_, editedAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "randomId",
        .dataTypeSpecific.clazz = Nil,
        .number = HistoryMessageLight_FieldNumber_RandomId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(HistoryMessageLight__storage_, randomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HistoryMessageLight class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HistoryMessageLight__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "attach",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void HistoryMessageLight_ClearAttachOneOfCase(HistoryMessageLight *message) {
  GPBDescriptor *descriptor = [HistoryMessageLight descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - RequestLoadHistoryLight

@implementation RequestLoadHistoryLight

@dynamic hasPeer, peer;
@dynamic date;
@dynamic loadMode;
@dynamic limit;

typedef struct RequestLoadHistoryLight__storage_ {
  uint32_t _has_storage_[1];
  ListLoadMode loadMode;
  int32_t limit;
  Peer *peer;
  int64_t date;
} RequestLoadHistoryLight__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestLoadHistoryLight_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadHistoryLight__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadHistoryLight_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestLoadHistoryLight__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "loadMode",
        .dataTypeSpecific.enumDescFunc = ListLoadMode_EnumDescriptor,
        .number = RequestLoadHistoryLight_FieldNumber_LoadMode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestLoadHistoryLight__storage_, loadMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadHistoryLight_FieldNumber_Limit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestLoadHistoryLight__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadHistoryLight class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadHistoryLight__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RequestLoadHistoryLight_LoadMode_RawValue(RequestLoadHistoryLight *message) {
  GPBDescriptor *descriptor = [RequestLoadHistoryLight descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestLoadHistoryLight_FieldNumber_LoadMode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRequestLoadHistoryLight_LoadMode_RawValue(RequestLoadHistoryLight *message, int32_t value) {
  GPBDescriptor *descriptor = [RequestLoadHistoryLight descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestLoadHistoryLight_FieldNumber_LoadMode];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ResponseLoadHistoryLight

@implementation ResponseLoadHistoryLight

@dynamic historyArray, historyArray_Count;

typedef struct ResponseLoadHistoryLight__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *historyArray;
} ResponseLoadHistoryLight__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "historyArray",
        .dataTypeSpecific.clazz = GPBObjCClass(HistoryMessageLight),
        .number = ResponseLoadHistoryLight_FieldNumber_HistoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadHistoryLight__storage_, historyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadHistoryLight class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadHistoryLight__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestCountForeignMessages

@implementation RequestCountForeignMessages

@dynamic hasPeer, peer;
@dynamic fromDate;

typedef struct RequestCountForeignMessages__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  int64_t fromDate;
} RequestCountForeignMessages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestCountForeignMessages_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestCountForeignMessages__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fromDate",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestCountForeignMessages_FieldNumber_FromDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestCountForeignMessages__storage_, fromDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestCountForeignMessages class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestCountForeignMessages__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseCountForeignMessages

@implementation ResponseCountForeignMessages

@dynamic lastConversationMessageDate;
@dynamic count;

typedef struct ResponseCountForeignMessages__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  int64_t lastConversationMessageDate;
} ResponseCountForeignMessages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastConversationMessageDate",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseCountForeignMessages_FieldNumber_LastConversationMessageDate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseCountForeignMessages__storage_, lastConversationMessageDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseCountForeignMessages_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseCountForeignMessages__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseCountForeignMessages class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseCountForeignMessages__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Dialog

@implementation Dialog

@dynamic hasPeer, peer;
@dynamic unreadCount;
@dynamic sortDate;
@dynamic senderUserId;
@dynamic hasIsFavourite, isFavourite;
@dynamic hasMid, mid;
@dynamic date;
@dynamic hasMessage, message;
@dynamic state;
@dynamic firstUnreadDate;
@dynamic hasAttributes, attributes;
@dynamic hasPinnedMessages, pinnedMessages;
@dynamic hasHistoryMessage, historyMessage;
@dynamic lastReceive;
@dynamic lastRead;
@dynamic lastReactionAt;
@dynamic readLater;
@dynamic dialogType;
@dynamic isMuted;

typedef struct Dialog__storage_ {
  uint32_t _has_storage_[1];
  int32_t unreadCount;
  MessageState state;
  Peer *peer;
  NSString *senderUserId;
  GPBBoolValue *isFavourite;
  UUIDValue *mid;
  MessageContent *message;
  MessageAttributes *attributes;
  PinnedMessages *pinnedMessages;
  HistoryMessage *historyMessage;
  NSString *dialogType;
  int64_t sortDate;
  int64_t date;
  int64_t firstUnreadDate;
  int64_t lastReceive;
  int64_t lastRead;
  int64_t lastReactionAt;
} Dialog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = Dialog_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Dialog__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unreadCount",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_UnreadCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Dialog__storage_, unreadCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sortDate",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_SortDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Dialog__storage_, sortDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "senderUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_SenderUserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Dialog__storage_, senderUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isFavourite",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = Dialog_FieldNumber_IsFavourite,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Dialog__storage_, isFavourite),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = Dialog_FieldNumber_Mid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Dialog__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_Date,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Dialog__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = Dialog_FieldNumber_Message,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Dialog__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = MessageState_EnumDescriptor,
        .number = Dialog_FieldNumber_State,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Dialog__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "firstUnreadDate",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_FirstUnreadDate,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Dialog__storage_, firstUnreadDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "attributes",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageAttributes),
        .number = Dialog_FieldNumber_Attributes,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Dialog__storage_, attributes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pinnedMessages",
        .dataTypeSpecific.clazz = GPBObjCClass(PinnedMessages),
        .number = Dialog_FieldNumber_PinnedMessages,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Dialog__storage_, pinnedMessages),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "historyMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(HistoryMessage),
        .number = Dialog_FieldNumber_HistoryMessage,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Dialog__storage_, historyMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastReceive",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_LastReceive,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Dialog__storage_, lastReceive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastRead",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_LastRead,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Dialog__storage_, lastRead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastReactionAt",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_LastReactionAt,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Dialog__storage_, lastReactionAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "readLater",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_ReadLater,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "dialogType",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_DialogType,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(Dialog__storage_, dialogType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isMuted",
        .dataTypeSpecific.clazz = Nil,
        .number = Dialog_FieldNumber_IsMuted,
        .hasIndex = 19,
        .offset = 20,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Dialog class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Dialog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Dialog_State_RawValue(Dialog *message) {
  GPBDescriptor *descriptor = [Dialog descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Dialog_FieldNumber_State];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDialog_State_RawValue(Dialog *message, int32_t value) {
  GPBDescriptor *descriptor = [Dialog descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Dialog_FieldNumber_State];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - RequestLoadDialogs

@implementation RequestLoadDialogs

@dynamic minDate;
@dynamic limit;
@dynamic filtersArray, filtersArray_Count;
@dynamic peersToLoadArray, peersToLoadArray_Count;

typedef struct RequestLoadDialogs__storage_ {
  uint32_t _has_storage_[1];
  int32_t limit;
  GPBEnumArray *filtersArray;
  NSMutableArray *peersToLoadArray;
  int64_t minDate;
} RequestLoadDialogs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minDate",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadDialogs_FieldNumber_MinDate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadDialogs__storage_, minDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadDialogs_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestLoadDialogs__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "filtersArray",
        .dataTypeSpecific.enumDescFunc = DialogsFilter_EnumDescriptor,
        .number = RequestLoadDialogs_FieldNumber_FiltersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestLoadDialogs__storage_, filtersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "peersToLoadArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestLoadDialogs_FieldNumber_PeersToLoadArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestLoadDialogs__storage_, peersToLoadArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadDialogs class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadDialogs__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseLoadDialogs

@implementation ResponseLoadDialogs

@dynamic dialogsArray, dialogsArray_Count;
@dynamic userPeersArray, userPeersArray_Count;
@dynamic groupPeersArray, groupPeersArray_Count;

typedef struct ResponseLoadDialogs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dialogsArray;
  NSMutableArray *userPeersArray;
  NSMutableArray *groupPeersArray;
} ResponseLoadDialogs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dialogsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Dialog),
        .number = ResponseLoadDialogs_FieldNumber_DialogsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadDialogs__storage_, dialogsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOutPeer),
        .number = ResponseLoadDialogs_FieldNumber_UserPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadDialogs__storage_, userPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupOutPeer),
        .number = ResponseLoadDialogs_FieldNumber_GroupPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadDialogs__storage_, groupPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadDialogs class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadDialogs__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DialogData

@implementation DialogData

@dynamic isFavourite;
@dynamic createdAt;
@dynamic clock;
@dynamic isMuted;

typedef struct DialogData__storage_ {
  uint32_t _has_storage_[1];
  int64_t createdAt;
  int64_t clock;
} DialogData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isFavourite",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogData_FieldNumber_IsFavourite,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogData_FieldNumber_CreatedAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DialogData__storage_, createdAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "clock",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogData_FieldNumber_Clock,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DialogData__storage_, clock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isMuted",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogData_FieldNumber_IsMuted,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DialogData class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DialogData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DialogIndex

@implementation DialogIndex

@dynamic hasPeer, peer;
@dynamic lastMessageDate;
@dynamic hasData_p, data_p;

typedef struct DialogIndex__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  DialogData *data_p;
  int64_t lastMessageDate;
} DialogIndex__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = DialogIndex_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DialogIndex__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastMessageDate",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogIndex_FieldNumber_LastMessageDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DialogIndex__storage_, lastMessageDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = GPBObjCClass(DialogData),
        .number = DialogIndex_FieldNumber_Data_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DialogIndex__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DialogIndex class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DialogIndex__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DialogListEntry

@implementation DialogListEntry

@dynamic hasPeer, peer;
@dynamic unreadCounterClock;
@dynamic unreadCount;
@dynamic myReadDate;
@dynamic lastMessageDate;
@dynamic receiveDate;
@dynamic readDate;
@dynamic entryClock;
@dynamic lastUpdateOfMessageDate;
@dynamic lastReactionDate;
@dynamic readLater;
@dynamic dialogType;
@dynamic hasData_p, data_p;

typedef struct DialogListEntry__storage_ {
  uint32_t _has_storage_[1];
  int32_t unreadCount;
  Peer *peer;
  NSString *dialogType;
  DialogData *data_p;
  int64_t unreadCounterClock;
  int64_t myReadDate;
  int64_t lastMessageDate;
  int64_t receiveDate;
  int64_t readDate;
  int64_t entryClock;
  int64_t lastUpdateOfMessageDate;
  int64_t lastReactionDate;
} DialogListEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = DialogListEntry_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DialogListEntry__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unreadCounterClock",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogListEntry_FieldNumber_UnreadCounterClock,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DialogListEntry__storage_, unreadCounterClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unreadCount",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogListEntry_FieldNumber_UnreadCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DialogListEntry__storage_, unreadCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "myReadDate",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogListEntry_FieldNumber_MyReadDate,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DialogListEntry__storage_, myReadDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastMessageDate",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogListEntry_FieldNumber_LastMessageDate,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DialogListEntry__storage_, lastMessageDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "receiveDate",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogListEntry_FieldNumber_ReceiveDate,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DialogListEntry__storage_, receiveDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "readDate",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogListEntry_FieldNumber_ReadDate,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DialogListEntry__storage_, readDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "entryClock",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogListEntry_FieldNumber_EntryClock,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DialogListEntry__storage_, entryClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastUpdateOfMessageDate",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogListEntry_FieldNumber_LastUpdateOfMessageDate,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DialogListEntry__storage_, lastUpdateOfMessageDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastReactionDate",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogListEntry_FieldNumber_LastReactionDate,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DialogListEntry__storage_, lastReactionDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "readLater",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogListEntry_FieldNumber_ReadLater,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "dialogType",
        .dataTypeSpecific.clazz = Nil,
        .number = DialogListEntry_FieldNumber_DialogType,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(DialogListEntry__storage_, dialogType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = GPBObjCClass(DialogData),
        .number = DialogListEntry_FieldNumber_Data_p,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(DialogListEntry__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DialogListEntry class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DialogListEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestFetchDialogIndex

@implementation RequestFetchDialogIndex


typedef struct RequestFetchDialogIndex__storage_ {
  uint32_t _has_storage_[1];
} RequestFetchDialogIndex__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestFetchDialogIndex class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RequestFetchDialogIndex__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseFetchDialogIndex

@implementation ResponseFetchDialogIndex

@dynamic dialogIndicesArray, dialogIndicesArray_Count;

typedef struct ResponseFetchDialogIndex__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dialogIndicesArray;
} ResponseFetchDialogIndex__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dialogIndicesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DialogIndex),
        .number = ResponseFetchDialogIndex_FieldNumber_DialogIndicesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseFetchDialogIndex__storage_, dialogIndicesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseFetchDialogIndex class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseFetchDialogIndex__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestDialogListDifference

@implementation RequestDialogListDifference

@dynamic fromClock;

typedef struct RequestDialogListDifference__storage_ {
  uint32_t _has_storage_[1];
  int64_t fromClock;
} RequestDialogListDifference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromClock",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestDialogListDifference_FieldNumber_FromClock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestDialogListDifference__storage_, fromClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestDialogListDifference class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestDialogListDifference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseDialogListDifference

@implementation ResponseDialogListDifference

@dynamic entriesArray, entriesArray_Count;
@dynamic clock;
@dynamic prevClock;

typedef struct ResponseDialogListDifference__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *entriesArray;
  int64_t clock;
  int64_t prevClock;
} ResponseDialogListDifference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "entriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DialogListEntry),
        .number = ResponseDialogListDifference_FieldNumber_EntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseDialogListDifference__storage_, entriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clock",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseDialogListDifference_FieldNumber_Clock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseDialogListDifference__storage_, clock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "prevClock",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseDialogListDifference_FieldNumber_PrevClock,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseDialogListDifference__storage_, prevClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseDialogListDifference class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseDialogListDifference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestGetLastConversationMessages

@implementation RequestGetLastConversationMessages

@dynamic peersArray, peersArray_Count;

typedef struct RequestGetLastConversationMessages__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersArray;
} RequestGetLastConversationMessages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestGetLastConversationMessages_FieldNumber_PeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestGetLastConversationMessages__storage_, peersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestGetLastConversationMessages class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestGetLastConversationMessages__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetLastConversationMessages

@implementation ResponseGetLastConversationMessages

@dynamic messagesArray, messagesArray_Count;

typedef struct ResponseGetLastConversationMessages__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *messagesArray;
} ResponseGetLastConversationMessages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messagesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseGetLastConversationMessages_Pair),
        .number = ResponseGetLastConversationMessages_FieldNumber_MessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseGetLastConversationMessages__storage_, messagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetLastConversationMessages class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetLastConversationMessages__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetLastConversationMessages_Pair

@implementation ResponseGetLastConversationMessages_Pair

@dynamic hasPeer, peer;
@dynamic hasMessage, message;

typedef struct ResponseGetLastConversationMessages_Pair__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  HistoryMessage *message;
} ResponseGetLastConversationMessages_Pair__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = ResponseGetLastConversationMessages_Pair_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseGetLastConversationMessages_Pair__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(HistoryMessage),
        .number = ResponseGetLastConversationMessages_Pair_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseGetLastConversationMessages_Pair__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetLastConversationMessages_Pair class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetLastConversationMessages_Pair__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ResponseGetLastConversationMessages)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestFavouriteDialog

@implementation RequestFavouriteDialog

@dynamic hasPeer, peer;

typedef struct RequestFavouriteDialog__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
} RequestFavouriteDialog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestFavouriteDialog_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestFavouriteDialog__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestFavouriteDialog class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestFavouriteDialog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestUnfavouriteDialog

@implementation RequestUnfavouriteDialog

@dynamic hasPeer, peer;

typedef struct RequestUnfavouriteDialog__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
} RequestUnfavouriteDialog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestUnfavouriteDialog_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestUnfavouriteDialog__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestUnfavouriteDialog class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestUnfavouriteDialog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateDialogFavouriteChanged

@implementation UpdateDialogFavouriteChanged

@dynamic hasPeer, peer;
@dynamic hasIsFavourite, isFavourite;

typedef struct UpdateDialogFavouriteChanged__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  GPBBoolValue *isFavourite;
} UpdateDialogFavouriteChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateDialogFavouriteChanged_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateDialogFavouriteChanged__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFavourite",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = UpdateDialogFavouriteChanged_FieldNumber_IsFavourite,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateDialogFavouriteChanged__storage_, isFavourite),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateDialogFavouriteChanged class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateDialogFavouriteChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateDialogMuteChanged

@implementation UpdateDialogMuteChanged

@dynamic hasPeer, peer;
@dynamic isMuted;

typedef struct UpdateDialogMuteChanged__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
} UpdateDialogMuteChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateDialogMuteChanged_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateDialogMuteChanged__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isMuted",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateDialogMuteChanged_FieldNumber_IsMuted,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateDialogMuteChanged class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateDialogMuteChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestNotifyDialogOpened

@implementation RequestNotifyDialogOpened

@dynamic hasPeer, peer;

typedef struct RequestNotifyDialogOpened__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
} RequestNotifyDialogOpened__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestNotifyDialogOpened_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestNotifyDialogOpened__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestNotifyDialogOpened class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestNotifyDialogOpened__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PinnedMessages

@implementation PinnedMessages

@dynamic midsArray, midsArray_Count;

typedef struct PinnedMessages__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *midsArray;
} PinnedMessages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "midsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = PinnedMessages_FieldNumber_MidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PinnedMessages__storage_, midsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PinnedMessages class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PinnedMessages__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestPinMessage

@implementation RequestPinMessage

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic lastPinDate;

typedef struct RequestPinMessage__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  UUIDValue *mid;
  int64_t lastPinDate;
} RequestPinMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestPinMessage_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestPinMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestPinMessage_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestPinMessage__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastPinDate",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestPinMessage_FieldNumber_LastPinDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestPinMessage__storage_, lastPinDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestPinMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestPinMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestUnpinMessage

@implementation RequestUnpinMessage

@dynamic hasPeer, peer;
@dynamic hasMid, mid;
@dynamic lastPinDate;

typedef struct RequestUnpinMessage__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
  UUIDValue *mid;
  int64_t lastPinDate;
} RequestUnpinMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestUnpinMessage_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestUnpinMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestUnpinMessage_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestUnpinMessage__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastPinDate",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestUnpinMessage_FieldNumber_LastPinDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestUnpinMessage__storage_, lastPinDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestUnpinMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestUnpinMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdatePinnedMessagesChanged

@implementation UpdatePinnedMessagesChanged

@dynamic hasPeer, peer;
@dynamic hasPinnedMessages, pinnedMessages;
@dynamic actionDate;

typedef struct UpdatePinnedMessagesChanged__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  PinnedMessages *pinnedMessages;
  int64_t actionDate;
} UpdatePinnedMessagesChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdatePinnedMessagesChanged_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdatePinnedMessagesChanged__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pinnedMessages",
        .dataTypeSpecific.clazz = GPBObjCClass(PinnedMessages),
        .number = UpdatePinnedMessagesChanged_FieldNumber_PinnedMessages,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdatePinnedMessagesChanged__storage_, pinnedMessages),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionDate",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdatePinnedMessagesChanged_FieldNumber_ActionDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdatePinnedMessagesChanged__storage_, actionDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdatePinnedMessagesChanged class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdatePinnedMessagesChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestGetUpdatedMessages

@implementation RequestGetUpdatedMessages

@dynamic hasPeer, peer;
@dynamic fromClock;

typedef struct RequestGetUpdatedMessages__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  int64_t fromClock;
} RequestGetUpdatedMessages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestGetUpdatedMessages_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestGetUpdatedMessages__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fromClock",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestGetUpdatedMessages_FieldNumber_FromClock,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestGetUpdatedMessages__storage_, fromClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestGetUpdatedMessages class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestGetUpdatedMessages__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetUpdatedMessages

@implementation ResponseGetUpdatedMessages

@dynamic messagesArray, messagesArray_Count;
@dynamic peerClock;
@dynamic nextAvailable;

typedef struct ResponseGetUpdatedMessages__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *messagesArray;
  int64_t peerClock;
} ResponseGetUpdatedMessages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messagesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseGetUpdatedMessages_UpdatedMessage),
        .number = ResponseGetUpdatedMessages_FieldNumber_MessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseGetUpdatedMessages__storage_, messagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "peerClock",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseGetUpdatedMessages_FieldNumber_PeerClock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseGetUpdatedMessages__storage_, peerClock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "nextAvailable",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseGetUpdatedMessages_FieldNumber_NextAvailable,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetUpdatedMessages class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetUpdatedMessages__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetUpdatedMessages_UpdatedMessage

@implementation ResponseGetUpdatedMessages_UpdatedMessage

@dynamic hasMid, mid;
@dynamic hasMessage, message;
@dynamic modifiedAt;

typedef struct ResponseGetUpdatedMessages_UpdatedMessage__storage_ {
  uint32_t _has_storage_[1];
  UUIDValue *mid;
  MessageContent *message;
  int64_t modifiedAt;
} ResponseGetUpdatedMessages_UpdatedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = ResponseGetUpdatedMessages_UpdatedMessage_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseGetUpdatedMessages_UpdatedMessage__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = ResponseGetUpdatedMessages_UpdatedMessage_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseGetUpdatedMessages_UpdatedMessage__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "modifiedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseGetUpdatedMessages_UpdatedMessage_FieldNumber_ModifiedAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseGetUpdatedMessages_UpdatedMessage__storage_, modifiedAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetUpdatedMessages_UpdatedMessage class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetUpdatedMessages_UpdatedMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ResponseGetUpdatedMessages)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageStatus

@implementation MessageStatus

@dynamic clock;
@dynamic userId;

typedef struct MessageStatus__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  int64_t clock;
} MessageStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clock",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageStatus_FieldNumber_Clock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageStatus__storage_, clock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageStatus_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageStatus__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageStatus class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageReads

@implementation RequestMessageReads

@dynamic hasMid, mid;
@dynamic limit;
@dynamic timestampFrom;

typedef struct RequestMessageReads__storage_ {
  uint32_t _has_storage_[1];
  int32_t limit;
  UUIDValue *mid;
  int64_t timestampFrom;
} RequestMessageReads__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestMessageReads_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageReads__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageReads_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestMessageReads__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestampFrom",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageReads_FieldNumber_TimestampFrom,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestMessageReads__storage_, timestampFrom),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageReads class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageReads__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageReceives

@implementation RequestMessageReceives

@dynamic hasMid, mid;
@dynamic limit;
@dynamic timestampFrom;

typedef struct RequestMessageReceives__storage_ {
  uint32_t _has_storage_[1];
  int32_t limit;
  UUIDValue *mid;
  int64_t timestampFrom;
} RequestMessageReceives__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = RequestMessageReceives_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageReceives__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageReceives_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestMessageReceives__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestampFrom",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageReceives_FieldNumber_TimestampFrom,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestMessageReceives__storage_, timestampFrom),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageReceives class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageReceives__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseMessageReads

@implementation ResponseMessageReads

@dynamic statusArray, statusArray_Count;
@dynamic timestampTill;
@dynamic lastReadDate;
@dynamic counter;

typedef struct ResponseMessageReads__storage_ {
  uint32_t _has_storage_[1];
  int32_t counter;
  NSMutableArray *statusArray;
  int64_t timestampTill;
  int64_t lastReadDate;
} ResponseMessageReads__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageStatus),
        .number = ResponseMessageReads_FieldNumber_StatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseMessageReads__storage_, statusArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestampTill",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMessageReads_FieldNumber_TimestampTill,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseMessageReads__storage_, timestampTill),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastReadDate",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMessageReads_FieldNumber_LastReadDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseMessageReads__storage_, lastReadDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "counter",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMessageReads_FieldNumber_Counter,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseMessageReads__storage_, counter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseMessageReads class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseMessageReads__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseMessageReceives

@implementation ResponseMessageReceives

@dynamic statusArray, statusArray_Count;
@dynamic timestampTill;

typedef struct ResponseMessageReceives__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *statusArray;
  int64_t timestampTill;
} ResponseMessageReceives__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageStatus),
        .number = ResponseMessageReceives_FieldNumber_StatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseMessageReceives__storage_, statusArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestampTill",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMessageReceives_FieldNumber_TimestampTill,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseMessageReceives__storage_, timestampTill),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseMessageReceives class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseMessageReceives__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestReadDialogLater

@implementation RequestReadDialogLater

@dynamic hasPeer, peer;
@dynamic readLater;

typedef struct RequestReadDialogLater__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
} RequestReadDialogLater__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = RequestReadDialogLater_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestReadDialogLater__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "readLater",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestReadDialogLater_FieldNumber_ReadLater,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestReadDialogLater class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestReadDialogLater__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateDialogReadLaterChanged

@implementation UpdateDialogReadLaterChanged

@dynamic hasPeer, peer;
@dynamic readLater;

typedef struct UpdateDialogReadLaterChanged__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
} UpdateDialogReadLaterChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = UpdateDialogReadLaterChanged_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateDialogReadLaterChanged__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "readLater",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateDialogReadLaterChanged_FieldNumber_ReadLater,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateDialogReadLaterChanged class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateDialogReadLaterChanged__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMuteChat

@implementation RequestMuteChat

@dynamic hasPeer, peer;
@dynamic hasDuration, duration;

typedef struct RequestMuteChat__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  GPBDuration *duration;
} RequestMuteChat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestMuteChat_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMuteChat__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = RequestMuteChat_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestMuteChat__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMuteChat class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMuteChat__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestUnmuteChat

@implementation RequestUnmuteChat

@dynamic hasPeer, peer;

typedef struct RequestUnmuteChat__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
} RequestUnmuteChat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = RequestUnmuteChat_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestUnmuteChat__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestUnmuteChat class]
                                     rootClass:[MessagingRoot class]
                                          file:MessagingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestUnmuteChat__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
