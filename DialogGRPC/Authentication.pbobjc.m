// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: authentication.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Authentication.pbobjc.h"
#import "Empty.pbobjc.h"
#import "Wrappers.pbobjc.h"
#import "Annotations.pbobjc.h"
#import "Definitions.pbobjc.h"
#import "Miscellaneous.pbobjc.h"
#import "Peers.pbobjc.h"
#import "Users.pbobjc.h"
#import "Scalapb.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AuthSession);
GPBObjCClassDeclaration(Config);
GPBObjCClassDeclaration(ForceReloadContacts);
GPBObjCClassDeclaration(ForceReloadDialogs);
GPBObjCClassDeclaration(ForceReloadHistory);
GPBObjCClassDeclaration(GPBDoubleValue);
GPBObjCClassDeclaration(GPBInt64Value);
GPBObjCClassDeclaration(GPBStringValue);
GPBObjCClassDeclaration(Peer);
GPBObjCClassDeclaration(User);

#pragma mark - AuthenticationRoot

@implementation AuthenticationRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[GAPIAnnotationsRoot extensionRegistry]];
    [registry addExtensions:[DefinitionsRoot extensionRegistry]];
    [registry addExtensions:[ScalapbRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - AuthenticationRoot_FileDescriptor

static GPBFileDescriptor *AuthenticationRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"dialog"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PhoneActivationType

GPBEnumDescriptor *PhoneActivationType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PhoneActivationTypeUnknown\000PhoneActivati"
        "onTypeCode\000PhoneActivationTypePassword\000";
    static const int32_t values[] = {
        PhoneActivationType_PhoneActivationTypeUnknown,
        PhoneActivationType_PhoneActivationTypeCode,
        PhoneActivationType_PhoneActivationTypePassword,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PhoneActivationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PhoneActivationType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PhoneActivationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PhoneActivationType_PhoneActivationTypeUnknown:
    case PhoneActivationType_PhoneActivationTypeCode:
    case PhoneActivationType_PhoneActivationTypePassword:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EmailActivationType

GPBEnumDescriptor *EmailActivationType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EmailActivationTypeUnknown\000EmailActivati"
        "onTypeCode\000EmailActivationTypeOauth2\000Ema"
        "ilActivationTypePassword\000";
    static const int32_t values[] = {
        EmailActivationType_EmailActivationTypeUnknown,
        EmailActivationType_EmailActivationTypeCode,
        EmailActivationType_EmailActivationTypeOauth2,
        EmailActivationType_EmailActivationTypePassword,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EmailActivationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EmailActivationType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EmailActivationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case EmailActivationType_EmailActivationTypeUnknown:
    case EmailActivationType_EmailActivationTypeCode:
    case EmailActivationType_EmailActivationTypeOauth2:
    case EmailActivationType_EmailActivationTypePassword:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AuthExtraInfoType

GPBEnumDescriptor *AuthExtraInfoType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AuthExtraInfoTypeNone\000AuthExtraInfoTypeN"
        "eedChangePassword\000";
    static const int32_t values[] = {
        AuthExtraInfoType_AuthExtraInfoTypeNone,
        AuthExtraInfoType_AuthExtraInfoTypeNeedChangePassword,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AuthExtraInfoType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AuthExtraInfoType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AuthExtraInfoType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AuthExtraInfoType_AuthExtraInfoTypeNone:
    case AuthExtraInfoType_AuthExtraInfoTypeNeedChangePassword:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AuthHolder

GPBEnumDescriptor *AuthHolder_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AuthHolderUnknown\000AuthHolderThisdevice\000A"
        "uthHolderOtherdevice\000";
    static const int32_t values[] = {
        AuthHolder_AuthHolderUnknown,
        AuthHolder_AuthHolderThisdevice,
        AuthHolder_AuthHolderOtherdevice,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AuthHolder)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AuthHolder_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AuthHolder_IsValidValue(int32_t value__) {
  switch (value__) {
    case AuthHolder_AuthHolderUnknown:
    case AuthHolder_AuthHolderThisdevice:
    case AuthHolder_AuthHolderOtherdevice:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RequestStartPhoneAuth

@implementation RequestStartPhoneAuth

@dynamic phoneNumber;
@dynamic hasTimeZone, timeZone;
@dynamic preferredLanguagesArray, preferredLanguagesArray_Count;

typedef struct RequestStartPhoneAuth__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *timeZone;
  NSMutableArray *preferredLanguagesArray;
  int64_t phoneNumber;
} RequestStartPhoneAuth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phoneNumber",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestStartPhoneAuth_FieldNumber_PhoneNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestStartPhoneAuth__storage_, phoneNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestStartPhoneAuth_FieldNumber_TimeZone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestStartPhoneAuth__storage_, timeZone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "preferredLanguagesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestStartPhoneAuth_FieldNumber_PreferredLanguagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestStartPhoneAuth__storage_, preferredLanguagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestStartPhoneAuth class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestStartPhoneAuth__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseStartPhoneAuth

@implementation ResponseStartPhoneAuth

@dynamic transactionHash;
@dynamic isRegistered;
@dynamic activationType;

typedef struct ResponseStartPhoneAuth__storage_ {
  uint32_t _has_storage_[1];
  PhoneActivationType activationType;
  NSString *transactionHash;
} ResponseStartPhoneAuth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseStartPhoneAuth_FieldNumber_TransactionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseStartPhoneAuth__storage_, transactionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isRegistered",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseStartPhoneAuth_FieldNumber_IsRegistered,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "activationType",
        .dataTypeSpecific.enumDescFunc = PhoneActivationType_EnumDescriptor,
        .number = ResponseStartPhoneAuth_FieldNumber_ActivationType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseStartPhoneAuth__storage_, activationType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseStartPhoneAuth class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseStartPhoneAuth__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ResponseStartPhoneAuth_ActivationType_RawValue(ResponseStartPhoneAuth *message) {
  GPBDescriptor *descriptor = [ResponseStartPhoneAuth descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseStartPhoneAuth_FieldNumber_ActivationType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetResponseStartPhoneAuth_ActivationType_RawValue(ResponseStartPhoneAuth *message, int32_t value) {
  GPBDescriptor *descriptor = [ResponseStartPhoneAuth descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseStartPhoneAuth_FieldNumber_ActivationType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - RequestSendCodeByPhoneCall

@implementation RequestSendCodeByPhoneCall

@dynamic transactionHash;

typedef struct RequestSendCodeByPhoneCall__storage_ {
  uint32_t _has_storage_[1];
  NSString *transactionHash;
} RequestSendCodeByPhoneCall__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSendCodeByPhoneCall_FieldNumber_TransactionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestSendCodeByPhoneCall__storage_, transactionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestSendCodeByPhoneCall class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestSendCodeByPhoneCall__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestStartEmailAuth

@implementation RequestStartEmailAuth

@dynamic email;
@dynamic hasTimeZone, timeZone;
@dynamic preferredLanguagesArray, preferredLanguagesArray_Count;

typedef struct RequestStartEmailAuth__storage_ {
  uint32_t _has_storage_[1];
  NSString *email;
  GPBStringValue *timeZone;
  NSMutableArray *preferredLanguagesArray;
} RequestStartEmailAuth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "email",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestStartEmailAuth_FieldNumber_Email,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestStartEmailAuth__storage_, email),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestStartEmailAuth_FieldNumber_TimeZone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestStartEmailAuth__storage_, timeZone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "preferredLanguagesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestStartEmailAuth_FieldNumber_PreferredLanguagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestStartEmailAuth__storage_, preferredLanguagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestStartEmailAuth class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestStartEmailAuth__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseStartEmailAuth

@implementation ResponseStartEmailAuth

@dynamic transactionHash;
@dynamic isRegistered;
@dynamic activationType;

typedef struct ResponseStartEmailAuth__storage_ {
  uint32_t _has_storage_[1];
  EmailActivationType activationType;
  NSString *transactionHash;
} ResponseStartEmailAuth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseStartEmailAuth_FieldNumber_TransactionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseStartEmailAuth__storage_, transactionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isRegistered",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseStartEmailAuth_FieldNumber_IsRegistered,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "activationType",
        .dataTypeSpecific.enumDescFunc = EmailActivationType_EnumDescriptor,
        .number = ResponseStartEmailAuth_FieldNumber_ActivationType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseStartEmailAuth__storage_, activationType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseStartEmailAuth class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseStartEmailAuth__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ResponseStartEmailAuth_ActivationType_RawValue(ResponseStartEmailAuth *message) {
  GPBDescriptor *descriptor = [ResponseStartEmailAuth descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseStartEmailAuth_FieldNumber_ActivationType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetResponseStartEmailAuth_ActivationType_RawValue(ResponseStartEmailAuth *message, int32_t value) {
  GPBDescriptor *descriptor = [ResponseStartEmailAuth descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseStartEmailAuth_FieldNumber_ActivationType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - RequestStartCertificateAuth

@implementation RequestStartCertificateAuth

@dynamic name;
@dynamic hasTimeZone, timeZone;
@dynamic preferredLanguagesArray, preferredLanguagesArray_Count;

typedef struct RequestStartCertificateAuth__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  GPBStringValue *timeZone;
  NSMutableArray *preferredLanguagesArray;
} RequestStartCertificateAuth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestStartCertificateAuth_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestStartCertificateAuth__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestStartCertificateAuth_FieldNumber_TimeZone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestStartCertificateAuth__storage_, timeZone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "preferredLanguagesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestStartCertificateAuth_FieldNumber_PreferredLanguagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestStartCertificateAuth__storage_, preferredLanguagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestStartCertificateAuth class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestStartCertificateAuth__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestStartTokenAuth

@implementation RequestStartTokenAuth

@dynamic token;
@dynamic hasTimeZone, timeZone;
@dynamic preferredLanguagesArray, preferredLanguagesArray_Count;

typedef struct RequestStartTokenAuth__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  GPBStringValue *timeZone;
  NSMutableArray *preferredLanguagesArray;
} RequestStartTokenAuth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestStartTokenAuth_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestStartTokenAuth__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestStartTokenAuth_FieldNumber_TimeZone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestStartTokenAuth__storage_, timeZone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "preferredLanguagesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestStartTokenAuth_FieldNumber_PreferredLanguagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestStartTokenAuth__storage_, preferredLanguagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestStartTokenAuth class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestStartTokenAuth__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestStartUsernameAuth

@implementation RequestStartUsernameAuth

@dynamic username;
@dynamic hasTimeZone, timeZone;
@dynamic preferredLanguagesArray, preferredLanguagesArray_Count;

typedef struct RequestStartUsernameAuth__storage_ {
  uint32_t _has_storage_[1];
  NSString *username;
  GPBStringValue *timeZone;
  NSMutableArray *preferredLanguagesArray;
} RequestStartUsernameAuth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestStartUsernameAuth_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestStartUsernameAuth__storage_, username),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestStartUsernameAuth_FieldNumber_TimeZone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestStartUsernameAuth__storage_, timeZone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "preferredLanguagesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestStartUsernameAuth_FieldNumber_PreferredLanguagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestStartUsernameAuth__storage_, preferredLanguagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestStartUsernameAuth class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestStartUsernameAuth__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseStartUsernameAuth

@implementation ResponseStartUsernameAuth

@dynamic transactionHash;
@dynamic isRegistered;

typedef struct ResponseStartUsernameAuth__storage_ {
  uint32_t _has_storage_[1];
  NSString *transactionHash;
} ResponseStartUsernameAuth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseStartUsernameAuth_FieldNumber_TransactionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseStartUsernameAuth__storage_, transactionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isRegistered",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseStartUsernameAuth_FieldNumber_IsRegistered,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseStartUsernameAuth class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseStartUsernameAuth__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestApplyExternalSessionAuth

@implementation RequestApplyExternalSessionAuth

@dynamic sessionId;

typedef struct RequestApplyExternalSessionAuth__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
} RequestApplyExternalSessionAuth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestApplyExternalSessionAuth_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestApplyExternalSessionAuth__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestApplyExternalSessionAuth class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestApplyExternalSessionAuth__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestGetIdToken

@implementation RequestGetIdToken

@dynamic service;

typedef struct RequestGetIdToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *service;
} RequestGetIdToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "service",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestGetIdToken_FieldNumber_Service,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestGetIdToken__storage_, service),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestGetIdToken class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestGetIdToken__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetIdToken

@implementation ResponseGetIdToken

@dynamic token;
@dynamic expirationDate;

typedef struct ResponseGetIdToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  int64_t expirationDate;
} ResponseGetIdToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseGetIdToken_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseGetIdToken__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expirationDate",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseGetIdToken_FieldNumber_ExpirationDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseGetIdToken__storage_, expirationDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetIdToken class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetIdToken__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestStartAuthTransaction

@implementation RequestStartAuthTransaction

@dynamic hasTimeZone, timeZone;
@dynamic preferredLanguagesArray, preferredLanguagesArray_Count;

typedef struct RequestStartAuthTransaction__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *timeZone;
  NSMutableArray *preferredLanguagesArray;
} RequestStartAuthTransaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeZone",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestStartAuthTransaction_FieldNumber_TimeZone,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestStartAuthTransaction__storage_, timeZone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "preferredLanguagesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestStartAuthTransaction_FieldNumber_PreferredLanguagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestStartAuthTransaction__storage_, preferredLanguagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestStartAuthTransaction class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestStartAuthTransaction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseStartAuthTransaction

@implementation ResponseStartAuthTransaction

@dynamic transactionHash;

typedef struct ResponseStartAuthTransaction__storage_ {
  uint32_t _has_storage_[1];
  NSString *transactionHash;
} ResponseStartAuthTransaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseStartAuthTransaction_FieldNumber_TransactionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseStartAuthTransaction__storage_, transactionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseStartAuthTransaction class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseStartAuthTransaction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestValidateCode

@implementation RequestValidateCode

@dynamic transactionHash;
@dynamic code;

typedef struct RequestValidateCode__storage_ {
  uint32_t _has_storage_[1];
  NSString *transactionHash;
  NSString *code;
} RequestValidateCode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestValidateCode_FieldNumber_TransactionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestValidateCode__storage_, transactionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestValidateCode_FieldNumber_Code,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestValidateCode__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestValidateCode class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestValidateCode__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestResendCode

@implementation RequestResendCode

@dynamic transactionHash;

typedef struct RequestResendCode__storage_ {
  uint32_t _has_storage_[1];
  NSString *transactionHash;
} RequestResendCode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestResendCode_FieldNumber_TransactionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestResendCode__storage_, transactionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestResendCode class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestResendCode__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestValidatePassword

@implementation RequestValidatePassword

@dynamic transactionHash;
@dynamic password;

typedef struct RequestValidatePassword__storage_ {
  uint32_t _has_storage_[1];
  NSString *transactionHash;
  NSString *password;
} RequestValidatePassword__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestValidatePassword_FieldNumber_TransactionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestValidatePassword__storage_, transactionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestValidatePassword_FieldNumber_Password,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestValidatePassword__storage_, password),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestValidatePassword class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestValidatePassword__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestGetOAuth2Params

@implementation RequestGetOAuth2Params

@dynamic transactionHash;
@dynamic redirectURL;

typedef struct RequestGetOAuth2Params__storage_ {
  uint32_t _has_storage_[1];
  NSString *transactionHash;
  NSString *redirectURL;
} RequestGetOAuth2Params__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestGetOAuth2Params_FieldNumber_TransactionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestGetOAuth2Params__storage_, transactionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "redirectURL",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestGetOAuth2Params_FieldNumber_RedirectURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestGetOAuth2Params__storage_, redirectURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestGetOAuth2Params class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestGetOAuth2Params__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetOAuth2Params

@implementation ResponseGetOAuth2Params

@dynamic authURL;

typedef struct ResponseGetOAuth2Params__storage_ {
  uint32_t _has_storage_[1];
  NSString *authURL;
} ResponseGetOAuth2Params__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authURL",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseGetOAuth2Params_FieldNumber_AuthURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseGetOAuth2Params__storage_, authURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetOAuth2Params class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetOAuth2Params__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestCompleteOAuth2

@implementation RequestCompleteOAuth2

@dynamic transactionHash;
@dynamic code;

typedef struct RequestCompleteOAuth2__storage_ {
  uint32_t _has_storage_[1];
  NSString *transactionHash;
  NSString *code;
} RequestCompleteOAuth2__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestCompleteOAuth2_FieldNumber_TransactionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestCompleteOAuth2__storage_, transactionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestCompleteOAuth2_FieldNumber_Code,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestCompleteOAuth2__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestCompleteOAuth2 class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestCompleteOAuth2__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestSignUp

@implementation RequestSignUp

@dynamic transactionHash;
@dynamic name;
@dynamic sex;
@dynamic hasPassword, password;

typedef struct RequestSignUp__storage_ {
  uint32_t _has_storage_[1];
  Sex sex;
  NSString *transactionHash;
  NSString *name;
  GPBStringValue *password;
} RequestSignUp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSignUp_FieldNumber_TransactionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestSignUp__storage_, transactionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSignUp_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestSignUp__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = Sex_EnumDescriptor,
        .number = RequestSignUp_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestSignUp__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "password",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestSignUp_FieldNumber_Password,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestSignUp__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestSignUp class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestSignUp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RequestSignUp_Sex_RawValue(RequestSignUp *message) {
  GPBDescriptor *descriptor = [RequestSignUp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestSignUp_FieldNumber_Sex];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRequestSignUp_Sex_RawValue(RequestSignUp *message, int32_t value) {
  GPBDescriptor *descriptor = [RequestSignUp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestSignUp_FieldNumber_Sex];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ResponseAuth

@implementation ResponseAuth

@dynamic hasUser, user;
@dynamic hasConfig, config;
@dynamic hasConfigHash, configHash;
@dynamic extraInfoArray, extraInfoArray_Count;

typedef struct ResponseAuth__storage_ {
  uint32_t _has_storage_[1];
  User *user;
  Config *config;
  GPBInt64Value *configHash;
  GPBEnumArray *extraInfoArray;
} ResponseAuth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.clazz = GPBObjCClass(User),
        .number = ResponseAuth_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseAuth__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "config",
        .dataTypeSpecific.clazz = GPBObjCClass(Config),
        .number = ResponseAuth_FieldNumber_Config,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseAuth__storage_, config),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "configHash",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = ResponseAuth_FieldNumber_ConfigHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseAuth__storage_, configHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extraInfoArray",
        .dataTypeSpecific.enumDescFunc = AuthExtraInfoType_EnumDescriptor,
        .number = ResponseAuth_FieldNumber_ExtraInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseAuth__storage_, extraInfoArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseAuth class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseAuth__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthSession

@implementation AuthSession

@dynamic id_p;
@dynamic authHolder;
@dynamic appId;
@dynamic appTitle;
@dynamic deviceTitle;
@dynamic authTime;
@dynamic authLocation;
@dynamic hasLatitude, latitude;
@dynamic hasLongitude, longitude;

typedef struct AuthSession__storage_ {
  uint32_t _has_storage_[1];
  AuthHolder authHolder;
  int32_t appId;
  int32_t authTime;
  NSString *id_p;
  NSString *appTitle;
  NSString *deviceTitle;
  NSString *authLocation;
  GPBDoubleValue *latitude;
  GPBDoubleValue *longitude;
} AuthSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthSession_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthSession__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authHolder",
        .dataTypeSpecific.enumDescFunc = AuthHolder_EnumDescriptor,
        .number = AuthSession_FieldNumber_AuthHolder,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthSession__storage_, authHolder),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "appId",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthSession_FieldNumber_AppId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthSession__storage_, appId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "appTitle",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthSession_FieldNumber_AppTitle,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuthSession__storage_, appTitle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceTitle",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthSession_FieldNumber_DeviceTitle,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AuthSession__storage_, deviceTitle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authTime",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthSession_FieldNumber_AuthTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AuthSession__storage_, authTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "authLocation",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthSession_FieldNumber_AuthLocation,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AuthSession__storage_, authLocation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDoubleValue),
        .number = AuthSession_FieldNumber_Latitude,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AuthSession__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDoubleValue),
        .number = AuthSession_FieldNumber_Longitude,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AuthSession__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthSession class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthSession__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AuthSession_AuthHolder_RawValue(AuthSession *message) {
  GPBDescriptor *descriptor = [AuthSession descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthSession_FieldNumber_AuthHolder];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAuthSession_AuthHolder_RawValue(AuthSession *message, int32_t value) {
  GPBDescriptor *descriptor = [AuthSession descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthSession_FieldNumber_AuthHolder];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - RequestGetAuthSessions

@implementation RequestGetAuthSessions


typedef struct RequestGetAuthSessions__storage_ {
  uint32_t _has_storage_[1];
} RequestGetAuthSessions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestGetAuthSessions class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RequestGetAuthSessions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetAuthSessions

@implementation ResponseGetAuthSessions

@dynamic userAuthsArray, userAuthsArray_Count;

typedef struct ResponseGetAuthSessions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userAuthsArray;
} ResponseGetAuthSessions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userAuthsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(AuthSession),
        .number = ResponseGetAuthSessions_FieldNumber_UserAuthsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseGetAuthSessions__storage_, userAuthsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetAuthSessions class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetAuthSessions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestTerminateSession

@implementation RequestTerminateSession

@dynamic id_p;

typedef struct RequestTerminateSession__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
} RequestTerminateSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestTerminateSession_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestTerminateSession__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestTerminateSession class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestTerminateSession__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestTerminateAllSessions

@implementation RequestTerminateAllSessions


typedef struct RequestTerminateAllSessions__storage_ {
  uint32_t _has_storage_[1];
} RequestTerminateAllSessions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestTerminateAllSessions class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RequestTerminateAllSessions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestSignOut

@implementation RequestSignOut


typedef struct RequestSignOut__storage_ {
  uint32_t _has_storage_[1];
} RequestSignOut__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestSignOut class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RequestSignOut__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ForceReloadField

@implementation ForceReloadField

@dynamic bodyOneOfCase;
@dynamic forceReloadDialogs;
@dynamic forceReloadContacts;
@dynamic forceReloadHistory;

typedef struct ForceReloadField__storage_ {
  uint32_t _has_storage_[2];
  ForceReloadDialogs *forceReloadDialogs;
  ForceReloadContacts *forceReloadContacts;
  ForceReloadHistory *forceReloadHistory;
} ForceReloadField__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "forceReloadDialogs",
        .dataTypeSpecific.clazz = GPBObjCClass(ForceReloadDialogs),
        .number = ForceReloadField_FieldNumber_ForceReloadDialogs,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ForceReloadField__storage_, forceReloadDialogs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "forceReloadContacts",
        .dataTypeSpecific.clazz = GPBObjCClass(ForceReloadContacts),
        .number = ForceReloadField_FieldNumber_ForceReloadContacts,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ForceReloadField__storage_, forceReloadContacts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "forceReloadHistory",
        .dataTypeSpecific.clazz = GPBObjCClass(ForceReloadHistory),
        .number = ForceReloadField_FieldNumber_ForceReloadHistory,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ForceReloadField__storage_, forceReloadHistory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ForceReloadField class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ForceReloadField__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ForceReloadField_ClearBodyOneOfCase(ForceReloadField *message) {
  GPBDescriptor *descriptor = [ForceReloadField descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ForceReloadDialogs

@implementation ForceReloadDialogs


typedef struct ForceReloadDialogs__storage_ {
  uint32_t _has_storage_[1];
} ForceReloadDialogs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ForceReloadDialogs class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ForceReloadDialogs__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ForceReloadContacts

@implementation ForceReloadContacts


typedef struct ForceReloadContacts__storage_ {
  uint32_t _has_storage_[1];
} ForceReloadContacts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ForceReloadContacts class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ForceReloadContacts__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ForceReloadHistory

@implementation ForceReloadHistory

@dynamic hasPeer, peer;

typedef struct ForceReloadHistory__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
} ForceReloadHistory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = ForceReloadHistory_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ForceReloadHistory__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ForceReloadHistory class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ForceReloadHistory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestChangePassword

@implementation RequestChangePassword

@dynamic oldPassword;
@dynamic newPassword;

typedef struct RequestChangePassword__storage_ {
  uint32_t _has_storage_[1];
  NSString *oldPassword;
  NSString *newPassword;
} RequestChangePassword__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oldPassword",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestChangePassword_FieldNumber_OldPassword,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestChangePassword__storage_, oldPassword),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newPassword",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestChangePassword_FieldNumber_NewPassword,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestChangePassword__storage_, newPassword),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestChangePassword class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestChangePassword__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetSelf

@implementation ResponseGetSelf

@dynamic hasUser, user;

typedef struct ResponseGetSelf__storage_ {
  uint32_t _has_storage_[1];
  User *user;
} ResponseGetSelf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.clazz = GPBObjCClass(User),
        .number = ResponseGetSelf_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseGetSelf__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetSelf class]
                                     rootClass:[AuthenticationRoot class]
                                          file:AuthenticationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetSelf__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
